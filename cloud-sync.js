/**
 * Cloud Sync (R2 via Worker) - 整包双向同步，仅保留最新
 * - 入口挂在 app.html 的认证区下方按钮：同步 & 更多
 * - 仅实现：上传/下载 latest.zip、查询 latest.json、清空备份、容量上限 10MB
 * - 依赖：AV(User), JSZip, 现有 mw_exportAllZip/mw_importZip 的打包与导入结构
 */
(function () {
    const WORKER_BASE = (window.MW_SYNC_WORKER_BASE || 'https://mindword-cloud.timikays.workers.dev');
    const MAX_BYTES = 10 * 1024 * 1024; // 10MB

    // 简易工具
    function isAutoGeneratedEmptyDoc(doc) {
        // 检查是否为自动生成的空文档
        if (!doc) return false;
        return doc.name === '未命名文档' &&
            doc.md === '# 未命名文档\n' &&
            (!doc.images || doc.images.length === 0);
    }
    function fmtBytes(n) {
        if (!Number.isFinite(n)) return '—';
        if (n < 1024) return n + ' B';
        if (n < 1024 * 1024) return (n / 1024).toFixed(1) + ' KB';
        return (n / 1024 / 1024).toFixed(2) + ' MB';
    }
    function fmtTime(iso) {
        if (!iso) return '—';
        try { const d = new Date(iso); return `${d.getFullYear()}-${String(d.getMonth() + 1).padStart(2, '0')}-${String(d.getDate()).padStart(2, '0')} ${String(d.getHours()).padStart(2, '0')}:${String(d.getMinutes()).padStart(2, '0')}`; } catch { return '—'; }
    }
    function getSessionToken() {
        try {
            const u = (typeof AV !== 'undefined' && AV.User && AV.User.current) ? AV.User.current() : null;
            if (u && typeof u.getSessionToken === 'function') {
                const t = u.getSessionToken();
                if (t) return t;
            }
        } catch (_) { }
        // 兜底：从 localStorage 中读取 LeanCloud currentUser 的 sessionToken（兼容项目中两个可能的 AppID 键名）
        try {
            const appIds = [
                'MQ3fZEqOgskJBWGoxOwqG1nT-gzGzoHsz'

            ];
            for (const appId of appIds) {
                const key = 'AV/' + appId + '/currentUser';
                const val = localStorage.getItem(key);
                if (val) {
                    try {
                        const obj = JSON.parse(val);
                        if (obj && obj.sessionToken) return obj.sessionToken;
                    } catch (_) { }
                }
            }
        } catch (_) { }
        return null;
    }
    async function fetchLatestMeta() {
        const token = getSessionToken();
        if (!token) throw new Error('未登录或会话失效');
        const resp = await fetch(`${WORKER_BASE}/sync/latest-meta`, {
            method: 'GET',
            headers: { 'Authorization': `LeanCloud ${token}` }
        });
        if (resp.status === 404) return null;
        if (!resp.ok) throw new Error(`获取云端信息失败(${resp.status})`);
        return await resp.json();
    }
    async function downloadLatestZip() {
        const token = getSessionToken();
        if (!token) throw new Error('未登录或会话失效');
        const resp = await fetch(`${WORKER_BASE}/sync/download-latest`, {
            method: 'POST',
            headers: { 'Authorization': `LeanCloud ${token}` }
        });
        if (!resp.ok) throw new Error(`下载失败(${resp.status})`);
        return await resp.blob();
    }
    async function uploadLatestZip(zipBlob) {
        const token = getSessionToken();
        if (!token) throw new Error('未登录或会话失效');
        if (!zipBlob) throw new Error('无可上传内容');
        if (zipBlob.size > MAX_BYTES) throw new Error('超过10MB容量上限，请清理后再试');
        const resp = await fetch(`${WORKER_BASE}/sync/upload-latest`, {
            method: 'POST',
            headers: { 'Authorization': `LeanCloud ${token}`, 'Content-Type': 'application/zip' },
            body: zipBlob
        });
        if (!resp.ok) throw new Error(`上传失败(${resp.status})`);
        return await resp.json();
    }
    async function clearLatest() {
        const token = getSessionToken();
        if (!token) throw new Error('未登录或会话失效');
        const resp = await fetch(`${WORKER_BASE}/sync/clear`, {
            method: 'POST',
            headers: { 'Authorization': `LeanCloud ${token}` }
        });
        if (!resp.ok) throw new Error(`清空失败(${resp.status})`);
        return await resp.json();
    }

    // 生成整包 ZIP Blob（复用现有导出逻辑，但不saveAs）
    async function generateAllZipBlob() {
        const docs = (typeof mw_loadDocs === 'function') ? mw_loadDocs() : [];
        if (!docs || !docs.length) throw new Error('没有文档可导出');

        const zip = new JSZip();
        const aiFolder = zip.folder('ai');
        try {
            const aiCfg = (typeof mw_fetchAIPlatformConfigsSnapshot === 'function') ? mw_fetchAIPlatformConfigsSnapshot() : null;
            if (aiCfg) aiFolder.file('platform-configs.json', JSON.stringify(aiCfg, null, 2));

            // 从LocalStorage获取用户的提示词模板，而不是使用mw_fetchAIPromptTemplatesSnapshot
            let myPromptTemplates = [];
            let myPromptTemplatesHash = null;
            let myPromptTemplatesLastModified = null;
            try {
                const stored = localStorage.getItem('myPromptTemplates');
                if (stored) {
                    myPromptTemplates = JSON.parse(stored);
                }
                myPromptTemplatesHash = localStorage.getItem('myPromptTemplates_hash');
                myPromptTemplatesLastModified = localStorage.getItem('myPromptTemplates_last_modified');
            } catch (_) { }

            // 如果有用户的提示词模板，保存到zip中
            if (myPromptTemplates && myPromptTemplates.length > 0) {
                aiFolder.file('my-prompt-templates.json', JSON.stringify(myPromptTemplates, null, 2));
                // 添加哈希值和创建时间信息到meta文件
                const metaData = {
                    hash: myPromptTemplatesHash,
                    lastModified: myPromptTemplatesLastModified,
                    count: myPromptTemplates.length,
                    createdAt: Date.now()
                };
                aiFolder.file('my-prompt-templates-meta.json', JSON.stringify(metaData, null, 2));
            }
        } catch (_) { }

        for (const doc of docs) {
            const safeName = (doc.name || 'document').replace(/[\\/:*?"<>|]+/g, '_');
            const root = zip.folder(safeName);
            root.file('index.md', doc.md || '');
            if (doc.images && doc.images.length) {
                const imgFolder = root.folder('images');
                for (const img of doc.images) {
                    const fname = img.name || ('img_' + Date.now() + '.png');
                    const blob = await mw_dataUrlToBlob(img.dataUrl || '', img.mime || 'image/png');
                    const ab = await blob.arrayBuffer();
                    imgFolder.file(fname, ab);
                }
            }
            root.file('meta.json', JSON.stringify({ id: doc.id, name: doc.name, version: doc.version || 1 }, null, 2));
        }
        return await zip.generateAsync({ type: 'blob' });
    }

    // 双向同步为最新：策略——若云端较新则下载覆盖，否则上传本地最新
    async function bidirectionalSyncLatest() {
        try {
            showInfo && showInfo('正在检查云端备份...');
            const cloud = await fetchLatestMeta(); // 可能为 null

            // 本地最近时间：优先使用自维护标记，其次用当前时刻作为上传基准
            let localTs = null;
            try { localTs = Number(localStorage.getItem('mw_last_change_time')) || null; } catch (_) { }

            if (cloud && cloud.updatedAt) {
                const cloudTs = Date.parse(cloud.updatedAt);
                if (!Number.isNaN(cloudTs) && localTs && cloudTs > localTs) {
                    // 云端较新 -> 下载并导入
                    const zipBlob = await downloadLatestZip();
                    await mw_importZip(zipBlob);
                    try { localStorage.setItem('mw_last_change_time', Date.now().toString()); } catch (_) { }
                    showSuccess && showSuccess('已从云端恢复为最新');

                    // 缓存同步数据到本地
                    try {
                        const meta = await fetchLatestMeta();
                        if (meta && meta.fileCount !== undefined && meta.sizeBytes !== undefined) {
                            localStorage.setItem('mw_cloud_sync_cache_en', JSON.stringify({
                                fileCount: meta.fileCount,
                                sizeBytes: meta.sizeBytes,
                                updatedAt: meta.updatedAt || new Date().toISOString()
                            }));
                        }
                    } catch (_) { }

                    setTimeout(updateCloudSyncStatusMenu, 300);

                    // 检查当前文档是否被删除，如果是则切换到第一个有效文档
                    setTimeout(() => {
                        const currentActiveId = mw_getActive();
                        if (currentActiveId) {
                            const docs = (typeof mw_loadDocs === 'function') ? mw_loadDocs() : [];
                            const currentDoc = docs.find(d => d.id === currentActiveId);
                            if (!currentDoc || currentDoc.deletedAt) {
                                console.log('[CloudSync] 当前文档已被删除，准备切换到第一个有效文档');
                                // 切换到第一个未删除的文档
                                const firstValidDoc = docs.find(d => !d.deletedAt);
                                if (firstValidDoc) {
                                    mw_setActive(firstValidDoc.id);
                                    mw_notifyEditorLoad(firstValidDoc);
                                    mw_notifyPreviewLoad(firstValidDoc);
                                    mw_notifyMindmapLoad(firstValidDoc);
                                    console.log('[CloudSync] 已切换到第一个有效文档:', firstValidDoc.id);
                                } else {
                                    // 没有有效文档，创建新文档（但不在同步时创建空文档）
                                    // 这里不自动生成"未命名文档"，让用户手动创建
                                    console.log('[CloudSync] 没有有效文档，等待用户手动创建');
                                }
                            } else if (currentDoc && isAutoGeneratedEmptyDoc(currentDoc)) {
                                // 如果当前文档是自动生成的空文档，切换到第一个有效文档
                                console.log('[CloudSync] 当前文档是自动生成的空文档，准备切换到第一个有效文档');
                                const validDocs = docs.filter(d => !d.deletedAt && !isAutoGeneratedEmptyDoc(d));
                                if (validDocs.length > 0) {
                                    const firstValidDoc = validDocs[0];
                                    mw_setActive(firstValidDoc.id);
                                    mw_notifyEditorLoad(firstValidDoc);
                                    mw_notifyPreviewLoad(firstValidDoc);
                                    mw_notifyMindmapLoad(firstValidDoc);
                                    console.log('[CloudSync] 已切换到第一个有效文档:', firstValidDoc.id);
                                } else {
                                    console.log('[CloudSync] 没有有效文档，保持当前空文档状态');
                                }
                            }
                        }
                    }, 100);

                    return { action: 'download', cloud };
                }
            }

            // 否则本地较新或云端为空 -> 上传
            const zipBlob = await generateAllZipBlob();
            if (zipBlob.size > MAX_BYTES) {
                showError && showError('整包超过10MB上限，请清理图片或拆分后再试');
                return { action: 'abort_oversize' };
            }
            const res = await uploadLatestZip(zipBlob);
            try { localStorage.setItem('mw_last_change_time', Date.now().toString()); } catch (_) { }
            showSuccess && showSuccess('已上传云端最新备份');

            // 缓存同步数据到本地
            try {
                const docs = (typeof mw_loadDocs === 'function') ? mw_loadDocs() : [];
                const fileCount = docs ? docs.length : 0;
                localStorage.setItem('mw_cloud_sync_cache_en', JSON.stringify({
                    fileCount: fileCount,
                    sizeBytes: zipBlob.size,
                    updatedAt: new Date().toISOString()
                }));
            } catch (_) { }

            setTimeout(updateCloudSyncStatusMenu, 300);
            return { action: 'upload', meta: res };
        } catch (e) {
            console.warn('[CloudSync] bidirectional failed', e);
            showError && showError(e.message || '同步失败');
            return { action: 'error', error: e };
        }
    }

    // 更新弹窗信息
    async function refreshModalInfo() {
        const timeEl = document.getElementById('cloud-sync-latest-time');
        const countEl = document.getElementById('cloud-sync-file-count');
        const sizeEl = document.getElementById('cloud-sync-total-size');
        try {
            const meta = await fetchLatestMeta();
            if (!meta) {
                timeEl.textContent = '暂无备份';
                countEl.textContent = '0';
                sizeEl.textContent = '0 B';
                return;
            }
            timeEl.textContent = fmtTime(meta.updatedAt);
            countEl.textContent = String(meta.fileCount ?? '—');
            sizeEl.textContent = fmtBytes(meta.sizeBytes);
        } catch (e) {
            timeEl.textContent = '获取失败';
            countEl.textContent = '—';
            sizeEl.textContent = '—';
        }
    }

    // 更新个人菜单中的云同步状态
    async function updateCloudSyncStatusMenu() {
        const statusEl = document.getElementById('cloud-sync-status-menu');
        const syncBtn = document.getElementById('cloud-sync-btn-menu');
        if (!statusEl) return;

        try {
            // 根据当前语言选择对应的缓存键
            const currentLang = (function () { try { return localStorage.getItem('mw_lang') || 'zh'; } catch (_) { return 'zh'; } })();
            const cacheKey = currentLang === 'en' ? 'mw_cloud_sync_cache_en' : 'mw_cloud_sync_cache_cn';

            // 首先尝试从本地缓存获取数据
            let cachedData = null;
            try {
                const cached = localStorage.getItem(cacheKey);
                if (cached) {
                    cachedData = JSON.parse(cached);
                }
            } catch (_) { }

            // 如果有缓存数据，直接使用缓存数据
            if (cachedData && cachedData.fileCount !== undefined && cachedData.sizeBytes !== undefined) {
                const fileCount = cachedData.fileCount || 0;
                const sizeBytes = cachedData.sizeBytes || 0;
                const updatedAt = cachedData.updatedAt || cachedData.timestamp;

                let timeText = '';
                if (updatedAt) {
                    const date = new Date(updatedAt);
                    const now = new Date();
                    const diffMs = now - date;
                    const diffMins = Math.floor(diffMs / 60000);
                    const diffHours = Math.floor(diffMs / 3600000);
                    const diffDays = Math.floor(diffMs / 86400000);

                    if (diffMins < 1) {
                        timeText = '刚刚';
                    } else if (diffMins < 60) {
                        timeText = `${diffMins}分钟前`;
                    } else if (diffHours < 24) {
                        timeText = `${diffHours}小时前`;
                    } else if (diffDays < 7) {
                        timeText = `${diffDays}天前`;
                    } else {
                        timeText = date.toLocaleDateString('zh-CN', { month: 'short', day: 'numeric' });
                    }
                }

                statusEl.innerHTML = `文件: ${fileCount}个<br>${fmtBytes(sizeBytes)} / 10MB${timeText ? '<br>备份: ' + timeText : ''}`;

                // 根据文件大小改变颜色
                if (sizeBytes > 9.5 * 1024 * 1024) {
                    statusEl.style.color = '#e53935';
                } else if (sizeBytes > 8 * 1024 * 1024) {
                    statusEl.style.color = '#ff9800';
                } else {
                    statusEl.style.color = '#666';
                }

                if (syncBtn) syncBtn.disabled = false;
                return;
            }

            // 如果没有缓存数据，尝试从云端获取
            const meta = await fetchLatestMeta();
            if (!meta) {
                statusEl.textContent = '双向同步为最新';
                statusEl.style.color = '#666';
                if (syncBtn) syncBtn.disabled = false;
                return;
            }

            const docs = (typeof mw_loadDocs === 'function') ? mw_loadDocs() : [];
            // 过滤掉已删除的文档和自动生成的空文档，只统计有效文档
            const validDocs = docs ? docs.filter(doc => !doc.deletedAt && !isAutoGeneratedEmptyDoc(doc)) : [];
            const fileCount = validDocs.length;
            const sizeBytes = meta.sizeBytes || 0;
            const updatedAt = meta.updatedAt || new Date().toISOString();

            // 保存到缓存，下次可以直接使用
            const cacheData = { fileCount, sizeBytes, updatedAt };
            localStorage.setItem(cacheKey, JSON.stringify(cacheData));

            // 计算相对时间
            let timeText = '';
            if (updatedAt) {
                const date = new Date(updatedAt);
                const now = new Date();
                const diffMs = now - date;
                const diffMins = Math.floor(diffMs / 60000);
                const diffHours = Math.floor(diffMs / 3600000);
                const diffDays = Math.floor(diffMs / 86400000);

                if (diffMins < 1) {
                    timeText = '刚刚';
                } else if (diffMins < 60) {
                    timeText = `${diffMins}分钟前`;
                } else if (diffHours < 24) {
                    timeText = `${diffHours}小时前`;
                } else if (diffDays < 7) {
                    timeText = `${diffDays}天前`;
                } else {
                    timeText = date.toLocaleDateString('zh-CN', { month: 'short', day: 'numeric' });
                }
            }

            statusEl.innerHTML = `文件: ${fileCount}个<br>${fmtBytes(sizeBytes)} / 10MB${timeText ? '<br>备份: ' + timeText : ''}`;

            // 根据文件大小改变颜色
            if (sizeBytes > 9.5 * 1024 * 1024) {
                statusEl.style.color = '#e53935';
            } else if (sizeBytes > 8 * 1024 * 1024) {
                statusEl.style.color = '#ff9800';
            } else {
                statusEl.style.color = '#666';
            }

            if (syncBtn) syncBtn.disabled = false;
        } catch (e) {
            statusEl.textContent = '获取失败';
            statusEl.style.color = '#e53935';
            if (syncBtn) syncBtn.disabled = true;
        }
    }

    // 事件绑定与显示控制
    function initCloudSyncUI() {
        const userBox = document.getElementById('auth-user');
        const controls = document.getElementById('cloud-sync-controls');
        const syncBtn = document.getElementById('cloud-sync-sync-btn');
        const moreBtn = document.getElementById('cloud-sync-more-btn');
        const modal = document.getElementById('cloud-sync-modal');
        const modalSync = document.getElementById('cloud-sync-modal-sync');
        const modalClear = document.getElementById('cloud-sync-modal-clear');
        const modalClose = document.getElementById('cloud-sync-modal-close');
        const menuSyncBtn = document.getElementById('cloud-sync-sync-btn-menu');

        // 显示控制：仅在已登录且语言为英文时显示
        try {
            const token = getSessionToken();
            const lang = (function () { try { return localStorage.getItem('mw_lang') || 'zh'; } catch (_) { return 'zh'; } })();
            if (token && userBox && controls) {
                controls.style.display = (lang === 'en') ? 'inline-flex' : 'none';
            } else if (controls) {
                controls.style.display = 'none';
            }
        } catch (_) { }
        // 初始化结束后再次让语言逻辑统一一次，避免闪烁
        try { if (typeof window.__mw_applyLangToUI === 'function') setTimeout(window.__mw_applyLangToUI, 0); } catch (_) { }

        if (syncBtn) {
            syncBtn.onclick = () => { bidirectionalSyncLatest(); };
        }
        if (menuSyncBtn) {
            menuSyncBtn.onclick = () => { bidirectionalSyncLatest(); };
        }
        if (moreBtn && modal) {
            moreBtn.onclick = async () => {
                modal.style.display = 'flex';
                await refreshModalInfo();
            };
        }
        if (modalClose && modal) {
            modalClose.onclick = () => { modal.style.display = 'none'; };
            modal.addEventListener('click', (e) => { if (e.target === modal) modal.style.display = 'none'; });
        }
        if (modalSync) {
            modalSync.onclick = async () => { await bidirectionalSyncLatest(); await refreshModalInfo(); };
        }
        if (modalClear) {
            modalClear.onclick = async () => {
                try { await clearLatest(); showSuccess && showSuccess('已清空云端备份'); } catch (e) { showError && showError(e.message || '清空失败'); }
                await refreshModalInfo();
            };
        }

        // 初始化个人菜单状态
        setTimeout(() => {
            updateCloudSyncStatusMenu();
        }, 100);
    }

    // 初始化时机：DOM 就绪后执行一次；并在认证区刷新后再次尝试
    document.addEventListener('DOMContentLoaded', () => { initCloudSyncUI(); });
    window.addEventListener('storage', (e) => {
        if (e.key && e.key.startsWith('AV/')) { setTimeout(initCloudSyncUI, 300); }
    });
    // 暴露手动刷新入口供现有 refreshAuthUI 调用（如需）
    window.__mw_initCloudSyncUI = initCloudSyncUI;

    // 将更新函数暴露到全局作用域，供其他文件调用
    window.updateCloudSyncStatusMenu = updateCloudSyncStatusMenu;
})();
