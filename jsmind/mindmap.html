<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>思维导图编辑器</title>
  <link rel="stylesheet" href="../styles.css">
  <link type="text/css" rel="stylesheet" href="../jsmind-local/jsmind.css" />
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/css/bootstrap.min.css" />
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.4/dist/jquery.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/js/bootstrap.bundle.min.js"></script>



  <link rel="stylesheet" href="mindmap.css">
  <style>
    .requires-single-selection {
      display: none !important;
    }

    .requires-single-selection.visible {
      display: inline-block !important;
    }
  </style>
</head>

</head>

<body>
  <div class="toolbar">
    <!-- 批量操作工具栏 -->


    <span class="ico-btn" role="button" onclick="downloadMindmap()" tabindex="0" title="下载图片"
      style="--ico: url('res/download.svg'); "></span>
    <span class="ico-btn" role="button" onclick="exportData()" tabindex="0" title="查看JSON"
      style="--ico: url('res/code.svg'); "></span>
    <span class="ico-btn" role="button" onclick="aiGenerateInitialTree()" tabindex="0" title="生成初始树"
      style="--ico: url('../res/生成初始树.svg');"></span>

    <!-- AI 快捷操作 -->
    <div id="aiQuickActions" style="display:inline-flex;gap:8px;align-items:center;">
      <span style="color: gainsboro;"> | </span>
      <span class="ico-btn requires-single-selection" role="button" onclick="aiCreateChild()" tabindex="0" title="创建子级"
        style="--ico: url('../res/添加子级.svg');"></span>
      <span class="ico-btn requires-single-selection" role="button" onclick="aiCreateSibling()" tabindex="0"
        title="创建同级" style="--ico: url('../res/添加同级.svg');"></span>
      <span class="ico-btn requires-single-selection" role="button" onclick="aiExpandNotes()" tabindex="0" title="扩写备注"
        style="--ico: url('../res/扩写备注.svg');"></span>
      <span class="ico-btn requires-single-selection" role="button" onclick="quickModifyNode()" tabindex="0"
        title="修改主题" style="--ico: url('../res/edit.svg');"></span>
      <span class="ico-btn" role="button" onclick="quickDeleteNode()" tabindex="0" title="删除节点"
        style="--ico: url('../res/删除.svg');"></span>

    </div>


    <!-- 图标选择器下拉菜单（已定制：隐藏默认 caret、只保留网格内第一个“清除”按钮） -->
    <style>
      /* 隐藏 Bootstrap 的下拉小箭头并去掉可能的聚焦动画/outline */
      #iconPickerBtn.dropdown-toggle::after {
        display: none !important;
      }

      #iconPickerBtn:focus {
        outline: none !important;
        box-shadow: none !important;
      }

      /* 工具栏内图标按钮保证 emoji 可见 */
      #iconGridToolbar .icon-picker-item {
        font-family: "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji", system-ui, sans-serif;
        color: #222 !important;
        font-size: 20px !important;
        line-height: 1;
        padding: 0;
        background: white !important;
      }

      /* 去掉下拉菜单自身的动画（若存在） */
      #iconPickerDropdown .dropdown-menu {
        transition: none !important;
        -webkit-transition: none !important;
        -moz-transition: none !important;

      }
    </style>

    <div class="dropdown" id="iconPickerDropdown" style="display: inline-block;">

      <span id="iconPickerBtn" class="ico-btn dropdown-toggle" role="button" data-toggle="dropdown" aria-haspopup="true"
        aria-expanded="false" title="选择图标" tabindex="0" style="--ico: url('res/tag.svg');"></span>
      <div class="dropdown-menu" aria-labelledby="iconPickerBtn"
        style="width: 360px; max-height: 420px; overflow-y: auto; overflow-x: hidden;">
        <div style="padding: 12px;">
          <h6 style="margin: 0 0 8px 0; font-size: 14px; font-weight: 600;">选择图标</h6>
          <div id="iconGridToolbar"
            style="display: grid; grid-template-columns: repeat(7, 1fr); gap: 6px; padding-bottom:8px; box-sizing: border-box; column-gap:6px;">
            <!-- 图标将通过JavaScript动态生成（第一个为清除） -->
          </div>
        </div>
        <!-- 已移除重复的底部清除按钮（仅保留网格中的第一个清除按钮） -->
      </div>
    </div>

    <!-- batchOperations 保留在 DOM 中但会被移动到画布左上（通过脚本在非移动端显示） -->
    <div id="batchOperations"
      style="display: none; float: right; padding: 1px 6px; background: rgba(76, 154, 255, 0.1); border-radius: 4px; border: 1px solid #4c9aff;">
      <span style="color: #4c9aff; font-size: 12px; ">已选中 <span id="selectedCount">0</span>
        个节点</span>
    </div>

    <!-- 右侧三个简单复选框：详情面板 / 显示节点类型 / 显示列表节点 -->
    <div id="toolbarToggles"
      style="margin-left:auto;display:flex;gap:12px;align-items:flex-end;justify-content:flex-end;">
      <span id="toggleNodeDetailsBtn" class="ico-btn state-on" role="button" tabindex="0" aria-pressed="true"
        title="详情面板" style="--ico: url('res/detail.svg'); "></span>
      <label class="mw-toggle-showtype"
        style="display:none;flex-direction:column;align-items:center;font-size:12px;margin:0 4px;">
        <input id="toggleShowNodeTypeCheckbox" type="checkbox" style="width:18px;height:18px;margin-bottom:6px;">
        <span style="display:block;margin-top:0;">显示类型</span>
      </label>
      <label class="mw-toggle-showtitleonly"
        style="display:none;flex-direction:column;align-items:center;font-size:12px;margin:0 4px;">
        <input id="toggleShowListNodesCheckbox" type="checkbox" style="width:18px;height:18px;margin-bottom:6px;">
        <span style="display:block;margin-top:0;">只看标题</span>
      </label>
    </div>





  </div>

  <div class="main-container">
    <div id="fullScreenMindmap"></div>



    <!-- 浮动节点详情面板（可关闭），保留内部字段和功能 -->
    <div id="nodeDetails" role="dialog" aria-hidden="true" aria-label="节点详情">
      <div class="panel-header">
        <strong>节点详情</strong>
        <button class="panel-close-btn" aria-label="关闭节点详情" onclick="hideNodeDetails()">✕</button>
      </div>
      <div style="margin-bottom: 15px;margin-top: 10px; display: flex; gap: 10px;">
        <span class="ico-btn requires-single-selection" role="button" onclick="aiCreateChild()" tabindex="0"
          title="创建子级" style="--ico: url('../res/添加子级.svg');"></span>
        <span class="ico-btn requires-single-selection" role="button" onclick="aiCreateSibling()" tabindex="0"
          title="创建同级" style="--ico: url('../res/添加同级.svg');"></span>
        <span class="ico-btn requires-single-selection" role="button" onclick="aiExpandNotes()" tabindex="0"
          title="扩写备注" style="--ico: url('../res/扩写备注.svg');"></span>
        <span class="ico-btn requires-single-selection" role="button" onclick="quickModifyNode()" tabindex="0"
          title="修改主题" style="--ico: url('../res/edit.svg');"></span>
        <span class="ico-btn" role="button" onclick="quickDeleteNode()" tabindex="0" title="删除节点"
          style="--ico: url('../res/删除.svg');"></span>
        <span class="ico-btn" role="button"
          onclick="(function(){try{function genId(){return 'r_'+Math.random().toString(36).slice(2,10);}var requestId=genId();var payload={initialView:'config',platformConfig:{},modelConfig:{},options:{}};if(typeof window.openAIServiceModal==='function'){try{window.openAIServiceModal(Object.assign({},payload,{requestId:requestId}));return;}catch(e){console.warn('openAIServiceModal failed',e);} }try{window.parent.postMessage({type:'AI_MODAL_OPEN_REQUEST',requestId:requestId,payload:payload},'*');}catch(e){console.error('send AI config open request failed',e);} }catch(e){console.warn(e);} })()"
          tabindex="0" title="AI配置" style="--ico: url('../res/setting.svg');"></span>
        <!-- <button class="btn"
            onclick="(function(){try{function genId(){return 'r_'+Math.random().toString(36).slice(2,10);}var requestId=genId();var payload={initialView:'config',platformConfig:{},modelConfig:{},options:{}};if(typeof window.openAIServiceModal==='function'){try{window.openAIServiceModal(Object.assign({},payload,{requestId:requestId}));return;}catch(e){console.warn('openAIServiceModal failed',e);} }try{window.parent.postMessage({type:'AI_MODAL_OPEN_REQUEST',requestId:requestId,payload:payload},'*');}catch(e){console.error('send AI config open request failed',e);} }catch(e){console.warn(e);} })()"
            style="flex: 0 0 40px; background: #ffffff;" title="AI配置">⚙️</button> -->
      </div>
      <div id="nodeDetailsEmpty" style="display:none; padding:24px; text-align:center; color:#64748b;">
        <img src="../res/empty.svg" alt="空状态" style="width:72px;height:72px;opacity:0.9;margin-bottom:12px;">
        <div>请选择一个节点</div>
      </div>

      <div id="nodeDetailsForm">
        <div id="nodeInfo"></div>

        <div class="form-group">
          <label for="nodeTopic">节点主题:</label>
          <textarea id="nodeTopic" placeholder="输入节点主题..." rows="3"
            style="width:100%; resize:vertical; line-height:1.4em;"></textarea>
        </div>

        <div class="form-group">
          <label for="nodeNotes">节点备注:</label>
          <textarea id="nodeNotes" placeholder="输入节点备注..."></textarea>
        </div>



        <!-- 自动更新提示 -->
        <div id="autoUpdateIndicator"
          style="display: none; margin-bottom: 10px; padding: 5px 10px; background: #d4edda; border: 1px solid #c3e6cb; border-radius: 4px; color: #155724; font-size: 12px; text-align: center;">
          <span style="display: inline-block; animation: pulse 1s ease-in-out;">✓</span> 已自动更新
        </div>

      </div>

      <!-- 通知桥接器 -->
      <script src="../notification-bridge.js"></script>

    </div>
  </div>
  </div>

  <script src="../jsmind-local/jsmind.js"></script>
  <script src="../jsmind-local/jsmind.draggable-node.js"></script>
  <script src="https://unpkg.com/dom-to-image@2.6.0/dist/dom-to-image.min.js"></script>
  <!-- 使用与jsMind 0.5.7版本匹配的截图插件 -->
  <script src="../jsmind-local/jsmind.screenshot.js"></script>
  <script type="module" src="../converter/sync.js"></script>
  <script type="module" src="../converter/load.js"></script>
  <script src="plugins/undo_manager.js"></script>




  <script src="icons.js"></script>
  <script type="module" src="mindmap-core.js"></script>
  <script>

    /* mindmap-ui.js - UI related extracted scripts */

    // 动作分发器：根据 actionType 处理不同入口
    // ctx: { selectedNode, itemsToInsert, childNodes, childTitles, parsedText }
    function applyAIAction(actionType, ctx) {
      try {
        const sel = ctx.selectedNode;
        if (!sel) {
          showWarning && showWarning('请先选择一个节点');
          return;
        }
        const items = Array.isArray(ctx.itemsToInsert) ? ctx.itemsToInsert : [];
        const addMany = function (parentId) {
          items.forEach(function (item) {
            try {
              var topicStr = '';
              var nodeData = {};
              if (typeof item === 'string') {
                topicStr = item;
              } else if (item && typeof item === 'object') {
                topicStr = (item.topic !== undefined) ? String(item.topic) : '';
                if (item.level !== undefined && item.level !== null) nodeData.level = item.level;
                if (item.raw) nodeData.raw = item.raw;
                if (item.notes) nodeData.notes = item.notes;
              } else {
                topicStr = String(item);
              }
              if (!topicStr) return;
              const nid = 'n_' + Math.random().toString(36).slice(2, 9);
              try {
                if (Object.keys(nodeData).length > 0) {
                  jm.add_node(parentId, nid, topicStr, nodeData);
                } else {
                  jm.add_node(parentId, nid, topicStr);
                }
              } catch (_err) {
                jm.add_node(parentId, nid, topicStr);
              }
            } catch (e) { console.warn('批量插入节点项失败', e); }
          });
        };

        switch (actionType) {
          case 'create_sibling': {
            // 插入同级：优先通过真实节点对象的 parent，兼容回退到 jm.get_parent(id)
            var nodeObj = null, parent = null;
            try { nodeObj = jm.get_node ? jm.get_node(sel.id) : sel; } catch (_) { nodeObj = sel; }
            try { parent = (nodeObj && nodeObj.parent) ? nodeObj.parent : null; } catch (_) { parent = null; }
            if (!parent) {
              try { parent = (jm.get_parent && sel && sel.id) ? jm.get_parent(sel.id) : null; } catch (_) { parent = null; }
            }
            if (parent && parent.id) {
              addMany(parent.id);
            } else {
              // 根节点无同级：降级为添加子级并提示
              addMany(sel.id);
              try { showWarning && showWarning('根节点无法添加同级，已改为添加子级'); } catch (_) { }
            }
            break;
          }
          case 'expand_notes': {
            // 扩写备注：将解析文本追加到选中节点备注（用空行隔开），无备注则直接写入
            try {
              var node = jm.get_node ? jm.get_node(sel.id) : sel;
              if (node) {
                node.data = node.data || {};
                var newText = String(ctx.parsedText || '').replace(/\r/g, '').trim();
                var oldText = '';
                try { oldText = String((node.data && node.data.notes) || '').replace(/\r/g, ''); } catch (_) { oldText = ''; }
                console.debug('[MW][AI][expand_notes] before', { id: node.id, oldLen: (oldText || '').length, appendLen: (newText || '').length });
                node.data.notes = oldText ? (oldText.replace(/\\s+$/, '') + '\\n\\n' + newText) : newText;
                try { node.notes = node.data.notes; } catch (_) { }
                console.debug('[MW][AI][expand_notes] after', { id: node.id, totalLen: ((node.data && node.data.notes) ? node.data.notes.length : 0) });
                jm.update_node(node.id, node.topic || '');
                // 同步详情面板 textarea 并触发输入事件，复用 handleAutoUpdate 的保存/同步流程
                try {
                  var ta = document.getElementById('nodeNotes');
                  if (ta) {
                    ta.value = node.data.notes || '';
                    console.debug('[MW][AI][expand_notes] sync textarea#nodeNotes -> dispatch input');
                    ta.dispatchEvent(new Event('input', { bubbles: true }));
                  } else {
                    console.debug('[MW][AI][expand_notes] textarea#nodeNotes not found');
                  }
                } catch (e) { console.warn('[MW][AI][expand_notes] textarea sync failed', e); }
                console.debug('[MW][AI][expand_notes] funcs', {
                  refreshAllNotesDisplay: typeof refreshAllNotesDisplay,
                  saveToLocalStorage: typeof saveToLocalStorage,
                  showAutoUpdateIndicator: typeof showAutoUpdateIndicator,
                  debouncedSave: typeof debouncedSave,
                  w_refreshAllNotesDisplay: typeof window.refreshAllNotesDisplay,
                  w_saveToLocalStorage: typeof window.saveToLocalStorage,
                  w_showAutoUpdateIndicator: typeof window.showAutoUpdateIndicator,
                  w_debouncedSave: typeof window.debouncedSave
                });
                try {
                  if (typeof refreshAllNotesDisplay === 'function') refreshAllNotesDisplay();
                  else if (typeof window.refreshAllNotesDisplay === 'function') window.refreshAllNotesDisplay();
                } catch (e1) { console.warn('[MW][AI][expand_notes] refreshAllNotesDisplay failed', e1); }
                try {
                  if (typeof saveToLocalStorage === 'function') saveToLocalStorage();
                  else if (typeof window.saveToLocalStorage === 'function') window.saveToLocalStorage();
                } catch (e2) { console.warn('[MW][AI][expand_notes] saveToLocalStorage failed', e2); }
                try {
                  if (typeof showAutoUpdateIndicator === 'function') showAutoUpdateIndicator();
                  else if (typeof window.showAutoUpdateIndicator === 'function') window.showAutoUpdateIndicator();
                } catch (e3) { console.warn('[MW][AI][expand_notes] showAutoUpdateIndicator failed', e3); }
                try {
                  if (typeof debouncedSave === 'function') debouncedSave();
                  else if (typeof window.debouncedSave === 'function') window.debouncedSave();
                } catch (e4) { console.warn('[MW][AI][expand_notes] debouncedSave failed', e4); }
              }
            } catch (e) {
              console.warn('更新备注失败', e);
              showError && showError('更新备注失败');
            }
            break;
          }
          case 'generate_initial_tree': {
            // 生成初始树：清空并创建新的根节点，然后按 level 构造层级树
            try {
              // 1) 根主题：优先占位符 name，其次选中节点主题，最后兜底
              var rootTitle = '';
              try {
                if (ctx.placeholders && ctx.placeholders.name) {
                  var nv = ctx.placeholders.name;
                  rootTitle = (nv && typeof nv === 'object') ? String(nv.value ?? '') : String(nv ?? '');
                }
              } catch (_) { }
              if (!rootTitle) {
                try { rootTitle = sel.topic || ''; } catch (_) { rootTitle = ''; }
              }
              if (!rootTitle) rootTitle = '新思维导图';

              // 2) 清空当前图并创建新根
              var rootId = 'root_' + Math.random().toString(36).slice(2, 9);
              try {
                var mind = {
                  meta: { name: 'mindword', author: 'mindword' },
                  format: 'node_array',
                  data: [{ id: rootId, isroot: true, topic: rootTitle }]
                };
                jm.show(mind);
              } catch (e) {
                // 回退：若 show 失败，尝试直接添加根
                try { jm.add_node(null, rootId, rootTitle); } catch (_) { }
              }

              // 3) 按 level 构造层级节点
              var stack = [];
              stack[1] = { id: rootId, level: 1 };
              const itemsToBuild = Array.isArray(ctx.itemsToInsert) ? ctx.itemsToInsert : [];
              itemsToBuild.forEach(function (item) {
                try {
                  var topicStr = '';
                  var nodeData = {};
                  var level = 1;
                  var notes = '';

                  if (typeof item === 'string') {
                    topicStr = item;
                  } else if (item && typeof item === 'object') {
                    topicStr = (item.topic !== undefined) ? String(item.topic) : '';
                    if (item.level !== undefined && item.level !== null) level = Math.max(1, parseInt(item.level, 10) || 1);
                    if (item.raw) nodeData.raw = item.raw;
                    if (item.notes) notes = item.notes;
                  } else {
                    topicStr = String(item);
                  }
                  if (!topicStr) return;

                  if (level < 1) level = 1;
                  var parentInfo = stack[level - 1] || stack[1];
                  var parentId = parentInfo ? parentInfo.id : rootId;

                  var nid = 'n_' + Math.random().toString(36).slice(2, 9);
                  var data = {};
                  if (notes) data.notes = notes;
                  if (Object.keys(nodeData).length > 0) Object.assign(data, nodeData);

                  try { jm.add_node(parentId, nid, topicStr, data); }
                  catch (_) { jm.add_node(parentId, nid, topicStr); }

                  stack[level] = { id: nid, level: level };
                  var li = level + 1;
                  while (stack[li]) { delete stack[li]; li++; }
                } catch (e) { console.warn('初始树插入项失败', e); }
              });

              try { if (typeof debouncedSave === 'function') debouncedSave(); } catch (_) { }
              showSuccess && showSuccess('已生成初始树：' + rootTitle + '（共 ' + (Array.isArray(itemsToBuild) ? itemsToBuild.length : 0) + ' 项）');
            } catch (e) {
              console.warn('生成初始树失败', e);
              showError && showError('生成初始树失败');
            }
            break;
          }
          case 'create_child':
          default: {
            addMany(sel.id);
            break;
          }
        }

        try { if (typeof debouncedSave === 'function') debouncedSave(); } catch (e) { }
      } catch (e) {
        console.error('applyAIAction 处理失败', e);
        showError && showError('处理 AI 动作失败: ' + (e && e.message ? e.message : String(e)));
      }
    }


    // --- extracted block from original HTML ---
    // AI扩写函数（改为使用父层托管的 AI 弹窗组件，modal 模式）

    // 入口快捷函数：通过 window.__mw_next_* 传递 actionType / 模板 / 占位符
    function aiCreateChild() {
      window.__mw_next_actionType = 'create_child';
      window.__mw_next_templateKey = '扩展子节点';
      expandWithAI();
    }
    function aiCreateSibling() {
      window.__mw_next_actionType = 'create_sibling';
      window.__mw_next_templateKey = '创建同级'; // 如有专用模板，可改为 '扩展同级'
      expandWithAI();
    }
    function aiExpandNotes() {
      window.__mw_next_actionType = 'expand_notes';
      window.__mw_next_templateKey = '扩写备注';
      expandWithAI();
    }
    function aiGenerateInitialTree() {
      try {
        var theme = prompt('请输入初始主题（根节点）');
        if (!theme) { showWarning && showWarning('请输入主题'); return; }
        // 若未选中节点，尝试选中根节点，便于插入
        try {
          var root = jm.get_root && jm.get_root();
          if (root && root.id) jm.select_node(root.id);
        } catch (_) { }
        window.__mw_next_actionType = 'generate_initial_tree';
        window.__mw_next_templateKey = '生成初始树';
        window.__mw_next_placeholders = { name: { desc: '初始主题', value: theme } };
        expandWithAI();
      } catch (e) { showError && showError('生成初始树失败: ' + (e.message || e)); }
    }
    // 简易修改/删除（占位实现）
    function quickModifyNode() {
      try {
        var sel = jm.get_selected_node && jm.get_selected_node();
        if (!sel) { showWarning && showWarning('请先选择一个节点'); return; }
        var newTitle = prompt('修改节点主题', sel.topic || '');
        if (newTitle !== null && newTitle.trim()) jm.update_node(sel.id, newTitle.trim());
        try { if (typeof debouncedSave === 'function') debouncedSave(); } catch (_) { }
      } catch (e) { showError && showError('修改失败'); }
    }
    function quickDeleteNode() {
      try {
        var selectedNodes = (typeof window.getMultiSelection === 'function') ? window.getMultiSelection() : [];
        if (selectedNodes.length > 1) {
          if (confirm('确认删除所有选中的 ' + selectedNodes.length + ' 个节点？')) {
            selectedNodes.forEach(function (nodeId) {
              jm.remove_node(nodeId);
            });
            try { if (typeof debouncedSave === 'function') debouncedSave(); } catch (_) { }
          }
        } else {
          var sel = jm.get_selected_node && jm.get_selected_node();
          if (!sel) { showWarning && showWarning('请先选择一个节点'); return; }
          if (confirm('确认删除该节点及其子节点？')) {
            jm.remove_node(sel.id);
            try { if (typeof debouncedSave === 'function') debouncedSave(); } catch (_) { }
          }
        }
      } catch (e) { showError && showError('删除失败'); }
    }

    // AI扩写函数（改为使用父层托管的 AI 弹窗组件，modal 模式）
    function expandWithAI() {
      try {
        const selectedNode = jm.get_selected_node();
        if (!selectedNode) {
          showWarning('请先选择一个节点');
          return;
        }

        // 构造 requestId
        function genId() { return 'r_' + Math.random().toString(36).slice(2, 10); }
        const requestId = genId();

        // 准备 templateData：使用预设模板（扩展子节点），并注入真实上下文
        var topic = selectedNode.topic || '';
        // 优先从最新节点数据读取备注；回退到详情面板输入
        var _nodeLatest = null;
        try { _nodeLatest = jm.get_node ? jm.get_node(selectedNode.id) : selectedNode; } catch (_) { _nodeLatest = selectedNode; }
        var notes = (_nodeLatest && _nodeLatest.data && _nodeLatest.data.notes) ? _nodeLatest.data.notes
          : (document.getElementById('nodeNotes') ? document.getElementById('nodeNotes').value : '');

        // 计算 fullPath 与 siblingNodes（若可用）
        function _computeFullPath(n) {
          try {
            if (typeof window.getNodeFullPath === 'function') return window.getNodeFullPath(n);
          } catch (_) { /* ignore */ }
          try {
            var path = [];
            var cur = n;
            while (cur) {
              path.unshift(cur.topic || '');
              var p = jm.get_parent ? jm.get_parent(cur.id) : null;
              if (!p) break;
              cur = p;
            }
            return path.join(' / ');
          } catch (e) {
            return n.topic || '';
          }
        }
        // 统一使用真实节点对象，避免轻量对象丢失父链/children
        var realSel = null;
        try { realSel = jm.get_node ? jm.get_node(selectedNode.id) : selectedNode; } catch (_) { realSel = selectedNode; }

        // 完整路径：从根到当前节点
        function _computeFullPathStrict(n) {
          try {
            // 若有外部工具函数则优先
            if (typeof window.getNodeFullPath === 'function') return window.getNodeFullPath(n);
          } catch (_) { /* ignore */ }
          try {
            var path = [];
            var cur = n;
            while (cur) {
              path.unshift(cur.topic || '');
              cur = (jm.get_parent && cur.id) ? jm.get_parent(cur.id) : null;
            }
            return path.join(' / ');
          } catch (e) { return n && (n.topic || ''); }
        }
        var fullPath = '';
        try {
          fullPath = (realSel && realSel.data && (realSel.data.fullPath || (realSel.data.data && realSel.data.data.fullPath))) || '';
        } catch (e) {
          fullPath = (realSel && realSel.topic) ? realSel.topic : '';
        }

        // 兄弟节点：直接从节点数据中读取（优先使用 data.siblingNodes）
        var siblingNodes = '';
        try {
          var sib = (realSel && realSel.data && (realSel.data.siblingNodes || (realSel.data.data && realSel.data.data.siblingNodes))) || [];
          if (Array.isArray(sib)) {
            siblingNodes = sib.filter(Boolean).join(', ');
          } else if (typeof sib === 'string') {
            siblingNodes = sib;
          }
        } catch (e) { siblingNodes = ''; }

        // 从 prompt-templates.json 中读取“扩展子节点”模板内容（若无法访问则回退）
        var templateText = '';
        try {
          var tplList = window.__prompt_templates || null;
          if (!tplList) {
            // lazy load from ai/newai/prompt-templates.json if available via fetch (silent)
            try {
              // sync attempt may fail in file://; fallback to default string
              // we will try to read from a global if demo pages preloaded templates
              tplList = window.__prompt_templates || tplList;
            } catch (err) { tplList = tplList || null; }
          }
          if (Array.isArray(tplList)) {
            var key = (typeof window.__mw_next_templateKey === 'string' && window.__mw_next_templateKey) ? window.__mw_next_templateKey : '扩展子节点';
            for (var ti = 0; ti < tplList.length; ti++) {
              var t = tplList[ti];
              if (t && t.name === key) { templateText = t.content || ''; break; }
            }
          }
        } catch (e) { templateText = ''; }

        // 最终回退策略：如果没有模板则使用 topic 或简单占位符
        if (!templateText || !String(templateText).trim()) {
          templateText = topic || '{{name}}';
        }

        var payload = {
          // modal 模式：不设置 mode 或确保不是 'direct'
          platformConfig: {}, // 可选：留空由父页面选择已保存平台或打开配置
          modelConfig: {},
          templateData: {
            templateText: templateText,
            placeholders: {
              // 对齐新组件默认占位符格式 {{name}}
              name: { desc: '节点主题', value: topic },
              notes: { desc: '节点备注', value: notes },
              fullPath: { desc: '节点完整路径', value: fullPath },
              siblingNodes: { desc: '同级兄弟节点（以逗号分隔）', value: siblingNodes },
              nodeId: { desc: '节点ID', value: selectedNode.id },
              // 补充上下文摘要，复用旧逻辑思想：提供可读文本，便于模板直接引用 {{context}}
              context: {
                desc: '节点上下文摘要',
                value: (function () {
                  try {
                    var lines = [];
                    lines.push('节点: ' + (topic || ''));
                    lines.push('路径: ' + (fullPath || ''));
                    if (notes) lines.push('备注: ' + notes);
                    if (parent && (parent.topic || '')) lines.push('父节点: ' + (parent.topic || ''));
                    if (siblingNodes) lines.push('同级兄弟: ' + siblingNodes);
                    var childTitles = (selectedNode.children || []).map(function (c) { return c.topic || ''; }).filter(Boolean).join(', ');
                    if (childTitles) lines.push('已有子节点: ' + childTitles);
                    return lines.join('\\n');
                  } catch (e) {
                    return (topic || '') + '\\n' + (fullPath || '');
                  }
                })()
              }
            }
          },
          options: {}
        };

        // 合并外部指定的占位符（如生成初始树传入主题）
        try {
          var extraPH = (window.__mw_next_placeholders && typeof window.__mw_next_placeholders === 'object') ? window.__mw_next_placeholders : null;
          if (extraPH) {
            Object.keys(extraPH).forEach(function (k) {
              payload.templateData.placeholders[k] = extraPH[k];
            });
          }
        } catch (_) { }

        // 指定模板 key 与参数映射；actionType 支持外部预设
        try { payload.templateData.templateKey = (window.__mw_next_templateKey || '扩展子节点'); } catch (e) { }
        try { payload.params = payload.templateData.placeholders; } catch (e) { }
        try { payload.actionType = (window.__mw_next_actionType || 'create_child'); } catch (_) { }

        // 临时消息处理器：等待 AI_MODAL_RESULT 回来
        const onMessage = function (e) {
          try {
            const msg = e && e.data;
            if (!msg || (msg.type !== 'AI_MODAL_RESULT' && msg.type !== 'AI_MODAL_SAVE_OUTPUT') || msg.requestId !== requestId) return;
            // 清理
            window.removeEventListener('message', onMessage);
            clearTimeout(timeoutT);

            if (msg.type === 'AI_MODAL_SAVE_OUTPUT' || msg.status === 'ok') {
              try {
                const detail = msg.detail || {};
                // 期望 detail 中包含生成的内容（例如 detail.output 或 detail.text）
                // 支持两种常见格式：detail.output（带 [OUTPUT] 包裹）或 detail.text
                const outText = detail.output || detail.text || (detail.result && detail.result.text) || msg.output || '';
                if (!outText) {
                  showWarning('AI 未返回有效内容');
                  return;
                }

                // 将 AI 返回的文本解析为若干子节点（简单按换行分割标题行或 Markdown 标题）
                // 若返回结构化 [OUTPUT] 标签，尝试提取标签内内容
                let parsed = outText;
                const m = /\[OUTPUT\]([\s\S]*)\[\/OUTPUT\]/i.exec(outText);
                if (m && m[1]) parsed = m[1].trim();

                // 解析策略升级：
                // - 仅把以 '#' 或以列表符（'-' '*' '+' 或 数字序号）开头的行作为节点
                // - 支持多层级：markdown 标题以 '#' 个数为层级；列表项根据前导空格数推断层级（每2个空格升一层）
                // - 返回 childTitles 为对象数组：{ topic: '文本', level: N }
                // 处理兼容性：先去除 \r 再按 '\n' 分割
                var normalized = (parsed || '').replace(/\r/g, '').replace(/\[OUTPUT\]|\[\/OUTPUT\]/gi, '');
                var rawLines = normalized.split('\n');
                var childNodes = [];
                var childTitles = [];
                var lastNode = null;

                rawLines.forEach(function (raw) {
                  if (!raw || !raw.trim()) return;
                  var line = raw.replace(/\t/g, '  '); // 把 tab 视作两个空格
                  var trimmed = line.trim();

                  // 检查 markdown 标题，如: "# Title" 或 "## Title"
                  var headerMatch = trimmed.match(/^(#{1,6})\s+(.*)$/);
                  if (headerMatch) {
                    var level = headerMatch[1].length;
                    var topic = headerMatch[2].trim();
                    if (topic) {
                      var nodeObj = { topic: topic, level: level, notes: '' };
                      childNodes.push(nodeObj);
                      childTitles.push(topic);
                      lastNode = nodeObj;
                    }
                    return;
                  }

                  // 检查 markdown 列表项，支持 "-","*","+","1.","1、" 等
                  var listMatch = line.match(/^(\s*)(?:[-\*\+]|(\d+)[\.、])\s+(.*)$/);
                  if (listMatch) {
                    var indent = listMatch[1].length;
                    // 每2个空格为一级（与 ai-config.js 的策略类似），基础层级从1开始
                    var levelFromIndent = Math.floor(indent / 2) + 1;
                    var topic = (listMatch[3] || '').trim();
                    if (topic) {
                      var nodeObj = { topic: topic, level: levelFromIndent, notes: '' };
                      childNodes.push(nodeObj);
                      childTitles.push(topic);
                      lastNode = nodeObj;
                    }
                    return;
                  }

                  // 其他行：将文本合并到最近一个解析出的节点的 notes 中
                  // 逻辑：
                  //  - 如果 lastNode 存在，直接追加到 lastNode.notes（保留换行）
                  //  - 否则如果已有 childNodes，则附加到最后一个 childNodes 元素的 notes
                  //  - 若没有任何解析出的节点（极端情况），把该行作为一个新的一级节点的标题（降级处理）
                  var nonTitleText = trimmed;
                  if (nonTitleText) {
                    if (lastNode) {
                      lastNode.notes = lastNode.notes ? (lastNode.notes + '\\n' + nonTitleText) : nonTitleText;
                    } else if (childNodes.length > 0) {
                      var prev = childNodes[childNodes.length - 1];
                      if (prev) {
                        prev.notes = prev.notes ? (prev.notes + '\\n' + nonTitleText) : nonTitleText;
                        lastNode = prev;
                      }
                    } else {
                      // 回退：将此文本作为新节点标题，保证不会完全丢失内容
                      var nodeObj = { topic: nonTitleText, level: 1, notes: '' };
                      childNodes.push(nodeObj);
                      childTitles.push(nonTitleText);
                      lastNode = nodeObj;
                    }
                  }
                  return;
                });




                if (childTitles.length === 0) {
                  // 退回到按段落分割：按连续空行（'\n\n' 或 更多）分割
                  var paras = normalized.split(/\n{2,}/).map(function (s) { return (s || '').trim(); }).filter(function (s) { return !!s; });
                  paras.forEach(function (p) {
                    var firstLine = (p.split('\n')[0] || '').trim();
                    if (firstLine) childTitles.push(firstLine);
                  });
                }

                if (childTitles.length === 0) {
                  showWarning('无法从 AI 输出解析出子节点，请检查输出格式');
                  return;
                }

                // 根据 actionType 分发处理；非 create_child 则提前处理并返回
                var itemsToInsert = (typeof childNodes !== 'undefined' && Array.isArray(childNodes) && childNodes.length > 0) ? childNodes : childTitles;
                applyAIAction((payload && payload.actionType) ? payload.actionType : 'create_child', {
                  selectedNode: selectedNode,
                  itemsToInsert: itemsToInsert,
                  childNodes: childNodes,
                  childTitles: childTitles,
                  parsedText: normalized,
                  placeholders: (payload && payload.templateData && payload.templateData.placeholders) ? payload.templateData.placeholders : {}
                });
                if (true) {
                  try { showSuccess && showSuccess('AI处理完成，解析到 ' + childTitles.length + ' 项'); } catch (e) { }
                  return;
                }

                // 插入子节点（使用 jm API，插入到 selectedNode 下）
                // 兼容 childNodes（[{topic, level}...]）和旧的 childTitles（['t1','t2']）
                var itemsToInsert = (typeof childNodes !== 'undefined' && Array.isArray(childNodes) && childNodes.length > 0) ? childNodes : childTitles;
                itemsToInsert.forEach(function (item, idx) {
                  try {
                    // 规范化 topicStr 与 nodeData
                    var topicStr = '';
                    var nodeData = {};
                    if (typeof item === 'string') {
                      topicStr = item;
                    } else if (item && typeof item === 'object') {
                      topicStr = (item.topic !== undefined) ? String(item.topic) : '';
                      if (item.level !== undefined && item.level !== null) {
                        nodeData.level = item.level;
                      }
                      // 保留原始 raw 文本以便调试/回写（如果需要）
                      if (item.raw) nodeData.raw = item.raw;
                      // 如果解析到了 notes，则传入以便新节点带上备注
                      if (item.notes) nodeData.notes = item.notes;
                    } else {
                      topicStr = String(item);
                    }

                    if (!topicStr) return; // 跳过空项

                    // 使用 jm.add_node(parentid, nodeid, topic, data)
                    const nid = 'n_' + Math.random().toString(36).slice(2, 9);
                    // 如果 jm.add_node 接受第四个参数 data，则传入 nodeData；若不接受也不会报错（安全尝试）
                    try {
                      if (Object.keys(nodeData).length > 0) {
                        jm.add_node(selectedNode.id, nid, topicStr, nodeData);
                      } else {
                        jm.add_node(selectedNode.id, nid, topicStr);
                      }
                    } catch (innerErr) {
                      // 兼容性回退：仅传 topic
                      jm.add_node(selectedNode.id, nid, topicStr);
                    }
                  } catch (e) {
                    console.warn('插入子节点失败', e);
                  }
                });

                // 保存 / 提示
                try { if (typeof debouncedSave === 'function') debouncedSave(); } catch (e) { }
                try { showSuccess && showSuccess('已为该节点生成 ' + childTitles.length + ' 个子节点'); } catch (e) { }
              } catch (err) {
                console.error('处理 AI 结果失败', err);
                showError('处理 AI 结果失败: ' + (err && err.message ? err.message : String(err)));
              }
            } else {
              // error
              const detailMsg = (msg.detail && msg.detail.message) ? msg.detail.message : 'AI 返回错误';
              showError('AI 生成失败: ' + detailMsg);
            }
          } catch (e) {
            console.warn('expandWithAI onMessage error', e);
          }
        };

        window.addEventListener('message', onMessage);

        // 超时保护（30s）：仅在非嵌入（非 modal）场景显示全局错误；嵌入场景由父页面/modal 处理超时
        const timeoutT = setTimeout(function () {
          try {
            // 先移除监听，避免后续重复触发
            window.removeEventListener('message', onMessage);
            // 若当前页面被嵌入到父页面（通常表示会由父页面显示 modal），则跳过本地的错误提示
            const isEmbedded = (window.parent && window.parent !== window);
            if (isEmbedded) {
              console.debug('[MW][AI] timeout skipped: parent/modal should handle it', requestId);
              // 可选：通知父窗口超时（注释掉以避免多余消息）
              // try { window.parent.postMessage({ type: 'AI_MODAL_TIMEOUT', requestId: requestId }, '*'); } catch (_) {}
              return;
            }
            // 非嵌入（headless）场景显示本地错误
            showError('AI 响应超时（30s）');
          } catch (e) { }
        }, 30000);

        // 发送请求给父页面
        try {
          console.log('[MW][AI] send AI_MODAL_OPEN_REQUEST', requestId, payload);
          window.parent.postMessage({ type: 'AI_MODAL_OPEN_REQUEST', requestId: requestId, payload: payload }, '*');
          // 清理一次性预设
          try {
            delete window.__mw_next_actionType;
            delete window.__mw_next_templateKey;
            delete window.__mw_next_placeholders;
          } catch (_) { }
        } catch (e) {
          clearTimeout(timeoutT);
          window.removeEventListener('message', onMessage);
          console.error('发送 AI 请求失败', e);
          showError('发送 AI 请求失败: ' + e.message);
        }

      } catch (e) {
        console.error('AI扩写出错:', e);
        showError('AI扩写出错: ' + e.message);
      }
    }

    // 隐藏/显示浮动面板的 API（供 showNodeDetails 调用）
    function hideNodeDetails() {
      const p = document.getElementById('nodeDetails');
      if (p) {
        p.style.display = 'none';
        p.setAttribute('aria-hidden', 'true');
        // 安全移除拖拽监听（若在闭包中定义则不会抛错）
        if (typeof removeNodeDetailsDragHandlers === 'function') {
          try { removeNodeDetailsDragHandlers(); } catch (e) { /* ignore */ }
        } else if (typeof window.removeNodeDetailsDragHandlers === 'function') {
          try { window.removeNodeDetailsDragHandlers(); } catch (e) { /* ignore */ }
        }
      }
      // 同步关闭“详情面板”开关，直到用户手动再开启
      try {
        window.__nodeDetailsEnabled = false;
        const cb = document.getElementById('toggleNodeDetailsCheckbox');
        if (cb) {
          cb.checked = false;
          cb.setAttribute('aria-checked', 'false');
        }
        const btn = document.getElementById('toggleNodeDetailsBtn');
        if (btn) {
          btn.classList.remove('state-on');
          btn.classList.remove('state-default');
          btn.classList.add('state-off');
          btn.setAttribute('aria-pressed', 'false');
        }
      } catch (e) { /* ignore */ }
    }
    function showNodeDetailsPanel() {
      const p = document.getElementById('nodeDetails');
      if (p) {
        p.style.display = 'block';
        p.setAttribute('aria-hidden', 'false');
        // 仅当面板未被用户移动过时，才重置为默认靠右位置
        if (p.dataset.moved !== 'true') {
          p.style.right = '12px';
          p.style.left = 'auto';
          p.style.top = '80px';
        }
        // 初始化拖拽监听（幂等）
        try {
          if (typeof initNodeDetailsDragHandlers === 'function') {
            initNodeDetailsDragHandlers();
          } else if (typeof window.initNodeDetailsDragHandlers === 'function') {
            window.initNodeDetailsDragHandlers();
          }
        } catch (e) { /* ignore */ }
      }
    }

    /* 打开详情面板并提示“请选择一个节点” */
    function showEmptyDetailsPrompt() {
      try {
        if (window.__nodeDetailsEnabled === false) {
          try { console.log('[MW][details][UI] skip empty: toggle disabled'); } catch (e) { }
          return;
        }
        // 确保面板可见
        try { showNodeDetailsPanel(); } catch (e) { try { console.warn('[MW][details][UI] showNodeDetailsPanel failed', e); } catch (ee) { } }
        var panel = document.getElementById('nodeDetails');
        var empty = document.getElementById('nodeDetailsEmpty');
        var form = document.getElementById('nodeDetailsForm');
        var info = document.getElementById('nodeInfo');
        var topic = document.getElementById('nodeTopic');
        var notes = document.getElementById('nodeNotes');

        // 切换为空状态：显示空视图，隐藏表单
        if (empty) empty.style.display = 'block';
        if (form) form.style.display = 'none';

        if (topic) topic.value = '';
        if (notes) notes.value = '';

        // 关键日志：输出各元素与可见性
        try {
          console.log('[MW][details][UI] showEmptyDetailsPrompt:',
            {
              panelExists: !!panel,
              panelDisplay: panel && panel.style ? panel.style.display : undefined,
              panelAriaHidden: panel ? panel.getAttribute('aria-hidden') : undefined,
              emptyExists: !!empty,
              emptyDisplay: empty && empty.style ? empty.style.display : undefined,
              formExists: !!form,
              formDisplay: form && form.style ? form.style.display : undefined
            }
          );
        } catch (e) { }
      } catch (e) {
        try { console.warn('[MW][details][UI] showEmptyDetailsPrompt error', e); } catch (ee) { }
      }
    }

    try { window.showEmptyDetailsPrompt = showEmptyDetailsPrompt; } catch (e) { /* ignore */ }
    // 缩放中心修正：在鼠标/触摸位置设置 transform-origin，配合现有库缩放以该点为中心
    (function setupZoomOrigin() {
      const container = document.getElementById('fullScreenMindmap');
      if (!container) return;
      function setOrigin(clientX, clientY) {
        const rect = container.getBoundingClientRect();
        const x = clientX - rect.left;
        const y = clientY - rect.top;
        container.style.transformOrigin = `${x}px ${y}px`;
      }
      // 鼠标滚轮：在缩放前设置 origin
      container.addEventListener('wheel', function (e) {
        if (e.ctrlKey || e.metaKey || e.shiftKey || e.altKey) {
          // 若用户同时按键，仍支持，但优先设置 origin
        }
        setOrigin(e.clientX, e.clientY);
        // 不阻止原生滚动/缩放逻辑，让现有库处理实际缩放
      }, { passive: true });
      // 触摸：记录触摸点以设置 origin（用于双指缩放前）
      container.addEventListener('touchstart', function (e) {
        if (!e.touches || e.touches.length === 0) return;
        const t = e.touches[0];
        setOrigin(t.clientX, t.clientY);
      }, { passive: true });
    })();


    /* 拖拽支持：鼠标与触摸 */
    (function () {
      let dragging = false;
      let startX = 0, startY = 0;
      let origLeft = 0, origTop = 0;
      let handlersAdded = false;



      function onPointerDown(e) {
        const p = document.getElementById('nodeDetails');
        if (!p) return;
        dragging = true;
        p.style.transition = 'none';
        const rect = p.getBoundingClientRect();
        origLeft = rect.left;
        origTop = rect.top;
        if (e.type === 'touchstart') {
          startX = e.touches[0].clientX;
          startY = e.touches[0].clientY;
        } else {
          startX = e.clientX;
          startY = e.clientY;
        }
        // prevent iframe text selection during drag
        document.body.style.userSelect = 'none';
      }

      function onPointerMove(e) {
        if (!dragging) return;
        const p = document.getElementById('nodeDetails');
        if (!p) return;
        let cx = (e.type === 'touchmove') ? e.touches[0].clientX : e.clientX;
        let cy = (e.type === 'touchmove') ? e.touches[0].clientY : e.clientY;
        const dx = cx - startX;
        const dy = cy - startY;
        const left = origLeft + dx;
        const top = origTop + dy;
        // 限制到视口内
        const vw = Math.max(document.documentElement.clientWidth || 0, window.innerWidth || 0);
        const vh = Math.max(document.documentElement.clientHeight || 0, window.innerHeight || 0);
        const rect = p.getBoundingClientRect();
        const w = rect.width, h = rect.height;
        const minLeft = 8;
        const maxLeft = vw - w - 8;
        const minTop = 8;
        const maxTop = vh - h - 8;
        const nx = Math.min(Math.max(left, minLeft), Math.max(minLeft, maxLeft));
        const ny = Math.min(Math.max(top, minTop), Math.max(minTop, maxTop));
        // 记录临时位移量，onPointerUp 会基于此判断是否标记为已移动
        try {
          p.dataset._dragMovedX = String(dx);
          p.dataset._dragMovedY = String(dy);
        } catch (e) { /* ignore */ }
        p.style.right = 'auto';
        p.style.left = nx + 'px';
        p.style.top = ny + 'px';
      }

      function onPointerUp() {
        if (!dragging) return;
        dragging = false;
        document.body.style.userSelect = '';
        const p = document.getElementById('nodeDetails');
        if (p) p.style.transition = '';
        // 标记是否发生过显著位移，页面未刷新前保持位置
        try {
          if (p) {
            const movedX = parseFloat(p.dataset._dragMovedX || '0');
            const movedY = parseFloat(p.dataset._dragMovedY || '0');
            if (Math.abs(movedX) > 2 || Math.abs(movedY) > 2) {
              p.dataset.moved = 'true';
            }
            delete p.dataset._dragMovedX;
            delete p.dataset._dragMovedY;
          }
        } catch (e) { /* ignore */ }
      }

      function initNodeDetailsDragHandlers() {
        if (handlersAdded) return;
        const p = document.getElementById('nodeDetails');
        if (!p) return;
        // 使用 panel-header 作为抓手，如无则全面板可拖
        const handle = p.querySelector('.panel-header') || p;
        handle.addEventListener('mousedown', onPointerDown, { passive: true });
        window.addEventListener('mousemove', onPointerMove, { passive: true });
        window.addEventListener('mouseup', onPointerUp, { passive: true });
        handle.addEventListener('touchstart', onPointerDown, { passive: true });
        window.addEventListener('touchmove', onPointerMove, { passive: true });
        window.addEventListener('touchend', onPointerUp, { passive: true });
        handlersAdded = true;
      }



      // 如果面板已显示，初始化一次
      document.addEventListener('DOMContentLoaded', function () {
        const p = document.getElementById('nodeDetails');
        if (p && p.style.display !== 'none') initNodeDetailsDragHandlers();
      });
      // 在窗口大小变化时微调位置，避免超出
      window.addEventListener('resize', function () {
        const p = document.getElementById('nodeDetails');
        if (!p || p.style.display === 'none') return;
        const rect = p.getBoundingClientRect();
        const vw = Math.max(document.documentElement.clientWidth || 0, window.innerWidth || 0);
        const vh = Math.max(document.documentElement.clientHeight || 0, window.innerHeight || 0);
        const maxLeft = Math.max(8, vw - rect.width - 8);
        const maxTop = Math.max(8, vh - rect.height - 8);
        let left = rect.left;
        let top = rect.top;
        if (left > maxLeft) left = maxLeft;
        if (top > maxTop) top = maxTop;
        p.style.left = left + 'px';
        p.style.top = top + 'px';
      });

    })();


    // --- extracted block from original HTML ---
    (function () {
      // 节点详情开关（默认开启）
      window.__nodeDetailsEnabled = (window.__nodeDetailsEnabled === undefined) ? true : !!window.__nodeDetailsEnabled;

      function updateToggleUI() {
        var enabled = !!window.__nodeDetailsEnabled;
        // 复选框（兼容保留）
        var cb = document.getElementById('toggleNodeDetailsCheckbox');
        if (cb) {
          cb.checked = enabled;
          cb.setAttribute('aria-checked', enabled ? 'true' : 'false');
        }
        // 图标按钮（新）
        var btn = document.getElementById('toggleNodeDetailsBtn');
        if (btn) {
          btn.classList.remove('state-on', 'state-off', 'state-default');
          btn.classList.add(enabled ? 'state-on' : 'state-off');
          btn.setAttribute('aria-pressed', enabled ? 'true' : 'false');
        }
      }

      // 切换处理：启用时若存在选中节点立即显示详情；禁用时隐藏面板并阻止后续弹出
      function handleToggleChange(checked) {
        window.__nodeDetailsEnabled = !!checked;
        if (!window.__nodeDetailsEnabled) {
          if (typeof hideNodeDetails === 'function') {
            try { hideNodeDetails(); } catch (e) { /* ignore */ }
          }
        } else {
          // 启用时：若有选中节点，立即显示其详情；否则打开面板并提示“请选择一个节点”
          try {
            var sel = null;
            if (window.jm && typeof window.jm.get_selected_node === 'function') {
              sel = window.jm.get_selected_node();
            }
            if (sel) {
              try { showNodeDetails(sel); } catch (e) { /* ignore */ }
            } else {
              // 无选中节点：打开面板并显示空状态
              try { showEmptyDetailsPrompt(); } catch (e) { /* ignore */ }
            }
          } catch (e) { /* ignore */ }
        }
        updateToggleUI();
      }

      // 挂载事件
      document.addEventListener('DOMContentLoaded', function () {
        // 初始化 UI（无论是否有复选框或按钮）
        updateToggleUI();

        // 复选框（兼容）
        var cb = document.getElementById('toggleNodeDetailsCheckbox');
        if (cb) {
          cb.addEventListener('change', function (e) {
            handleToggleChange(!!e.target.checked);
          }, { passive: true });
          cb.addEventListener('keydown', function (e) {
            if (e.key === ' ' || e.key === 'Enter') {
              setTimeout(function () { handleToggleChange(!!cb.checked); }, 0);
            }
          });
        }

        // 图标按钮（新）
        var btn = document.getElementById('toggleNodeDetailsBtn');
        if (btn) {
          btn.addEventListener('click', function () {
            handleToggleChange(!window.__nodeDetailsEnabled);
          });
          btn.addEventListener('keydown', function (e) {
            if (e.key === 'Enter' || e.key === ' ') {
              e.preventDefault();
              handleToggleChange(!window.__nodeDetailsEnabled);
            }
          });
        }
      });

      // 包装 showNodeDetails：若开关关闭则静默返回
      if (typeof window.showNodeDetails === 'function') {
        var _origShowNodeDetails = window.showNodeDetails;
        window.showNodeDetails = function (node) {
          if (window.__nodeDetailsEnabled === false) return;
          return _origShowNodeDetails.apply(this, arguments);
        };
      } else {
        // 若函数尚未定义，延迟包装（在后续定义时检测）
        var _tryWrap = function () {
          if (typeof window.showNodeDetails === 'function') {
            var _orig = window.showNodeDetails;
            window.showNodeDetails = function (node) {
              if (window.__nodeDetailsEnabled === false) return;
              return _orig.apply(this, arguments);
            };
            clearInterval(_tryWrapInterval);
          }
        };
        var _tryWrapInterval = setInterval(_tryWrap, 200);
      }
    })();


    // --- extracted block from original HTML ---
    (function mw_post_init_fix() {
      try {
        function isMobileNow() {
          var isSmallScreen = (window.matchMedia && window.matchMedia('(max-width: 768px)').matches);
          var hasTouch = ('ontouchstart' in window) || (navigator.maxTouchPoints && navigator.maxTouchPoints > 0);
          return isSmallScreen || (hasTouch && window.innerWidth <= 900);
        }

        function relocateBatchOpsIfNeeded() {
          try {
            var isMobile = isMobileNow();
            var batch = document.getElementById('batchOperations');
            var mw = document.getElementById('mw-batchops');
            if (!batch || !mw) return;
            if (!isMobile) {
              // copy count
              var sc = batch.querySelector('#selectedCount');
              var scVal = sc ? sc.textContent : '0';
              var targetStrong = mw.querySelector('#selectedCountDisplay');
              if (targetStrong) targetStrong.textContent = scVal;
              batch.style.display = 'none';
              mw.style.display = 'inline-flex';
              // keep references
              window.__mw_batch_source = batch;
              window.__mw_batch_target = mw;
            } else {
              batch.style.display = 'none';
              if (mw) mw.style.display = 'none';
            }
          } catch (e) { console.warn('[MW] relocateBatchOpsIfNeeded failed', e); }
        }

        function ensureDetailsToggleVisibleOnDesktop() {
          try {
            var cbDetails = document.getElementById('toggleNodeDetailsCheckbox');
            if (!cbDetails) return;
            var label = cbDetails.parentElement;
            if (!label) return;
            if (!isMobileNow()) {
              label.style.display = ''; // restore default
            }
          } catch (e) { /* ignore */ }
        }

        // sync selected count periodically (small cost, robust)
        function startSelectedCountSync() {
          try {
            var source = document.getElementById('batchOperations');
            var target = document.getElementById('mw-batchops');
            if (!source || !target) return;
            var sSrc = source.querySelector('#selectedCount');
            var sTgt = target.querySelector('#selectedCountDisplay');
            if (!sSrc || !sTgt) return;
            var last = null;
            setInterval(function () {
              try {
                var now = sSrc.textContent || sSrc.innerText || '0';
                if (now !== last) {
                  last = now;
                  sTgt.textContent = now;
                }
              } catch (e) { }
            }, 250);
          } catch (e) { /* ignore */ }
        }

        // run on load and on resize/orientationchange
        function boot() {
          relocateBatchOpsIfNeeded();
          ensureDetailsToggleVisibleOnDesktop();
          startSelectedCountSync();
          // 初始化AI快捷操作按钮可见性
          if (typeof updateAIQuickActionsVisibility === 'function') {
            updateAIQuickActionsVisibility();
          }
        }

        if (document.readyState === 'complete' || document.readyState === 'interactive') {
          setTimeout(boot, 50);
        } else {
          document.addEventListener('DOMContentLoaded', function () { setTimeout(boot, 50); });
          window.addEventListener('load', function () { setTimeout(boot, 50); });
        }
        window.addEventListener('resize', function () { setTimeout(relocateBatchOpsIfNeeded, 60); });
        window.addEventListener('orientationchange', function () { setTimeout(relocateBatchOpsIfNeeded, 60); });
      } catch (e) {
        console.error('[MW] post init fix error', e);
      }
    })();


    // toolbar 图标选择器初始化 —— 更稳健的实现：使用 textContent、等待 availableIcons 与 jm 就绪
    (function () {
      function createToolbarIconGrid() {
        var grid = document.getElementById('iconGridToolbar');
        if (!grid) return;
        grid.innerHTML = '';

        // 首位为清除图标按钮（网格内唯一的清除）
        var clearBtn = document.createElement('button');
        clearBtn.type = 'button';
        clearBtn.className = 'icon-picker-item';
        clearBtn.title = '清除图标';
        clearBtn.style.cssText = 'alpha:0.3;width:40px;height:40px;border:1px dashed #ddd;color:#dbdbdb !important;border-radius:4px;background:#fff;cursor:pointer;font-size:18px;display:flex;align-items:center;justify-content:center;';
        clearBtn.textContent = '🚫';
        clearBtn.onclick = function (e) { e.stopPropagation(); clearIconFromToolbar(); };
        grid.appendChild(clearBtn);

        // 如果 MWIcons.getGroups 可用，按组渲染（带分组标题）
        var groups = (window.MWIcons && typeof window.MWIcons.getGroups === 'function') ? window.MWIcons.getGroups() : null;

        if (groups && Object.keys(groups).length > 0) {
          // 创建分组容器
          Object.keys(groups).forEach(function (groupKey) {
            var group = groups[groupKey];
            // 分组标题
            var header = document.createElement('div');
            header.style.cssText = 'grid-column: 1 / -1; font-size:12px; font-weight:600; color:#333; padding:6px 0 4px 0;';
            header.textContent = (groupKey.charAt(0).toUpperCase() + groupKey.slice(1));
            grid.appendChild(header);

            // 分组图标网格（7列内使用相同样式）
            group.forEach(function (icon) {
              var btn = document.createElement('button');
              btn.type = 'button';
              btn.className = 'icon-picker-item';
              btn.title = icon.name || '';
              btn.style.cssText = 'width:40px;height:40px;border:1px solid #ddd;border-radius:4px;background:white;cursor:pointer;font-size:20px;display:flex;align-items:center;justify-content:center;';
              btn.textContent = icon.emoji || '';
              btn.onclick = function (ev) {
                ev.stopPropagation();
                applyIconToSelection(icon.emoji);
                try { $('#iconPickerDropdown .dropdown-toggle').dropdown('toggle'); } catch (e) { }
              };
              btn.onmouseover = function () { btn.style.background = '#f0f0f0'; };
              btn.onmouseout = function () { btn.style.background = 'white'; };
              grid.appendChild(btn);
            });
          });
          return;
        }

        // 兼容回退：扁平化 window.availableIcons 或全局 availableIcons
        var icons = (window.availableIcons && window.availableIcons.length) ? window.availableIcons
          : (typeof availableIcons !== 'undefined' && availableIcons && availableIcons.length) ? availableIcons
            : [];
        if (!icons || icons.length === 0) {
          // 显示占位提示（用户看到不会空白）
          var ph = document.createElement('div');
          ph.style.cssText = 'grid-column: 1 / -1; color:#6c757d; font-size:12px; padding:6px; text-align:center;';
          ph.textContent = '图标库加载中...';
          grid.appendChild(ph);
          return;
        }

        icons.forEach(function (icon) {
          var btn = document.createElement('button');
          btn.type = 'button';
          btn.className = 'icon-picker-item';
          btn.title = icon.name || '';
          btn.style.cssText = 'width:40px;height:40px;border:1px solid #ddd;border-radius:4px;background:white;cursor:pointer;font-size:20px;display:flex;align-items:center;justify-content:center;';
          btn.textContent = icon.emoji || '';
          btn.onclick = function (ev) {
            ev.stopPropagation();
            applyIconToSelection(icon.emoji);
            // 关闭 dropdown（Bootstrap）
            try { $('#iconPickerDropdown .dropdown-toggle').dropdown('toggle'); } catch (e) { }
          };
          btn.onmouseover = function () { btn.style.background = '#f0f0f0'; };
          btn.onmouseout = function () { btn.style.background = 'white'; };
          grid.appendChild(btn);
        });
      }

      // 安全的初始化：如果 availableIcons 尚未就绪，重复尝试几次
      function initWithRetry(attemptsLeft) {
        try {
          if ((window.availableIcons && window.availableIcons.length > 0) || (typeof availableIcons !== 'undefined' && availableIcons && availableIcons.length > 0) || attemptsLeft <= 0) {
            createToolbarIconGrid();
            return;
          }
        } catch (e) { /* ignore */ }

        setTimeout(function () { initWithRetry(attemptsLeft - 1); }, 120);
      }

      // 将 emoji 应用到当前选中节点（支持多选）
      function applyIconToSelection(emoji) {
        if (!window.jm) {
          console.warn('jm 未初始化，无法应用图标');
          return;
        }

        // 获取多选（框选）或单选
        var ids = [];
        try {
          if (typeof window.getMultiSelection === 'function') {
            ids = window.getMultiSelection() || [];
          }
        } catch (e) { ids = []; }

        // 若无多选，则尝试用 jm.get_selected_node（单选）
        if (!ids || ids.length === 0) {
          try {
            var sel = jm.get_selected_node && jm.get_selected_node();
            if (sel) {
              var selId = (typeof sel === 'string') ? sel : (sel.id || null);
              if (selId) ids = [selId];
            }
          } catch (e) { }
        }

        if (!ids || ids.length === 0) {
          showWarning && showWarning('请先选中 1 个或多个节点');
          return;
        }

        // 对每个节点的 topic 前面插入 emoji（若已存在表情则替换）
        // 使用宽松的 emoji 去除正则（兼容性差时也能工作）
        var emojiStrip = /^[^\w\u4e00-\u9fff\s]+/u;
        ids.forEach(function (id) {
          try {
            var node = jm.get_node(id);
            if (!node) return;
            var topic = node.topic || '';
            // 移除开头的非字母数字与非中文字符（多半是 emoji 或符号）
            topic = topic.replace(emojiStrip, '').trim();
            var newTopic = (emoji ? (emoji + ' ' + topic) : topic);
            jm.update_node(node.id, newTopic);
          } catch (e) {
            console.warn('应用图标失败', e);
          }
        });

        // 保存并提示
        try { if (typeof debouncedSave === 'function') debouncedSave(); } catch (e) { }
        try { showSuccess && showSuccess('已应用图标'); } catch (e) { }
      }

      // 从选中节点清除图标（相当于 applyIconToSelection('')）
      window.clearIconFromToolbar = function () {
        if (!window.jm) return;
        var ids = [];
        try {
          if (typeof window.getMultiSelection === 'function') ids = window.getMultiSelection() || [];
        } catch (e) { ids = []; }
        if (!ids || ids.length === 0) {
          try {
            var sel = jm.get_selected_node && jm.get_selected_node();
            if (sel) {
              var selId = (typeof sel === 'string') ? sel : (sel.id || null);
              if (selId) ids = [selId];
            }
          } catch (e) { }
        }
        if (!ids || ids.length === 0) {
          showWarning && showWarning('请先选中 节点');
          return;
        }

        var emojiStrip = /^[^\w\u4e00-\u9fff\s]+/u;
        ids.forEach(function (id) {
          try {
            var node = jm.get_node(id);
            if (!node) return;
            var topic = node.topic || '';
            topic = topic.replace(emojiStrip, '').trim();
            jm.update_node(node.id, topic);
          } catch (e) { console.warn('清除图标失败', e); }
        });
        try { if (typeof debouncedSave === 'function') debouncedSave(); } catch (e) { }
        try { showSuccess && showSuccess('已清除图标'); } catch (e) { }
      };

      // 初始化入口：最多重试 8 次（每次 120ms）
      if (document.readyState === 'complete' || document.readyState === 'interactive') {
        setTimeout(function () { initWithRetry(8); }, 120);
      } else {
        document.addEventListener('DOMContentLoaded', function () { setTimeout(function () { initWithRetry(8); }, 120); });
      }

      // 在 jm 初始化后再执行一次，防止 race
      window.MW_scheduleOnce && window.MW_scheduleOnce('initToolbarIconGrid', function () {
        initWithRetry(4);
      }, 300);
    })();
  </script>

</body>

</html>
</body>

</html>