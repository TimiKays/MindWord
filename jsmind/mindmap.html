<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>思维导图编辑器</title>
  <link rel="stylesheet" href="../styles.css">
  <link type="text/css" rel="stylesheet" href="../jsmind-local/jsmind.css" />
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/css/bootstrap.min.css" />
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.4/dist/jquery.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/js/bootstrap.bundle.min.js"></script>



  <link rel="stylesheet" href="mindmap.css">
  <style>
    .requires-single-selection {
      display: none !important;
    }

    .requires-single-selection.visible {
      display: inline-block !important;
    }
  </style>
</head>

</head>

<body>
  <div class="toolbar">
    <!-- 批量操作工具栏 -->


    <span class="ico-btn" role="button" onclick="downloadMindmap()" tabindex="0" title="下载图片"
      style="--ico: url('res/download.svg'); "></span>
    <span class="ico-btn" role="button" onclick="exportData()" tabindex="0" title="查看JSON"
      style="--ico: url('res/code.svg'); "></span>
    <span class="ico-btn" role="button" onclick="aiGenerateInitialTree()" tabindex="0" title="生成初始树"
      style="--ico: url('../res/生成初始树.svg');"></span>

    <!-- AI 快捷操作 -->
    <div id="aiQuickActions" style="display:inline-flex;gap:8px;align-items:center;">
      <span style="color: gainsboro;"> | </span>
      <span class="ico-btn requires-single-selection" role="button" onclick="aiCreateChild()" tabindex="0" title="创建子级"
        style="--ico: url('../res/添加子级.svg');"></span>
      <span class="ico-btn requires-single-selection" role="button" onclick="aiCreateSibling()" tabindex="0"
        title="创建同级" style="--ico: url('../res/添加同级.svg');"></span>
      <span class="ico-btn requires-single-selection" role="button" onclick="aiExpandNotes()" tabindex="0" title="扩写备注"
        style="--ico: url('../res/扩写备注.svg');"></span>
      <span class="ico-btn requires-single-selection" role="button" onclick="quickModifyNode()" tabindex="0" title="修改"
        style="--ico: url('../res/edit.svg');"></span>
      <span class="ico-btn" role="button" onclick="quickDeleteNode()" tabindex="0" title="删除节点"
        style="--ico: url('../res/删除.svg');"></span>

    </div>


    <!-- 图标选择器下拉菜单（已定制：隐藏默认 caret、只保留网格内第一个“清除”按钮） -->
    <style>
      /* 隐藏 Bootstrap 的下拉小箭头并去掉可能的聚焦动画/outline */
      #iconPickerBtn.dropdown-toggle::after {
        display: none !important;
      }

      #iconPickerBtn:focus {
        outline: none !important;
        box-shadow: none !important;
      }

      /* 工具栏内图标按钮保证 emoji 可见 */
      #iconGridToolbar .icon-picker-item {
        font-family: "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji", system-ui, sans-serif;
        color: #222 !important;
        font-size: 20px !important;
        line-height: 1;
        padding: 0;
        background: white !important;
      }

      /* 去掉下拉菜单自身的动画（若存在） */
      #iconPickerDropdown .dropdown-menu {
        transition: none !important;
        -webkit-transition: none !important;
        -moz-transition: none !important;

      }
    </style>

    <div class="dropdown" id="iconPickerDropdown" style="display: inline-block;">

      <span id="iconPickerBtn" class="ico-btn dropdown-toggle" role="button" data-toggle="dropdown" aria-haspopup="true"
        aria-expanded="false" title="选择图标" tabindex="0" style="--ico: url('res/tag.svg');"></span>
      <div class="dropdown-menu" aria-labelledby="iconPickerBtn"
        style="width: 360px; max-height: 420px; overflow-y: auto; overflow-x: hidden;">
        <div style="padding: 12px;">
          <h6 style="margin: 0 0 8px 0; font-size: 14px; font-weight: 600;">选择图标</h6>
          <div id="iconGridToolbar"
            style="display: grid; grid-template-columns: repeat(7, 1fr); gap: 6px; padding-bottom:8px; box-sizing: border-box; column-gap:6px;">
            <!-- 图标将通过JavaScript动态生成（第一个为清除） -->
          </div>
        </div>
        <!-- 已移除重复的底部清除按钮（仅保留网格中的第一个清除按钮） -->
      </div>
    </div>

    <!-- batchOperations 保留在 DOM 中但会被移动到画布左上（通过脚本在非移动端显示） -->
    <div id="batchOperations"
      style="display: none; float: right; padding: 1px 6px; background: rgba(76, 154, 255, 0.1); border-radius: 4px; border: 1px solid #4c9aff;">
      <span style="color: #4c9aff; font-size: 12px; ">已选中 <span id="selectedCount">0</span>
        个节点</span>
    </div>

    <!-- 右侧三个简单复选框：详情面板 / 显示节点类型 / 显示列表节点 -->
    <div id="toolbarToggles"
      style="margin-left:auto;display:flex;gap:12px;align-items:flex-end;justify-content:flex-end;">
      <span id="toggleNodeDetailsBtn" class="ico-btn state-on" role="button" tabindex="0" aria-pressed="true"
        title="详情面板" style="--ico: url('res/detail.svg'); "></span>
      <label class="mw-toggle-showtype"
        style="display:none;flex-direction:column;align-items:center;font-size:12px;margin:0 4px;">
        <input id="toggleShowNodeTypeCheckbox" type="checkbox" style="width:18px;height:18px;margin-bottom:6px;">
        <span style="display:block;margin-top:0;">显示类型</span>
      </label>
      <label class="mw-toggle-showtitleonly"
        style="display:none;flex-direction:column;align-items:center;font-size:12px;margin:0 4px;">
        <input id="toggleShowListNodesCheckbox" type="checkbox" style="width:18px;height:18px;margin-bottom:6px;">
        <span style="display:block;margin-top:0;">只看标题</span>
      </label>
    </div>





  </div>

  <div class="main-container">
    <div id="fullScreenMindmap"></div>
    <!-- 浮动节点详情面板（可关闭），保留内部字段和功能 -->
    <div id="nodeDetails" role="dialog" aria-hidden="true" aria-label="节点详情">
      <div class="panel-header">
        <strong>节点详情</strong>
        <button class="panel-close-btn" aria-label="关闭节点详情" onclick="hideNodeDetails()">✕</button>
      </div>

      <div id="nodeDetailsEmpty" style="display:none; padding:24px; text-align:center; color:#64748b;">
        <img src="../res/empty.svg" alt="空状态" style="width:72px;height:72px;opacity:0.9;margin-bottom:12px;">
        <div>请选择一个节点</div>
      </div>

      <div id="nodeDetailsForm">
        <div id="nodeInfo"></div>

        <div style="margin-bottom: 15px;margin-top: 10px; display: flex; gap: 10px;">
          <span class="ico-btn requires-single-selection" role="button" onclick="aiCreateChild()" tabindex="0"
            title="创建子级" style="--ico: url('../res/添加子级.svg');"></span>
          <span class="ico-btn requires-single-selection" role="button" onclick="aiCreateSibling()" tabindex="0"
            title="创建同级" style="--ico: url('../res/添加同级.svg');"></span>
          <span class="ico-btn requires-single-selection" role="button" onclick="aiExpandNotes()" tabindex="0"
            title="扩写备注" style="--ico: url('../res/扩写备注.svg');"></span>
          <span class="ico-btn" role="button" onclick="quickDeleteNode()" tabindex="0" title="删除节点"
            style="--ico: url('../res/删除.svg');"></span>
          <span class="ico-btn" role="button"
            onclick="(function(){try{function genId(){return 'r_'+Math.random().toString(36).slice(2,10);}var requestId=genId();var payload={initialView:'config',platformConfig:{},modelConfig:{},options:{}};if(typeof window.openAIServiceModal==='function'){try{window.openAIServiceModal(Object.assign({},payload,{requestId:requestId}));return;}catch(e){console.warn('openAIServiceModal failed',e);} }try{window.parent.postMessage({type:'AI_MODAL_OPEN_REQUEST',requestId:requestId,payload:payload},'*');}catch(e){console.error('send AI config open request failed',e);} }catch(e){console.warn(e);} })()"
            tabindex="0" title="AI配置" style="--ico: url('../res/setting.svg');"></span>
          <!-- <button class="btn"
            onclick="(function(){try{function genId(){return 'r_'+Math.random().toString(36).slice(2,10);}var requestId=genId();var payload={initialView:'config',platformConfig:{},modelConfig:{},options:{}};if(typeof window.openAIServiceModal==='function'){try{window.openAIServiceModal(Object.assign({},payload,{requestId:requestId}));return;}catch(e){console.warn('openAIServiceModal failed',e);} }try{window.parent.postMessage({type:'AI_MODAL_OPEN_REQUEST',requestId:requestId,payload:payload},'*');}catch(e){console.error('send AI config open request failed',e);} }catch(e){console.warn(e);} })()"
            style="flex: 0 0 40px; background: #ffffff;" title="AI配置">⚙️</button> -->
        </div>

        <div class="form-group">
          <label for="nodeTopic">节点主题:</label>
          <textarea id="nodeTopic" placeholder="输入节点主题..." rows="3"
            style="width:100%; resize:vertical; line-height:1.4em;"></textarea>
        </div>

        <div class="form-group">
          <label for="nodeNotes">节点备注:</label>
          <textarea id="nodeNotes" placeholder="输入节点备注..."></textarea>
        </div>



        <!-- 自动更新提示 -->
        <div id="autoUpdateIndicator"
          style="display: none; margin-bottom: 10px; padding: 5px 10px; background: #d4edda; border: 1px solid #c3e6cb; border-radius: 4px; color: #155724; font-size: 12px; text-align: center;">
          <span style="display: inline-block; animation: pulse 1s ease-in-out;">✓</span> 已自动更新
        </div>

      </div>

      <!-- 通知桥接器 -->
      <script src="../notification-bridge.js"></script>

    </div>
  </div>
  </div>

  <script src="../jsmind-local/jsmind.js"></script>
  <script src="../jsmind-local/jsmind.draggable-node.js"></script>
  <script src="https://unpkg.com/dom-to-image@2.6.0/dist/dom-to-image.min.js"></script>
  <!-- 使用与jsMind 0.5.7版本匹配的截图插件 -->
  <script src="../jsmind-local/jsmind.screenshot.js"></script>
  <script type="module" src="../converter/sync.js"></script>
  <script type="module" src="../converter/load.js"></script>
  <script src="plugins/undo_manager.js"></script>




  <script src="icons.js"></script>
  <script type="module" src="mindmap-core.js"></script>
  <script>

    /* mindmap-ui.js - UI related extracted scripts */

    // 动作分发器：根据 actionType 处理不同入口
    // ctx: { selectedNode, itemsToInsert, childNodes, childTitles, parsedText }
    function applyAIAction(actionType, ctx) {
      try {
        const sel = ctx.selectedNode;
        if (!sel) {
          showWarning && showWarning('请先选择一个节点');
          return;
        }
        const items = Array.isArray(ctx.itemsToInsert) ? ctx.itemsToInsert : [];
        // 新版 addMany：支持从带缩进/Markdown 的多层列表文本构建树并递归插入
        const addMany = function (parentId) {
          // 如果 items 已经包含对象并带有 level 字段，则优先按 level 插入（兼容旧行为）
          const hasLevelField = items.some(i => i && typeof i === 'object' && (i.level !== undefined && i.level !== null));

          // 辅助：将多行文本解析为节点项数组，支持 Markdown 无序/有序列表与缩进
          function parseTextToItems(text) {
            const lines = String(text || '').replace(/\r\n/g, '\n').split('\n').map(l => l.replace(/\t/g, '    '));
            const result = [];
            for (let rawLine of lines) {
              const line = rawLine.replace(/\u00A0/g, ''); // 去除不间断空格
              if (line.trim() === '') continue;
              // 匹配前导空格数和列表标记（-, *, +, 或数字.）
              const m = line.match(/^(\s*)([-*+]|\d+\.)?\s*(.*)$/);
              if (!m) continue;
              const indent = m[1] ? m[1].length : 0;
              const marker = m[2] || null;
              const content = (m[3] || '').trim();
              // 计算层级：每4个空格为一级（经验值），同时如果有列表标记也视为有效项
              const level = Math.floor(indent / 4);
              result.push({ topic: content, raw: rawLine, level, marker });
            }
            return result;
          }

          // 辅助：把扁平的带 level 项转换成树结构（parent->children）
          function buildTreeFromItems(flatItems) {
            const root = { children: [] };
            const stack = [{ level: -1, node: root }];
            flatItems.forEach(it => {
              const node = Object.assign({ topic: String(it.topic || ''), raw: it.raw || '' }, it);
              node.children = [];
              // 找到合适的父层：从栈顶往下找第一个 level < node.level
              while (stack.length > 0 && stack[stack.length - 1].level >= (node.level || 0)) {
                stack.pop();
              }
              stack[stack.length - 1].node.children.push(node);
              stack.push({ level: node.level || 0, node });
            });
            return root.children;
          }

          // 递归插入树节点
          function insertTreeNodes(parentId, nodes) {
            if (!Array.isArray(nodes) || nodes.length === 0) return;
            nodes.forEach(n => {
              try {
                const topicStr = String(n.topic || '');
                if (!topicStr) return;
                const nid = 'n_' + Math.random().toString(36).slice(2, 9);
                const nodeData = {};
                if (n.raw) nodeData.raw = n.raw;
                if (n.level !== undefined && n.level !== null) nodeData.level = n.level;
                try {
                  if (Object.keys(nodeData).length > 0) {
                    jm.add_node(parentId, nid, topicStr, nodeData);
                  } else {
                    jm.add_node(parentId, nid, topicStr);
                  }
                } catch (err) {
                  try { jm.add_node(parentId, nid, topicStr); } catch (_) { console.warn('插入节点失败', _); }
                }
                // 递归插入子节点
                if (Array.isArray(n.children) && n.children.length > 0) {
                  insertTreeNodes(nid, n.children);
                }
              } catch (e) {
                console.warn('插入树节点失败', e);
              }
            });
          }

          try {
            if (hasLevelField) {
              // 如果 items 已含层级信息，先将 items 转换为扁平结构并按 level 构建树
              const flat = items.map(it => {
                if (typeof it === 'string') return { topic: it, raw: it, level: 0 };
                const topic = (it && typeof it === 'object') ? (it.topic !== undefined ? String(it.topic) : String(it)) : String(it);
                const level = (it && typeof it === 'object' && (it.level !== undefined && it.level !== null)) ? parseInt(it.level, 10) || 0 : 0;
                const raw = (it && typeof it === 'object' && it.raw) ? it.raw : topic;
                return { topic, raw, level };
              });
              const tree = buildTreeFromItems(flat);
              insertTreeNodes(parentId, tree);
            } else {
              // 否则将所有字符串项合并为文本并解析为带层级的项
              const combined = [];
              items.forEach(it => {
                if (typeof it === 'string') {
                  // 如果字符串含多行，则解析多行
                  const parsed = parseTextToItems(it);
                  if (parsed.length > 0) parsed.forEach(p => combined.push(p));
                } else if (it && typeof it === 'object') {
                  // 对象项按 topic 字段处理（保留 raw/notes）
                  const topic = (it.topic !== undefined) ? String(it.topic) : '';
                  const raw = it.raw || topic;
                  const lvl = (it.level !== undefined && it.level !== null) ? parseInt(it.level, 10) || 0 : 0;
                  combined.push({ topic, raw, level: lvl });
                } else {
                  combined.push({ topic: String(it), raw: String(it), level: 0 });
                }
              });
              // 构建树并插入
              const tree = buildTreeFromItems(combined);
              insertTreeNodes(parentId, tree);
            }
          } catch (e) {
            console.warn('addMany 批量插入（分层）失败，回退到逐项插入：', e);
            // 回退：保持原来的逐项插入行为，保证兼容性
            items.forEach(function (item) {
              try {
                var topicStr = '';
                var nodeData = {};
                if (typeof item === 'string') {
                  topicStr = item;
                } else if (item && typeof item === 'object') {
                  topicStr = (item.topic !== undefined) ? String(item.topic) : '';
                  if (item.level !== undefined && item.level !== null) nodeData.level = item.level;
                  if (item.raw) nodeData.raw = item.raw;
                  if (item.notes) nodeData.notes = item.notes;
                } else {
                  topicStr = String(item);
                }
                if (!topicStr) return;
                const nid = 'n_' + Math.random().toString(36).slice(2, 9);
                try {
                  if (Object.keys(nodeData).length > 0) {
                    jm.add_node(parentId, nid, topicStr, nodeData);
                  } else {
                    jm.add_node(parentId, nid, topicStr);
                  }
                } catch (_err) {
                  jm.add_node(parentId, nid, topicStr);
                }
              } catch (e) { console.warn('批量插入节点项失败', e); }
            });
          }
        };

        switch (actionType) {
          case 'create_sibling': {
            // 插入同级：优先通过真实节点对象的 parent，兼容回退到 jm.get_parent(id)
            var nodeObj = null, parent = null;
            try { nodeObj = jm.get_node ? jm.get_node(sel.id) : sel; } catch (_) { nodeObj = sel; }
            try { parent = (nodeObj && nodeObj.parent) ? nodeObj.parent : null; } catch (_) { parent = null; }
            if (!parent) {
              try { parent = (jm.get_parent && sel && sel.id) ? jm.get_parent(sel.id) : null; } catch (_) { parent = null; }
            }
            if (parent && parent.id) {
              addMany(parent.id);
            } else {
              // 根节点无同级：降级为添加子级并提示
              addMany(sel.id);
              try { showWarning && showWarning('根节点无法添加同级，已改为添加子级'); } catch (_) { }
            }
            break;
          }
          case 'expand_notes': {
            // 扩写备注：将解析文本追加到选中节点备注（用空行隔开），无备注则直接写入
            try {
              var node = jm.get_node ? jm.get_node(sel.id) : sel;
              if (node) {
                node.data = node.data || {};
                var newText = String(ctx.parsedText || '').replace(/\r/g, '').trim();
                var oldText = '';
                try { oldText = String((node.data && node.data.notes) || '').replace(/\r/g, ''); } catch (_) { oldText = ''; }
                console.debug('[MW][AI][expand_notes] before', { id: node.id, oldLen: (oldText || '').length, appendLen: (newText || '').length });
                node.data.notes = oldText ? (oldText.replace(/\\s+$/, '') + '\\n\\n' + newText) : newText;
                try { node.notes = node.data.notes; } catch (_) { }
                console.debug('[MW][AI][expand_notes] after', { id: node.id, totalLen: ((node.data && node.data.notes) ? node.data.notes.length : 0) });
                jm.update_node(node.id, node.topic || '');
                // 同步详情面板 textarea 并触发输入事件，复用 handleAutoUpdate 的保存/同步流程
                try {
                  var ta = document.getElementById('nodeNotes');
                  if (ta) {
                    ta.value = node.data.notes || '';
                    console.debug('[MW][AI][expand_notes] sync textarea#nodeNotes -> dispatch input');
                    ta.dispatchEvent(new Event('input', { bubbles: true }));
                  } else {
                    console.debug('[MW][AI][expand_notes] textarea#nodeNotes not found');
                  }
                } catch (e) { console.warn('[MW][AI][expand_notes] textarea sync failed', e); }
                console.debug('[MW][AI][expand_notes] funcs', {
                  refreshAllNotesDisplay: typeof refreshAllNotesDisplay,
                  saveToLocalStorage: typeof saveToLocalStorage,
                  showAutoUpdateIndicator: typeof showAutoUpdateIndicator,
                  debouncedSave: typeof debouncedSave,
                  w_refreshAllNotesDisplay: typeof window.refreshAllNotesDisplay,
                  w_saveToLocalStorage: typeof window.saveToLocalStorage,
                  w_showAutoUpdateIndicator: typeof window.showAutoUpdateIndicator,
                  w_debouncedSave: typeof window.debouncedSave
                });
                try {
                  if (typeof refreshAllNotesDisplay === 'function') refreshAllNotesDisplay();
                  else if (typeof window.refreshAllNotesDisplay === 'function') window.refreshAllNotesDisplay();
                } catch (e1) { console.warn('[MW][AI][expand_notes] refreshAllNotesDisplay failed', e1); }
                try {
                  if (typeof saveToLocalStorage === 'function') saveToLocalStorage();
                  else if (typeof window.saveToLocalStorage === 'function') window.saveToLocalStorage();
                } catch (e2) { console.warn('[MW][AI][expand_notes] saveToLocalStorage failed', e2); }
                try {
                  if (typeof showAutoUpdateIndicator === 'function') showAutoUpdateIndicator();
                  else if (typeof window.showAutoUpdateIndicator === 'function') window.showAutoUpdateIndicator();
                } catch (e3) { console.warn('[MW][AI][expand_notes] showAutoUpdateIndicator failed', e3); }
                try {
                  if (typeof debouncedSave === 'function') debouncedSave();
                  else if (typeof window.debouncedSave === 'function') window.debouncedSave();
                } catch (e4) { console.warn('[MW][AI][expand_notes] debouncedSave failed', e4); }
              }
            } catch (e) {
              console.warn('更新备注失败', e);
              showError && showError('更新备注失败');
            }
            break;
          }
          case 'generate_initial_tree': {
            // 简化方案：不在导图内解析，直接把 AI 返回的 Markdown 发给编辑器并触发保存/同步
            try {
              // 取 parsedText（由 expandWithAI 传入），若无则兜底 itemsToInsert 拼接
              var md = '';
              try {
                md = (typeof ctx.parsedText === 'string') ? ctx.parsedText : '';
              } catch (_) { md = ''; }
              if (!md) {
                // 兜底：从 itemsToInsert 拼成 Markdown（每项一行）
                var itemsList = Array.isArray(ctx.itemsToInsert) ? ctx.itemsToInsert : [];
                md = itemsList.map(function (it) {
                  if (typeof it === 'string') return it;
                  if (it && typeof it === 'object') return (it.raw || it.topic || '');
                  return String(it || '');
                }).filter(Boolean).join(String.fromCharCode(10));
              }
              md = String(md || '');
              if (!md.trim()) {
                showWarning && showWarning('AI 未返回有效 Markdown，无法生成初始树');
                break;
              }

              // 在父页查找编辑器 iframe
              var editorFrame = null;
              try { editorFrame = window.parent && window.parent.document && window.parent.document.querySelector('iframe[data-panel="editor"]'); } catch (e) { editorFrame = null; }
              if (!editorFrame) {
                try { editorFrame = window.parent && window.parent.document && window.parent.document.getElementById('iframe-editor'); } catch (e) { /* ignore */ }
              }
              if (!editorFrame) {
                try { editorFrame = window.parent && window.parent.document && window.parent.document.querySelector('iframe[src*="editor/editor.html"]'); } catch (e) { /* ignore */ }
              }
              var targetWin = (editorFrame && editorFrame.contentWindow) ? editorFrame.contentWindow : null;
              if (!targetWin) {
                showError && showError('未找到编辑器面板，无法替换文档内容');
                break;
              }

              // 发送“设置 Markdown”与“保存/同步”的消息到编辑器
              try {
                targetWin.postMessage({ type: 'editor-set-markdown', markdown: md, requestId: (window.__mw_ai_active_requestId || null), source: 'mindmap' }, '*');
              } catch (e1) { console.warn('[MW][AI] post editor-set-markdown failed', e1); }
              setTimeout(function () {
                try {
                  targetWin.postMessage({ type: 'editor-save-or-sync', reason: 'generate_initial_tree', requestId: (window.__mw_ai_active_requestId || null), source: 'mindmap' }, '*');
                } catch (e2) { console.warn('[MW][AI] post editor-save-or-sync failed', e2); }
              }, 50);

              try { showSuccess && showSuccess('已将内容发送到编辑器并触发保存/同步'); } catch (_) { }
            } catch (e) {
              console.warn('生成初始树发送到编辑器失败', e);
              showError && showError('生成初始树失败');
            }
            break;
          }
          case 'create_child':
          default: {
            addMany(sel.id);
            break;
          }
        }

        try { if (typeof debouncedSave === 'function') debouncedSave(); } catch (e) { }
      } catch (e) {
        console.error('applyAIAction 处理失败', e);
        showError && showError('处理 AI 动作失败: ' + (e && e.message ? e.message : String(e)));
      }
    }


    // --- extracted block from original HTML ---
    // AI扩写函数（改为使用父层托管的 AI 弹窗组件，modal 模式）

    // 入口快捷函数：通过 window.__mw_next_* 传递 actionType / 模板 / 占位符
    function aiCreateChild() {
      window.__mw_next_actionType = 'create_child';
      window.__mw_next_templateKey = '扩展子节点';
      expandWithAI();
    }
    function aiCreateSibling() {
      window.__mw_next_actionType = 'create_sibling';
      window.__mw_next_templateKey = '创建同级'; // 如有专用模板，可改为 '扩展同级'
      expandWithAI();
    }
    function aiExpandNotes() {
      window.__mw_next_actionType = 'expand_notes';
      window.__mw_next_templateKey = '扩写备注';
      expandWithAI();
    }
    function aiGenerateInitialTree() {
      try {
        var theme = prompt('请输入初始主题（根节点）');
        if (!theme) { showWarning && showWarning('请输入主题'); return; }
        // 若未选中节点，尝试选中根节点，便于插入
        try {
          var root = jm.get_root && jm.get_root();
          if (root && root.id) jm.select_node(root.id);
        } catch (_) { }
        window.__mw_next_actionType = 'generate_initial_tree';
        window.__mw_next_templateKey = '生成初始树';
        window.__mw_next_placeholders = { name: { desc: '初始主题', value: theme } };
        expandWithAI();
      } catch (e) { showError && showError('生成初始树失败: ' + (e.message || e)); }
    }
    // 简易修改/删除（占位实现）
    function quickModifyNode() {
      try {
        var sel = jm.get_selected_node && jm.get_selected_node();
        if (!sel) { showWarning && showWarning('请先选择一个节点'); return; }

        // 无论开关是否开启，都显示节点详情面板
        try {
          // 先显示面板
          if (typeof showNodeDetailsPanel === 'function') {
            showNodeDetailsPanel();
          }
          // 再显示节点详情内容
          if (typeof window.showNodeDetails === 'function') {
            window.showNodeDetails(sel);
          } else if (typeof showNodeDetails === 'function') {
            showNodeDetails(sel);
          }
        } catch (e) {
          console.warn('显示节点详情失败:', e);
        }
      } catch (e) {
        showError && showError('修改失败');
      }
    }
    function quickDeleteNode() {
      try {
        var selectedNodes = (typeof window.getMultiSelection === 'function') ? window.getMultiSelection() : [];
        if (selectedNodes.length > 1) {
          if (confirm('确认删除所有选中的 ' + selectedNodes.length + ' 个节点？')) {
            selectedNodes.forEach(function (nodeId) {
              jm.remove_node(nodeId);
            });
            try { if (typeof debouncedSave === 'function') debouncedSave(); } catch (_) { }
          }
        } else {
          var sel = jm.get_selected_node && jm.get_selected_node();
          if (!sel) { showWarning && showWarning('请先选择一个节点'); return; }
          if (confirm('确认删除该节点及其子节点？')) {
            jm.remove_node(sel.id);
            try { if (typeof debouncedSave === 'function') debouncedSave(); } catch (_) { }
          }
        }
      } catch (e) { showError && showError('删除失败'); }
    }

    // AI扩写函数（改为使用父层托管的 AI 弹窗组件，modal 模式）
    function expandWithAI() {
      try {
        const selectedNode = jm.get_selected_node();
        if (!selectedNode) {
          showWarning('请先选择一个节点');
          return;
        }

        // 构造 requestId
        function genId() { return 'r_' + Math.random().toString(36).slice(2, 10); }
        const requestId = genId();
        try { window.__mw_ai_active_requestId = requestId; } catch (_) { }
        try { window.__mw_handled_requests = window.__mw_handled_requests || {}; } catch (_) { window.__mw_handled_requests = {}; }

        // 准备 templateData：使用预设模板（扩展子节点），并注入真实上下文
        var topic = selectedNode.topic || '';
        // 优先从最新节点数据读取备注；回退到详情面板输入
        var _nodeLatest = null;
        try { _nodeLatest = jm.get_node ? jm.get_node(selectedNode.id) : selectedNode; } catch (_) { _nodeLatest = selectedNode; }
        var notes = (_nodeLatest && _nodeLatest.data && _nodeLatest.data.notes) ? _nodeLatest.data.notes
          : (document.getElementById('nodeNotes') ? document.getElementById('nodeNotes').value : '');

        // 计算 fullPath 与 siblingNodes（若可用）
        function _computeFullPath(n) {
          try {
            if (typeof window.getNodeFullPath === 'function') return window.getNodeFullPath(n);
          } catch (_) { /* ignore */ }
          try {
            var path = [];
            var cur = n;
            while (cur) {
              path.unshift(cur.topic || '');
              var p = jm.get_parent ? jm.get_parent(cur.id) : null;
              if (!p) break;
              cur = p;
            }
            return path.join(' / ');
          } catch (e) {
            return n.topic || '';
          }
        }
        // 统一使用真实节点对象，避免轻量对象丢失父链/children
        var realSel = null;
        try { realSel = jm.get_node ? jm.get_node(selectedNode.id) : selectedNode; } catch (_) { realSel = selectedNode; }

        // 完整路径：从根到当前节点
        function _computeFullPathStrict(n) {
          try {
            // 若有外部工具函数则优先
            if (typeof window.getNodeFullPath === 'function') return window.getNodeFullPath(n);
          } catch (_) { /* ignore */ }
          try {
            var path = [];
            var cur = n;
            while (cur) {
              path.unshift(cur.topic || '');
              cur = (jm.get_parent && cur.id) ? jm.get_parent(cur.id) : null;
            }
            return path.join(' / ');
          } catch (e) { return n && (n.topic || ''); }
        }
        var fullPath = '';
        try {
          fullPath = (realSel && realSel.data && (realSel.data.fullPath || (realSel.data.data && realSel.data.data.fullPath))) || '';
        } catch (e) {
          fullPath = (realSel && realSel.topic) ? realSel.topic : '';
        }

        // 兄弟节点：直接从节点数据中读取（优先使用 data.siblingNodes）
        var siblingNodes = '';
        try {
          var sib = (realSel && realSel.data && (realSel.data.siblingNodes || (realSel.data.data && realSel.data.data.siblingNodes))) || [];
          if (Array.isArray(sib)) {
            siblingNodes = sib.filter(Boolean).join(', ');
          } else if (typeof sib === 'string') {
            siblingNodes = sib;
          }
        } catch (e) { siblingNodes = ''; }

        // 从 prompt-templates.json 中读取“扩展子节点”模板内容（若无法访问则回退）
        var templateText = '';
        try {
          var tplList = window.__prompt_templates || null;
          if (!tplList) {
            // lazy load from ai/newai/prompt-templates.json if available via fetch (silent)
            try {
              // sync attempt may fail in file://; fallback to default string
              // we will try to read from a global if demo pages preloaded templates
              tplList = window.__prompt_templates || tplList;
            } catch (err) { tplList = tplList || null; }
          }
          if (Array.isArray(tplList)) {
            var key = (typeof window.__mw_next_templateKey === 'string' && window.__mw_next_templateKey) ? window.__mw_next_templateKey : '扩展子节点';
            for (var ti = 0; ti < tplList.length; ti++) {
              var t = tplList[ti];
              if (t && t.name === key) { templateText = t.content || ''; break; }
            }
          }
        } catch (e) { templateText = ''; }

        // 最终回退策略：如果没有模板则使用 topic 或简单占位符
        if (!templateText || !String(templateText).trim()) {
          templateText = topic || '{{name}}';
        }

        var payload = {
          // modal 模式：不设置 mode 或确保不是 'direct'
          platformConfig: {}, // 可选：留空由父页面选择已保存平台或打开配置
          modelConfig: {},
          templateData: {
            templateText: templateText,
            placeholders: {
              // 对齐新组件默认占位符格式 {{name}}
              name: { desc: '节点主题', value: topic },
              notes: { desc: '节点备注', value: notes },
              fullPath: { desc: '节点完整路径', value: fullPath },
              siblingNodes: { desc: '同级兄弟节点（以逗号分隔）', value: siblingNodes },
              nodeId: { desc: '节点ID', value: selectedNode.id },
              // 补充上下文摘要，复用旧逻辑思想：提供可读文本，便于模板直接引用 {{context}}
              context: {
                desc: '节点上下文摘要',
                value: (function () {
                  try {
                    var lines = [];
                    lines.push('节点: ' + (topic || ''));
                    lines.push('路径: ' + (fullPath || ''));
                    // 注入 raw 信息（仅当节点自身包含 raw 字段时）
                    var rawVal = selectedNode.data.data.raw || '';


                    lines.push('raw: ' + rawVal);

                    if (notes) lines.push('备注: ' + notes);
                    if (parent && (parent.topic || '')) lines.push('父节点: ' + (parent.topic || ''));
                    if (siblingNodes) lines.push('同级兄弟: ' + siblingNodes);
                    var childTitles = (selectedNode.children || []).map(function (c) { return c.topic || ''; }).filter(Boolean).join(', ');
                    if (childTitles) lines.push('已有子节点: ' + childTitles);
                    return lines.join('\n');
                  } catch (e) {
                    return (topic || '') + '\n' + (fullPath || '');
                  }
                })()
              }
            }
          },
          options: {}
        };

        // 合并外部指定的占位符（如生成初始树传入主题）
        try {
          var extraPH = (window.__mw_next_placeholders && typeof window.__mw_next_placeholders === 'object') ? window.__mw_next_placeholders : null;
          if (extraPH) {
            Object.keys(extraPH).forEach(function (k) {
              payload.templateData.placeholders[k] = extraPH[k];
            });
          }
        } catch (_) { }

        // 指定模板 key 与参数映射；actionType 支持外部预设
        try { payload.templateData.templateKey = (window.__mw_next_templateKey || '扩展子节点'); } catch (e) { }
        try { payload.params = payload.templateData.placeholders; } catch (e) { }
        try { payload.actionType = (window.__mw_next_actionType || 'create_child'); } catch (_) { }

        // 临时消息处理器：等待 AI_MODAL_RESULT 回来
        const onMessage = function (e) {
          try {
            const msg = e && e.data;
            var isSave = !!(msg && msg.type === 'AI_MODAL_SAVE_OUTPUT');
            var okId = !!(msg && (
              (msg.requestId === requestId) ||
              (isSave && !msg.requestId && window.__mw_ai_active_requestId === requestId)
            ));
            if (!msg || (msg.type !== 'AI_MODAL_RESULT' && msg.type !== 'AI_MODAL_SAVE_OUTPUT') || !okId) {
              return;
            }
            // 若父页随后广播 cancel，但本请求已处理过，则忽略
            if (msg.type === 'AI_MODAL_RESULT' && msg.status === 'cancel') {
              try { if (window.__mw_handled_requests && window.__mw_handled_requests[requestId]) return; } catch (_) { }
            }
            // 清理
            window.removeEventListener('message', onMessage);
            clearTimeout(timeoutT);
            try { delete window.__mw_ai_active_requestId; } catch (_) { }

            if (msg.type === 'AI_MODAL_SAVE_OUTPUT' || msg.status === 'ok') {
              try {
                const detail = msg.detail || {};
                // 期望 detail 中包含生成的内容（例如 detail.output 或 detail.text）
                // 支持两种常见格式：detail.output（带 [OUTPUT] 包裹）或 detail.text
                const outText = detail.output || detail.text || (detail.result && detail.result.text) || msg.output || '';
                if (!outText) {
                  showWarning('AI 未返回有效内容');
                  return;
                }
                // 标记本次请求已获得有效输出，用于忽略后续 cancel
                try { window.__mw_handled_requests[requestId] = true; window.__mw_lastHandledId = requestId; } catch (_) { }

                // 将 AI 返回的文本解析为若干子节点 —— 先尝试使用 converter(md->AST)，若不可用则回退到行解析
                let parsed = outText;
                const m = /\[OUTPUT\]([\s\S]*)\[\/OUTPUT\]/i.exec(outText);
                if (m && m[1]) parsed = m[1].trim();

                // 规范化文本（去除CR）
                var normalized = (parsed || '').replace(/\r/g, '').replace(/\[OUTPUT\]|\[\/OUTPUT\]/gi, '');

                // 简单判定是否为 Markdown（包含标题或列表标记）
                var looksLikeMarkdown = /(^\s*#{1,6}\s+)|(^\s*[-\*\+]\s+)|(^\s*\d+[\.\、]\s+)/m.test(normalized);

                // 标记：如果成功使用转换器插入则设为 true，后续逻辑会直接返回
                var converterInserted = false;

                if (looksLikeMarkdown) {
                  try {
                    // 动态加载转换器（使用 Promise 链，兼容非-async 环境）
                    var tryLoadConverter = function () {
                      return import('../converter/md-to-ast.js').catch(function (e1) {
                        return import('./converter/md-to-ast.js').catch(function (e2) {
                          return null;
                        });
                      });
                    };
                    var mdmod = null;
                    tryLoadConverter().then(function (mod) {
                      mdmod = mod;
                      if (mdmod && mdmod.MdToAstConverter) {
                        try {
                          const conv = new mdmod.MdToAstConverter();
                          const ast = conv.convert(normalized);
                          // 优先使用已有 converter 将 AST 转为 node_tree，然后一次性插入 node_tree 的 children 到所选节点下
                          try {
                            var nodeTree = null;
                            try {
                              // 优先使用全局 window.converter（converter.js 的实例），否则尝试导入本地 converter 模块
                              if (window && window.converter && typeof window.converter.astToNodeTree === 'function') {
                                nodeTree = window.converter.astToNodeTree(ast);
                              } else {
                                // 尝试动态导入 converter.js 并调用 astToNodeTree
                                try {
                                  var convModule = null;
                                  try { convModule = import('../converter/converter.js'); } catch (_) { try { convModule = import('./converter/converter.js'); } catch (__) { convModule = null; } }
                                  if (convModule && convModule.default && typeof convModule.default.astToNodeTree === 'function') {
                                    nodeTree = convModule.default.astToNodeTree(ast);
                                  } else if (convModule && typeof convModule.astToNodeTree === 'function') {
                                    nodeTree = convModule.astToNodeTree(ast);
                                  }
                                } catch (eConv) {
                                  console.warn('[MW][AI] 动态导入 converter.js 失败', eConv);
                                  nodeTree = null;
                                }
                              }
                            } catch (e) {
                              console.warn('[MW][AI] astToNodeTree 调用失败', e);
                              nodeTree = null;
                            }

                            // 将 nodeTree 的 children 递归插入到 selectedNode 下
                            function insertNodeTreeChildren(parentId, ntNode, requestId) {
                              if (!ntNode) return;
                              // 防重复插入锁：使用基于 requestId 的局部锁，避免全局阻塞
                              try {
                                window._mw_ai_inserting_requests = window._mw_ai_inserting_requests || {};
                              } catch (e) {
                                window._mw_ai_inserting_requests = {};
                              }
                              if (requestId && window._mw_ai_inserting_requests[requestId]) {
                                console.debug('[MW][AI] insertNodeTreeChildren skipped: insertion already in progress for', requestId);
                                return;
                              }
                              if (requestId) {
                                try { window._mw_ai_inserting_requests[requestId] = true; } catch (e) { window._mw_ai_inserting_requests[requestId] = true; }
                              } else {
                                // 兜底回退到短期全局标记（向后兼容）
                                try { if (window.__mw_ai_inserting) { console.debug('[MW][AI] insertNodeTreeChildren skipped: global insertion in progress'); return; } } catch (e) { }
                                try { window.__mw_ai_inserting = true; } catch (e) { window.__mw_ai_inserting = true; }
                              }
                              try {
                                var children = ntNode.children || (ntNode.data && ntNode.data.children) || [];
                                if (!Array.isArray(children)) return;

                                // 计算目标 parent 的基准层级（优先使用 core 提供的 getNodeLevel / setNodeLevel）
                                var targetLevel = null;
                                try {
                                  var targetNodeObj = (parentId && jm.get_node) ? jm.get_node(parentId) : null;
                                  if (targetNodeObj && targetNodeObj.data && (targetNodeObj.data.level !== undefined && targetNodeObj.data.level !== null)) {
                                    targetLevel = parseInt(targetNodeObj.data.level, 10);
                                  } else if (typeof window.getNodeLevel === 'function') {
                                    targetLevel = window.getNodeLevel(targetNodeObj) || null;
                                  }
                                } catch (e) { targetLevel = null; }
                                // 若无法获取，设为 1（根下一级）
                                if (targetLevel === null || isNaN(targetLevel)) targetLevel = 1;

                                // 辅助：检测是否存在相同 topic 的兄弟，避免重复（粗略匹配）
                                function siblingExists(parentId, topic) {
                                  try {
                                    if (!parentId || !topic) return false;
                                    var pObj = jm.get_node ? jm.get_node(parentId) : null;
                                    var kids = (pObj && Array.isArray(pObj.children)) ? pObj.children : [];
                                    for (var i = 0; i < kids.length; i++) {
                                      var c = kids[i];
                                      if (!c) continue;
                                      try {
                                        if (String((c.topic || '')).trim() === String(topic).trim()) return true;
                                      } catch (e) { continue; }
                                    }
                                  } catch (e) { }
                                  return false;
                                }

                                // 递归插入，复用 core 的降级/对齐函数（若存在）
                                function _insert(parentId, nodes, depthOffset) {
                                  if (!Array.isArray(nodes) || nodes.length === 0) return;
                                  nodes.forEach(function (child) {
                                    try {
                                      // 计算 topic 优先字段
                                      var topic = child.topic || (child.data && (child.data.topic || child.data.title)) || (child.title || '');
                                      if (!topic && child.data && child.data.raw) {
                                        var fl = String(child.data.raw || '').split('\n').map(function (s) { return s.trim(); }).filter(Boolean)[0] || '';
                                        topic = fl.length > 120 ? fl.slice(0, 120) + '...' : fl;
                                      }

                                      // 如果该 node 本身无可用标题但有 children，则直接提升其 children 到当前层级
                                      var hasChildren = Array.isArray(child.children) && child.children.length > 0;
                                      if (!topic && hasChildren) {
                                        _insert(parentId, child.children, depthOffset);
                                        return;
                                      }
                                      if (!topic && !hasChildren) return;

                                      // 去重：若已存在同名兄弟则跳过
                                      if (siblingExists(parentId, topic)) {
                                        console.debug('[MW][AI] skip duplicate topic under parent', parentId, topic);
                                        // 仍需尝试插入其子节点到已存在节点下以合并内容（可选）
                                        // 找到该兄弟节点 id 并作为新的 parentId
                                        try {
                                          var pObj = jm.get_node ? jm.get_node(parentId) : null;
                                          var existKid = null;
                                          if (pObj && Array.isArray(pObj.children)) {
                                            for (var ii = 0; ii < pObj.children.length; ii++) {
                                              var kk = pObj.children[ii];
                                              if (kk && String((kk.topic || '')).trim() === String(topic).trim()) { existKid = kk; break; }
                                            }
                                          }
                                          if (existKid) {
                                            var existId = existKid.id;
                                            if (hasChildren) _insert(existId, child.children, depthOffset + 1);
                                          }
                                        } catch (e) { /* ignore */ }
                                        return;
                                      }

                                      // 生成新节点 id 与 nodeData（保留 child.data 的安全子集）
                                      var nid = 'n_' + Math.random().toString(36).slice(2, 9);
                                      var nodeData = {};
                                      try { if (child.data) nodeData = Object.assign({}, child.data); } catch (_) { nodeData = {}; }
                                      // 移除超长 raw，避免混合节点问题
                                      try { if (nodeData.raw && typeof nodeData.raw === 'string' && nodeData.raw.length > 600) delete nodeData.raw; } catch (_) { }
                                      // 若 nodeData 中包含 level 字段，优先调整为相对于 targetLevel 的降级值
                                      try {
                                        if (nodeData.level !== undefined && nodeData.level !== null) {
                                          var requested = parseInt(nodeData.level, 10) || 0;
                                          // 将 converter 的 level 映射到以 targetLevel 为基准的层级
                                          nodeData.level = Math.max(1, targetLevel + requested);
                                        } else {
                                          // 若没有显式 level，尝试从 child 自身 data/heading 推断（若 core 提供 setNodeLevel，则可在后处理）
                                          // 这里我们不强行设置 level，交由 core 的 setNodeLevel 或 normalize 函数处理
                                        }
                                      } catch (e) { /* ignore */ }

                                      // 执行插入（尝试保留 nodeData）
                                      try {
                                        if (Object.keys(nodeData).length > 0) {
                                          jm.add_node(parentId, nid, topic, nodeData);
                                        } else {
                                          jm.add_node(parentId, nid, topic);
                                        }
                                      } catch (e) {
                                        try { jm.add_node(parentId, nid, topic); } catch (e2) { console.warn('[MW][AI] jm.add_node failed', e2); return; }
                                      }

                                      // 在 core 中尝试调用自动降级/类型修正函数（若存在）
                                      try {
                                        // setNodeLevel(nodeId, level) 或 applySiblingOrParentType(nodeId)
                                        if (typeof window.setNodeLevel === 'function') {
                                          // 若 nodeData.level 存在则 setNodeLevel
                                          if (nodeData && nodeData.level !== undefined && nodeData.level !== null) {
                                            try { window.setNodeLevel(nid, nodeData.level); } catch (_) { }
                                          } else {
                                            // 以 targetLevel + depthOffset + 1 做默认设置
                                            try { window.setNodeLevel(nid, Math.max(1, targetLevel + (depthOffset || 0))); } catch (_) { }
                                          }
                                        }
                                        if (typeof window.applySiblingOrParentType === 'function') {
                                          try { window.applySiblingOrParentType(nid); } catch (_) { }
                                        }
                                      } catch (e) { /* ignore */ }

                                      // 递归插入子节点（深度 +1）
                                      if (hasChildren) {
                                        _insert(nid, child.children, (depthOffset || 0) + 1);
                                      }
                                    } catch (e) {
                                      console.warn('[MW][AI] 插入 node_tree 子节点失败', e);
                                    }
                                  });
                                }

                                // 开始插入：depthOffset 从 1 开始（子节点相对于 parent）
                                _insert(parentId, children, 1);

                                // 完成后尝试调用一些 core 的 normalize 函数对整段子树做一次性调整（若存在）
                                try {
                                  if (typeof window.adjustChildrenHeadingLevel === 'function') {
                                    try { window.adjustChildrenHeadingLevel(parentId); } catch (e) { }
                                  }
                                  if (typeof window.normalizeSubtreeUnderList === 'function') {
                                    try { window.normalizeSubtreeUnderList(parentId); } catch (e) { }
                                  }
                                } catch (e) { /* ignore */ }

                                try { showSuccess && showSuccess('已通过 converter.astToNodeTree 解析并插入子树'); } catch (e) { }
                                try { if (typeof debouncedSave === 'function') debouncedSave(); } catch (_) { }
                              } finally {
                                // 释放锁
                                try { delete window.__mw_ai_inserting; } catch (e) { window.__mw_ai_inserting = false; }
                              }
                            }

                            if (nodeTree) {
                              // nodeTree 可能为 { data: {...}, children: [...] } 或直接为根节点对象
                              // 若请求的 actionType 不是默认的 create_child，则将 nodeTree 转换为 items 并走 applyAIAction 分发
                              try {
                                var requestedAction = (payload && payload.actionType) ? payload.actionType : 'create_child';
                                if (requestedAction && requestedAction !== 'create_child') {
                                  try {
                                    // 优先处理生成初始树：直接用 nodeTree 构造新的 mindmap 数据并替换当前整棵树
                                    if (requestedAction === 'generate_initial_tree') {
                                      try {
                                        // 统一走 applyAIAction 的新实现：把 Markdown 交给编辑器并保存/同步
                                        if (typeof applyAIAction === 'function') {
                                          applyAIAction('generate_initial_tree', {
                                            selectedNode: selectedNode,
                                            itemsToInsert: [],
                                            parsedText: normalized,
                                            placeholders: (payload && payload.templateData && payload.templateData.placeholders) ? payload.templateData.placeholders : {}
                                          });
                                        }
                                      } catch (e) {
                                        console.warn('[MW][AI] forward to applyAIAction(generate_initial_tree) failed', e);
                                      }
                                      return;
                                    }

                                    // 插入同级：将 nodeTree.children 插入到 selectedNode 的 parent 下（找不到 parent 则降级为插入子节点）
                                    if (requestedAction === 'create_sibling') {
                                      try {
                                        var parentId = null;
                                        try {
                                          var selNodeObj = jm.get_node ? jm.get_node(selectedNode.id) : selectedNode;
                                          if (selNodeObj && selNodeObj.parent) {
                                            parentId = selNodeObj.parent;
                                          } else if (jm.get_parent) {
                                            var p = jm.get_parent(selectedNode.id);
                                            if (p && p.id) parentId = p.id;
                                          }
                                        } catch (e) { parentId = null; }
                                        if (!parentId) parentId = selectedNode.id;
                                        var wrapper = { children: (nodeTree && nodeTree.children) ? nodeTree.children : [] };
                                        insertNodeTreeChildren(parentId, wrapper, requestId || null);
                                        try { showSuccess && showSuccess('已插入同级节点'); } catch (e) { }
                                        try { if (typeof debouncedSave === 'function') debouncedSave(); } catch (_) { }
                                        return;
                                      } catch (e) {
                                        console.warn('[MW][AI] create_sibling 处理失败', e);
                                      }
                                    }

                                    // 其它非 create_child 的情况保持向后兼容，回退到扁平 items 分发
                                    if (typeof applyAIAction === 'function') {
                                      var extractItemsFromNodeTree = function (nt) {
                                        var res = [];
                                        if (!nt) return res;
                                        var children = nt.children || (nt.data && nt.data.children) || [];
                                        if (!Array.isArray(children)) return res;
                                        children.forEach(function (c) {
                                          try {
                                            var title = c.topic || (c.data && (c.data.topic || c.data.title)) || c.title || '';
                                            if (!title && c.data && c.data.raw) {
                                              title = String(c.data.raw || '').split('\n').map(function (s) { return s.trim(); }).filter(Boolean)[0] || '';
                                            }
                                            if (title) {
                                              var it = { topic: title };
                                              if (c.data && c.data.raw) it.raw = c.data.raw;
                                              res.push(it);
                                            }
                                          } catch (e) { /* ignore */ }
                                        });
                                        return res;
                                      };
                                      var items = extractItemsFromNodeTree(nodeTree);
                                      applyAIAction(requestedAction, {
                                        selectedNode: selectedNode,
                                        itemsToInsert: items,
                                        childNodes: items,
                                        childTitles: items.map(function (it) { return it.topic || ''; }),
                                        parsedText: normalized,
                                        placeholders: (payload && payload.templateData && payload.templateData.placeholders) ? payload.templateData.placeholders : {}
                                      });
                                      try { showSuccess && showSuccess('已通过 converter.astToNodeTree 解析并分发为 ' + items.length + ' 项'); } catch (e) { }
                                      try { if (typeof debouncedSave === 'function') debouncedSave(); } catch (_) { }
                                      return;
                                    }
                                  } catch (e) {
                                    console.warn('[MW][AI] nodeTree 特殊 action 分发失败，回退到默认插入', e);
                                  }
                                }
                              } catch (e) {
                                console.warn('[MW][AI] nodeTree 分发为 actionItems 时出错，回退到插入子树', e);
                              }
                              // 默认行为：插入为子树（传入 requestId 以使用局部锁）
                              insertNodeTreeChildren(selectedNode.id, nodeTree, requestId || null);
                              try { showSuccess && showSuccess('已通过 converter.astToNodeTree 解析并插入子树'); } catch (e) { }
                              try { if (typeof debouncedSave === 'function') debouncedSave(); } catch (_) { }
                              return;
                            }
                          } catch (convErr) {
                            console.warn('[MW][AI] 使用 astToNodeTree 插入失败，回退到原处理', convErr);
                            converterInserted = false;
                          }
                        } catch (convErr) {
                          console.warn('[MW][AI] md->AST 转换失败', convErr);
                          converterInserted = false;
                        }
                      }
                    }).catch(function (err) {
                      console.warn('[MW][AI] 动态加载 md->AST 模块失败', err);
                      converterInserted = false;
                    });
                  } catch (e) {
                    console.warn('[MW][AI] 动态加载 md->AST 模块失败', e);
                    converterInserted = false;
                  }
                }

                // // 若未使用转换器或转换失败，则回退到原有的逐行解析逻辑（保持兼容）
                // var rawLines = normalized.split('\\n');
                // var childNodes = [];
                // var childTitles = [];
                // var lastNode = null;

                // rawLines.forEach(function (raw) {
                //   if (!raw || !raw.trim()) return;
                //   var line = raw.replace(/\\t/g, '  '); // 把 tab 视作两个空格
                //   var trimmed = line.trim();

                //   // 检查 markdown 标题，如: "# Title" 或 "## Title"
                //   var headerMatch = trimmed.match(/^(#{1,6})\\s+(.*)$/);
                //   if (headerMatch) {
                //     var level = headerMatch[1].length;
                //     var topic = headerMatch[2].trim();
                //     if (topic) {
                //       var nodeObj = { topic: topic, level: level, notes: '' };
                //       childNodes.push(nodeObj);
                //       childTitles.push(topic);
                //       lastNode = nodeObj;
                //     }
                //     return;
                //   }

                //   // 检查 markdown 列表项，支持 "-","*","+","1.","1、" 等
                //   var listMatch = line.match(/^(\\s*)(?:[-\\*\\+]|(\\d+)[\\.、])\\s+(.*)$/);
                //   if (listMatch) {
                //     var indent = listMatch[1].length;
                //     var levelFromIndent = Math.floor(indent / 2) + 1;
                //     var topic = (listMatch[3] || '').trim();
                //     if (topic) {
                //       var nodeObj = { topic: topic, level: levelFromIndent, notes: '' };
                //       childNodes.push(nodeObj);
                //       childTitles.push(topic);
                //       lastNode = nodeObj;
                //     }
                //     return;
                //   }

                //   // 其他行：追加到最近解析的节点 notes
                //   var nonTitleText = trimmed;
                //   if (nonTitleText) {
                //     if (lastNode) {
                //       lastNode.notes = lastNode.notes ? (lastNode.notes + '\\n' + nonTitleText) : nonTitleText;
                //     } else if (childNodes.length > 0) {
                //       var prev = childNodes[childNodes.length - 1];
                //       if (prev) {
                //         prev.notes = prev.notes ? (prev.notes + '\\n' + nonTitleText) : nonTitleText;
                //         lastNode = prev;
                //       }
                //     } else {
                //       var nodeObj = { topic: nonTitleText, level: 1, notes: '' };
                //       childNodes.push(nodeObj);
                //       childTitles.push(nonTitleText);
                //       lastNode = nodeObj;
                //     }
                //   }
                //   return;
                // });
                // // end of fallback parsing




                // if (childTitles.length === 0) {
                //   // 退回到按段落分割：按连续空行（'\n\n' 或 更多）分割
                //   var paras = normalized.split(/\n{2,}/).map(function (s) { return (s || '').trim(); }).filter(function (s) { return !!s; });
                //   paras.forEach(function (p) {
                //     var firstLine = (p.split('\n')[0] || '').trim();
                //     if (firstLine) childTitles.push(firstLine);
                //   });
                // }

                // if (childTitles.length === 0) {
                //   showWarning('无法从 AI 输出解析出子节点，请检查输出格式');
                //   return;
                // }

                // // 根据 actionType 分发处理；非 create_child 则提前处理并返回
                // var itemsToInsert = (typeof childNodes !== 'undefined' && Array.isArray(childNodes) && childNodes.length > 0) ? childNodes : childTitles;
                // applyAIAction((payload && payload.actionType) ? payload.actionType : 'create_child', {
                //   selectedNode: selectedNode,
                //   itemsToInsert: itemsToInsert,
                //   childNodes: childNodes,
                //   childTitles: childTitles,
                //   parsedText: normalized,
                //   placeholders: (payload && payload.templateData && payload.templateData.placeholders) ? payload.templateData.placeholders : {}
                // });
                // if (true) {
                //   try { showSuccess && showSuccess('AI处理完成，解析到 ' + childTitles.length + ' 项'); } catch (e) { }
                //   return;
                // }

                // // 插入子节点（使用 jm API，插入到 selectedNode 下）
                // // 兼容 childNodes（[{topic, level}...]）和旧的 childTitles（['t1','t2']）
                // var itemsToInsert = (typeof childNodes !== 'undefined' && Array.isArray(childNodes) && childNodes.length > 0) ? childNodes : childTitles;
                // itemsToInsert.forEach(function (item, idx) {
                //   try {
                //     // 规范化 topicStr 与 nodeData
                //     var topicStr = '';
                //     var nodeData = {};
                //     if (typeof item === 'string') {
                //       topicStr = item;
                //     } else if (item && typeof item === 'object') {
                //       topicStr = (item.topic !== undefined) ? String(item.topic) : '';
                //       if (item.level !== undefined && item.level !== null) {
                //         nodeData.level = item.level;
                //       }
                //       // 保留原始 raw 文本以便调试/回写（如果需要）
                //       if (item.raw) nodeData.raw = item.raw;
                //       // 如果解析到了 notes，则传入以便新节点带上备注
                //       if (item.notes) nodeData.notes = item.notes;
                //     } else {
                //       topicStr = String(item);
                //     }

                //     if (!topicStr) return; // 跳过空项

                //     // 使用 jm.add_node(parentid, nodeid, topic, data)
                //     const nid = 'n_' + Math.random().toString(36).slice(2, 9);
                //     // 如果 jm.add_node 接受第四个参数 data，则传入 nodeData；若不接受也不会报错（安全尝试）
                //     try {
                //       if (Object.keys(nodeData).length > 0) {
                //         jm.add_node(selectedNode.id, nid, topicStr, nodeData);
                //       } else {
                //         jm.add_node(selectedNode.id, nid, topicStr);
                //       }
                //     } catch (innerErr) {
                //       // 兼容性回退：仅传 topic
                //       jm.add_node(selectedNode.id, nid, topicStr);
                //     }
                //   } catch (e) {
                //     console.warn('插入子节点失败', e);
                //   }
                // });

                // 保存 / 提示
                try { if (typeof debouncedSave === 'function') debouncedSave(); } catch (e) { }
                try { showSuccess && showSuccess('已为该节点生成 ' + childTitles.length + ' 个子节点'); } catch (e) { }
              } catch (err) {
                console.error('处理 AI 结果失败', err);
                showError('处理 AI 结果失败: ' + (err && err.message ? err.message : String(err)));
              }
            } else {
              // error
              const detailMsg = (msg.detail && msg.detail.message) ? msg.detail.message : 'AI 返回错误';
              showError('AI 生成失败: ' + detailMsg);
            }
          } catch (e) {
            console.warn('expandWithAI onMessage error', e);
          }
        };

        window.addEventListener('message', onMessage);

        // 超时保护（30s）：仅在非嵌入（非 modal）场景显示全局错误；嵌入场景由父页面/modal 处理超时
        const timeoutT = setTimeout(function () {
          try {
            // 先移除监听，避免后续重复触发
            window.removeEventListener('message', onMessage);
            // 若当前页面被嵌入到父页面（通常表示会由父页面显示 modal），则跳过本地的错误提示
            const isEmbedded = (window.parent && window.parent !== window);
            if (isEmbedded) {
              console.debug('[MW][AI] timeout skipped: parent/modal should handle it', requestId);
              // 可选：通知父窗口超时（注释掉以避免多余消息）
              // try { window.parent.postMessage({ type: 'AI_MODAL_TIMEOUT', requestId: requestId }, '*'); } catch (_) {}
              return;
            }
            // 非嵌入（headless）场景显示本地错误
            showError('AI 响应超时（30s）');
          } catch (e) { }
        }, 30000);

        // 发送请求给父页面
        try {
          console.log('[MW][AI] send AI_MODAL_OPEN_REQUEST', requestId, payload);
          window.parent.postMessage({ type: 'AI_MODAL_OPEN_REQUEST', requestId: requestId, payload: payload }, '*');
          // 清理一次性预设
          try {
            delete window.__mw_next_actionType;
            delete window.__mw_next_templateKey;
            delete window.__mw_next_placeholders;
          } catch (_) { }
        } catch (e) {
          clearTimeout(timeoutT);
          window.removeEventListener('message', onMessage);
          console.error('发送 AI 请求失败', e);
          showError('发送 AI 请求失败: ' + e.message);
        }

      } catch (e) {
        console.error('AI扩写出错:', e);
        showError('AI扩写出错: ' + e.message);
      }
    }

    // 隐藏/显示浮动面板的 API（供 showNodeDetails 调用）
    function hideNodeDetails() {
      const p = document.getElementById('nodeDetails');
      if (p) {
        p.style.display = 'none';
        p.setAttribute('aria-hidden', 'true');
        // 安全移除拖拽监听（若在闭包中定义则不会抛错）
        if (typeof removeNodeDetailsDragHandlers === 'function') {
          try { removeNodeDetailsDragHandlers(); } catch (e) { /* ignore */ }
        } else if (typeof window.removeNodeDetailsDragHandlers === 'function') {
          try { window.removeNodeDetailsDragHandlers(); } catch (e) { /* ignore */ }
        }
      }
      // 同步关闭“详情面板”开关，直到用户手动再开启
      try {
        window.__nodeDetailsEnabled = false;
        const cb = document.getElementById('toggleNodeDetailsCheckbox');
        if (cb) {
          cb.checked = false;
          cb.setAttribute('aria-checked', 'false');
        }
        const btn = document.getElementById('toggleNodeDetailsBtn');
        if (btn) {
          btn.classList.remove('state-on');
          btn.classList.remove('state-default');
          btn.classList.add('state-off');
          btn.setAttribute('aria-pressed', 'false');
        }
      } catch (e) { /* ignore */ }
    }
    function showNodeDetailsPanel() {
      const p = document.getElementById('nodeDetails');
      if (p) {
        p.style.display = 'block';
        p.setAttribute('aria-hidden', 'false');
        // 仅当面板未被用户移动过时，才重置为默认靠右位置
        if (p.dataset.moved !== 'true') {
          p.style.right = '12px';
          p.style.left = 'auto';
          p.style.top = '80px';
        }
        // 初始化拖拽监听（幂等）
        try {
          if (typeof initNodeDetailsDragHandlers === 'function') {
            initNodeDetailsDragHandlers();
          } else if (typeof window.initNodeDetailsDragHandlers === 'function') {
            window.initNodeDetailsDragHandlers();
          }
        } catch (e) { /* ignore */ }
      }
    }

    /* 打开详情面板并提示“请选择一个节点” */
    function showEmptyDetailsPrompt() {
      try {
        if (window.__nodeDetailsEnabled === false) {
          try { console.log('[MW][details][UI] skip empty: toggle disabled'); } catch (e) { }
          return;
        }
        // 确保面板可见
        try { showNodeDetailsPanel(); } catch (e) { try { console.warn('[MW][details][UI] showNodeDetailsPanel failed', e); } catch (ee) { } }
        var panel = document.getElementById('nodeDetails');
        var empty = document.getElementById('nodeDetailsEmpty');
        var form = document.getElementById('nodeDetailsForm');
        var info = document.getElementById('nodeInfo');
        var topic = document.getElementById('nodeTopic');
        var notes = document.getElementById('nodeNotes');

        // 切换为空状态：显示空视图，隐藏表单
        if (empty) empty.style.display = 'block';
        if (form) form.style.display = 'none';

        if (topic) topic.value = '';
        if (notes) notes.value = '';

        // 关键日志：输出各元素与可见性
        try {
          console.log('[MW][details][UI] showEmptyDetailsPrompt:',
            {
              panelExists: !!panel,
              panelDisplay: panel && panel.style ? panel.style.display : undefined,
              panelAriaHidden: panel ? panel.getAttribute('aria-hidden') : undefined,
              emptyExists: !!empty,
              emptyDisplay: empty && empty.style ? empty.style.display : undefined,
              formExists: !!form,
              formDisplay: form && form.style ? form.style.display : undefined
            }
          );
        } catch (e) { }
      } catch (e) {
        try { console.warn('[MW][details][UI] showEmptyDetailsPrompt error', e); } catch (ee) { }
      }
    }

    try { window.showEmptyDetailsPrompt = showEmptyDetailsPrompt; } catch (e) { /* ignore */ }
    // 缩放中心修正：在鼠标/触摸位置设置 transform-origin，配合现有库缩放以该点为中心
    (function setupZoomOrigin() {
      const container = document.getElementById('fullScreenMindmap');
      if (!container) return;
      function setOrigin(clientX, clientY) {
        const rect = container.getBoundingClientRect();
        const x = clientX - rect.left;
        const y = clientY - rect.top;
        container.style.transformOrigin = `${x}px ${y}px`;
      }
      // 鼠标滚轮：在缩放前设置 origin
      container.addEventListener('wheel', function (e) {
        if (e.ctrlKey || e.metaKey || e.shiftKey || e.altKey) {
          // 若用户同时按键，仍支持，但优先设置 origin
        }
        setOrigin(e.clientX, e.clientY);
        // 不阻止原生滚动/缩放逻辑，让现有库处理实际缩放
      }, { passive: true });
      // 触摸：记录触摸点以设置 origin（用于双指缩放前）
      container.addEventListener('touchstart', function (e) {
        if (!e.touches || e.touches.length === 0) return;
        const t = e.touches[0];
        setOrigin(t.clientX, t.clientY);
      }, { passive: true });
    })();


    /* 拖拽支持：鼠标与触摸 */
    (function () {
      let dragging = false;
      let startX = 0, startY = 0;
      let origLeft = 0, origTop = 0;
      let handlersAdded = false;



      function onPointerDown(e) {
        const p = document.getElementById('nodeDetails');
        if (!p) return;
        dragging = true;
        p.style.transition = 'none';
        const rect = p.getBoundingClientRect();
        origLeft = rect.left;
        origTop = rect.top;
        if (e.type === 'touchstart') {
          startX = e.touches[0].clientX;
          startY = e.touches[0].clientY;
        } else {
          startX = e.clientX;
          startY = e.clientY;
        }
        // prevent iframe text selection during drag
        document.body.style.userSelect = 'none';
      }

      function onPointerMove(e) {
        if (!dragging) return;
        const p = document.getElementById('nodeDetails');
        if (!p) return;
        let cx = (e.type === 'touchmove') ? e.touches[0].clientX : e.clientX;
        let cy = (e.type === 'touchmove') ? e.touches[0].clientY : e.clientY;
        const dx = cx - startX;
        const dy = cy - startY;
        const left = origLeft + dx;
        const top = origTop + dy;
        // 限制到视口内
        const vw = Math.max(document.documentElement.clientWidth || 0, window.innerWidth || 0);
        const vh = Math.max(document.documentElement.clientHeight || 0, window.innerHeight || 0);
        const rect = p.getBoundingClientRect();
        const w = rect.width, h = rect.height;
        const minLeft = 8;
        const maxLeft = vw - w - 8;
        const minTop = 8;
        const maxTop = vh - h - 8;
        const nx = Math.min(Math.max(left, minLeft), Math.max(minLeft, maxLeft));
        const ny = Math.min(Math.max(top, minTop), Math.max(minTop, maxTop));
        // 记录临时位移量，onPointerUp 会基于此判断是否标记为已移动
        try {
          p.dataset._dragMovedX = String(dx);
          p.dataset._dragMovedY = String(dy);
        } catch (e) { /* ignore */ }
        p.style.right = 'auto';
        p.style.left = nx + 'px';
        p.style.top = ny + 'px';
      }

      function onPointerUp() {
        if (!dragging) return;
        dragging = false;
        document.body.style.userSelect = '';
        const p = document.getElementById('nodeDetails');
        if (p) p.style.transition = '';
        // 标记是否发生过显著位移，页面未刷新前保持位置
        try {
          if (p) {
            const movedX = parseFloat(p.dataset._dragMovedX || '0');
            const movedY = parseFloat(p.dataset._dragMovedY || '0');
            if (Math.abs(movedX) > 2 || Math.abs(movedY) > 2) {
              p.dataset.moved = 'true';
            }
            delete p.dataset._dragMovedX;
            delete p.dataset._dragMovedY;
          }
        } catch (e) { /* ignore */ }
      }

      function initNodeDetailsDragHandlers() {
        if (handlersAdded) return;
        const p = document.getElementById('nodeDetails');
        if (!p) return;
        // 使用 panel-header 作为抓手，如无则全面板可拖
        const handle = p.querySelector('.panel-header') || p;
        handle.addEventListener('mousedown', onPointerDown, { passive: true });
        window.addEventListener('mousemove', onPointerMove, { passive: true });
        window.addEventListener('mouseup', onPointerUp, { passive: true });
        handle.addEventListener('touchstart', onPointerDown, { passive: true });
        window.addEventListener('touchmove', onPointerMove, { passive: true });
        window.addEventListener('touchend', onPointerUp, { passive: true });
        handlersAdded = true;
      }



      // 如果面板已显示，初始化一次
      document.addEventListener('DOMContentLoaded', function () {
        const p = document.getElementById('nodeDetails');
        if (p && p.style.display !== 'none') initNodeDetailsDragHandlers();
      });
      // 在窗口大小变化时微调位置，避免超出
      window.addEventListener('resize', function () {
        const p = document.getElementById('nodeDetails');
        if (!p || p.style.display === 'none') return;
        const rect = p.getBoundingClientRect();
        const vw = Math.max(document.documentElement.clientWidth || 0, window.innerWidth || 0);
        const vh = Math.max(document.documentElement.clientHeight || 0, window.innerHeight || 0);
        const maxLeft = Math.max(8, vw - rect.width - 8);
        const maxTop = Math.max(8, vh - rect.height - 8);
        let left = rect.left;
        let top = rect.top;
        if (left > maxLeft) left = maxLeft;
        if (top > maxTop) top = maxTop;
        p.style.left = left + 'px';
        p.style.top = top + 'px';
      });

    })();


    // --- extracted block from original HTML ---
    (function () {
      // 节点详情开关（默认开启）
      window.__nodeDetailsEnabled = (window.__nodeDetailsEnabled === undefined) ? false : !!window.__nodeDetailsEnabled;

      function updateToggleUI() {
        var enabled = !!window.__nodeDetailsEnabled;
        // 复选框（兼容保留）
        var cb = document.getElementById('toggleNodeDetailsCheckbox');
        if (cb) {
          cb.checked = enabled;
          cb.setAttribute('aria-checked', enabled ? 'true' : 'false');
        }
        // 图标按钮（新）
        var btn = document.getElementById('toggleNodeDetailsBtn');
        if (btn) {
          btn.classList.remove('state-on', 'state-off', 'state-default');
          btn.classList.add(enabled ? 'state-on' : 'state-off');
          btn.setAttribute('aria-pressed', enabled ? 'true' : 'false');
        }
      }

      // 切换处理：启用时若存在选中节点立即显示详情；禁用时隐藏面板并阻止后续弹出
      function handleToggleChange(checked) {
        window.__nodeDetailsEnabled = !!checked;
        if (!window.__nodeDetailsEnabled) {
          if (typeof hideNodeDetails === 'function') {
            try { hideNodeDetails(); } catch (e) { /* ignore */ }
          }
        } else {
          // 启用时：若有选中节点，立即显示其详情；否则打开面板并提示“请选择一个节点”
          try {
            var sel = null;
            if (window.jm && typeof window.jm.get_selected_node === 'function') {
              sel = window.jm.get_selected_node();
            }
            if (sel) {
              try { showNodeDetails(sel); } catch (e) { /* ignore */ }
            } else {
              // 无选中节点：打开面板并显示空状态
              try { showEmptyDetailsPrompt(); } catch (e) { /* ignore */ }
            }
          } catch (e) { /* ignore */ }
        }
        updateToggleUI();
      }

      // 挂载事件
      document.addEventListener('DOMContentLoaded', function () {
        // 初始化 UI（无论是否有复选框或按钮）
        updateToggleUI();

        // 复选框（兼容）
        var cb = document.getElementById('toggleNodeDetailsCheckbox');
        if (cb) {
          cb.addEventListener('change', function (e) {
            handleToggleChange(!!e.target.checked);
          }, { passive: true });
          cb.addEventListener('keydown', function (e) {
            if (e.key === ' ' || e.key === 'Enter') {
              setTimeout(function () { handleToggleChange(!!cb.checked); }, 0);
            }
          });
        }

        // 图标按钮（新）
        var btn = document.getElementById('toggleNodeDetailsBtn');
        if (btn) {
          btn.addEventListener('click', function () {
            handleToggleChange(!window.__nodeDetailsEnabled);
          });
          btn.addEventListener('keydown', function (e) {
            if (e.key === 'Enter' || e.key === ' ') {
              e.preventDefault();
              handleToggleChange(!window.__nodeDetailsEnabled);
            }
          });
        }
      });

      // 包装 showNodeDetails：若开关关闭则静默返回
      if (typeof window.showNodeDetails === 'function') {
        var _origShowNodeDetails = window.showNodeDetails;
        window.showNodeDetails = function (node) {
          if (window.__nodeDetailsEnabled === false) return;
          return _origShowNodeDetails.apply(this, arguments);
        };
      } else {
        // 若函数尚未定义，延迟包装（在后续定义时检测）
        var _tryWrap = function () {
          if (typeof window.showNodeDetails === 'function') {
            var _orig = window.showNodeDetails;
            window.showNodeDetails = function (node) {
              if (window.__nodeDetailsEnabled === false) return;
              return _orig.apply(this, arguments);
            };
            clearInterval(_tryWrapInterval);
          }
        };
        var _tryWrapInterval = setInterval(_tryWrap, 200);
      }
    })();


    // --- extracted block from original HTML ---
    (function mw_post_init_fix() {
      try {
        function isMobileNow() {
          var isSmallScreen = (window.matchMedia && window.matchMedia('(max-width: 768px)').matches);
          var hasTouch = ('ontouchstart' in window) || (navigator.maxTouchPoints && navigator.maxTouchPoints > 0);
          return isSmallScreen || (hasTouch && window.innerWidth <= 900);
        }

        function relocateBatchOpsIfNeeded() {
          try {
            var isMobile = isMobileNow();
            var batch = document.getElementById('batchOperations');
            var mw = document.getElementById('mw-batchops');
            if (!batch || !mw) return;
            if (!isMobile) {
              // copy count
              var sc = batch.querySelector('#selectedCount');
              var scVal = sc ? sc.textContent : '0';
              var targetStrong = mw.querySelector('#selectedCountDisplay');
              if (targetStrong) targetStrong.textContent = scVal;
              batch.style.display = 'none';
              mw.style.display = 'inline-flex';
              // keep references
              window.__mw_batch_source = batch;
              window.__mw_batch_target = mw;
            } else {
              batch.style.display = 'none';
              if (mw) mw.style.display = 'none';
            }
          } catch (e) { console.warn('[MW] relocateBatchOpsIfNeeded failed', e); }
        }

        function ensureDetailsToggleVisibleOnDesktop() {
          try {
            var cbDetails = document.getElementById('toggleNodeDetailsCheckbox');
            if (!cbDetails) return;
            var label = cbDetails.parentElement;
            if (!label) return;
            if (!isMobileNow()) {
              label.style.display = ''; // restore default
            }
          } catch (e) { /* ignore */ }
        }

        // sync selected count periodically (small cost, robust)
        function startSelectedCountSync() {
          try {
            var source = document.getElementById('batchOperations');
            var target = document.getElementById('mw-batchops');
            if (!source || !target) return;
            var sSrc = source.querySelector('#selectedCount');
            var sTgt = target.querySelector('#selectedCountDisplay');
            if (!sSrc || !sTgt) return;
            var last = null;
            setInterval(function () {
              try {
                var now = sSrc.textContent || sSrc.innerText || '0';
                if (now !== last) {
                  last = now;
                  sTgt.textContent = now;
                }
              } catch (e) { }
            }, 250);
          } catch (e) { /* ignore */ }
        }

        // run on load and on resize/orientationchange
        function boot() {
          relocateBatchOpsIfNeeded();
          ensureDetailsToggleVisibleOnDesktop();
          startSelectedCountSync();
          // 初始化AI快捷操作按钮可见性
          if (typeof updateAIQuickActionsVisibility === 'function') {
            updateAIQuickActionsVisibility();
          }
        }

        if (document.readyState === 'complete' || document.readyState === 'interactive') {
          setTimeout(boot, 50);
        } else {
          document.addEventListener('DOMContentLoaded', function () { setTimeout(boot, 50); });
          window.addEventListener('load', function () { setTimeout(boot, 50); });
        }
        window.addEventListener('resize', function () { setTimeout(relocateBatchOpsIfNeeded, 60); });
        window.addEventListener('orientationchange', function () { setTimeout(relocateBatchOpsIfNeeded, 60); });
      } catch (e) {
        console.error('[MW] post init fix error', e);
      }
    })();


    // toolbar 图标选择器初始化 —— 更稳健的实现：使用 textContent、等待 availableIcons 与 jm 就绪
    (function () {
      function createToolbarIconGrid() {
        var grid = document.getElementById('iconGridToolbar');
        if (!grid) return;
        grid.innerHTML = '';

        // 首位为清除图标按钮（网格内唯一的清除）
        var clearBtn = document.createElement('button');
        clearBtn.type = 'button';
        clearBtn.className = 'icon-picker-item';
        clearBtn.title = '清除图标';
        clearBtn.style.cssText = 'alpha:0.3;width:40px;height:40px;border:1px dashed #ddd;color:#dbdbdb !important;border-radius:4px;background:#fff;cursor:pointer;font-size:18px;display:flex;align-items:center;justify-content:center;';
        clearBtn.textContent = '🚫';
        clearBtn.onclick = function (e) { e.stopPropagation(); clearIconFromToolbar(); };
        grid.appendChild(clearBtn);

        // 如果 MWIcons.getGroups 可用，按组渲染（带分组标题）
        var groups = (window.MWIcons && typeof window.MWIcons.getGroups === 'function') ? window.MWIcons.getGroups() : null;

        if (groups && Object.keys(groups).length > 0) {
          // 创建分组容器
          Object.keys(groups).forEach(function (groupKey) {
            var group = groups[groupKey];
            // 分组标题
            var header = document.createElement('div');
            header.style.cssText = 'grid-column: 1 / -1; font-size:12px; font-weight:600; color:#333; padding:6px 0 4px 0;';
            header.textContent = (groupKey.charAt(0).toUpperCase() + groupKey.slice(1));
            grid.appendChild(header);

            // 分组图标网格（7列内使用相同样式）
            group.forEach(function (icon) {
              var btn = document.createElement('button');
              btn.type = 'button';
              btn.className = 'icon-picker-item';
              btn.title = icon.name || '';
              btn.style.cssText = 'width:40px;height:40px;border:1px solid #ddd;border-radius:4px;background:white;cursor:pointer;font-size:20px;display:flex;align-items:center;justify-content:center;';
              btn.textContent = icon.emoji || '';
              btn.onclick = function (ev) {
                ev.stopPropagation();
                applyIconToSelection(icon.emoji);
                try { $('#iconPickerDropdown .dropdown-toggle').dropdown('toggle'); } catch (e) { }
              };
              btn.onmouseover = function () { btn.style.background = '#f0f0f0'; };
              btn.onmouseout = function () { btn.style.background = 'white'; };
              grid.appendChild(btn);
            });
          });
          return;
        }

        // 兼容回退：扁平化 window.availableIcons 或全局 availableIcons
        var icons = (window.availableIcons && window.availableIcons.length) ? window.availableIcons
          : (typeof availableIcons !== 'undefined' && availableIcons && availableIcons.length) ? availableIcons
            : [];
        if (!icons || icons.length === 0) {
          // 显示占位提示（用户看到不会空白）
          var ph = document.createElement('div');
          ph.style.cssText = 'grid-column: 1 / -1; color:#6c757d; font-size:12px; padding:6px; text-align:center;';
          ph.textContent = '图标库加载中...';
          grid.appendChild(ph);
          return;
        }

        icons.forEach(function (icon) {
          var btn = document.createElement('button');
          btn.type = 'button';
          btn.className = 'icon-picker-item';
          btn.title = icon.name || '';
          btn.style.cssText = 'width:40px;height:40px;border:1px solid #ddd;border-radius:4px;background:white;cursor:pointer;font-size:20px;display:flex;align-items:center;justify-content:center;';
          btn.textContent = icon.emoji || '';
          btn.onclick = function (ev) {
            ev.stopPropagation();
            applyIconToSelection(icon.emoji);
            // 关闭 dropdown（Bootstrap）
            try { $('#iconPickerDropdown .dropdown-toggle').dropdown('toggle'); } catch (e) { }
          };
          btn.onmouseover = function () { btn.style.background = '#f0f0f0'; };
          btn.onmouseout = function () { btn.style.background = 'white'; };
          grid.appendChild(btn);
        });
      }

      // 安全的初始化：如果 availableIcons 尚未就绪，重复尝试几次
      function initWithRetry(attemptsLeft) {
        try {
          if ((window.availableIcons && window.availableIcons.length > 0) || (typeof availableIcons !== 'undefined' && availableIcons && availableIcons.length > 0) || attemptsLeft <= 0) {
            createToolbarIconGrid();
            return;
          }
        } catch (e) { /* ignore */ }

        setTimeout(function () { initWithRetry(attemptsLeft - 1); }, 120);
      }

      // 将 emoji 应用到当前选中节点（支持多选）
      function applyIconToSelection(emoji) {
        if (!window.jm) {
          console.warn('jm 未初始化，无法应用图标');
          return;
        }

        // 获取多选（框选）或单选
        var ids = [];
        try {
          if (typeof window.getMultiSelection === 'function') {
            ids = window.getMultiSelection() || [];
          }
        } catch (e) { ids = []; }

        // 若无多选，则尝试用 jm.get_selected_node（单选）
        if (!ids || ids.length === 0) {
          try {
            var sel = jm.get_selected_node && jm.get_selected_node();
            if (sel) {
              var selId = (typeof sel === 'string') ? sel : (sel.id || null);
              if (selId) ids = [selId];
            }
          } catch (e) { }
        }

        if (!ids || ids.length === 0) {
          showWarning && showWarning('请先选中 1 个或多个节点');
          return;
        }

        // 对每个节点的 topic 前面插入 emoji（若已存在表情则替换）
        // 使用宽松的 emoji 去除正则（兼容性差时也能工作）
        var emojiStrip = /^[^\w\u4e00-\u9fff\s]+/u;
        ids.forEach(function (id) {
          try {
            var node = jm.get_node(id);
            if (!node) return;
            var topic = node.topic || '';
            // 移除开头的非字母数字与非中文字符（多半是 emoji 或符号）
            topic = topic.replace(emojiStrip, '').trim();
            var newTopic = (emoji ? (emoji + ' ' + topic) : topic);
            jm.update_node(node.id, newTopic);
          } catch (e) {
            console.warn('应用图标失败', e);
          }
        });

        // 保存并提示
        try { if (typeof debouncedSave === 'function') debouncedSave(); } catch (e) { }
        try { showSuccess && showSuccess('已应用图标'); } catch (e) { }
      }

      // 从选中节点清除图标（相当于 applyIconToSelection('')）
      window.clearIconFromToolbar = function () {
        if (!window.jm) return;
        var ids = [];
        try {
          if (typeof window.getMultiSelection === 'function') ids = window.getMultiSelection() || [];
        } catch (e) { ids = []; }
        if (!ids || ids.length === 0) {
          try {
            var sel = jm.get_selected_node && jm.get_selected_node();
            if (sel) {
              var selId = (typeof sel === 'string') ? sel : (sel.id || null);
              if (selId) ids = [selId];
            }
          } catch (e) { }
        }
        if (!ids || ids.length === 0) {
          showWarning && showWarning('请先选中 节点');
          return;
        }

        var emojiStrip = /^[^\w\u4e00-\u9fff\s]+/u;
        ids.forEach(function (id) {
          try {
            var node = jm.get_node(id);
            if (!node) return;
            var topic = node.topic || '';
            topic = topic.replace(emojiStrip, '').trim();
            jm.update_node(node.id, topic);
          } catch (e) { console.warn('清除图标失败', e); }
        });
        try { if (typeof debouncedSave === 'function') debouncedSave(); } catch (e) { }
        try { showSuccess && showSuccess('已清除图标'); } catch (e) { }
      };

      // 初始化入口：最多重试 8 次（每次 120ms）
      if (document.readyState === 'complete' || document.readyState === 'interactive') {
        setTimeout(function () { initWithRetry(8); }, 120);
      } else {
        document.addEventListener('DOMContentLoaded', function () { setTimeout(function () { initWithRetry(8); }, 120); });
      }

      // 在 jm 初始化后再执行一次，防止 race
      window.MW_scheduleOnce && window.MW_scheduleOnce('initToolbarIconGrid', function () {
        initWithRetry(4);
      }, 300);
    })();
  </script>

</body>

</html>
</body>

</html>