<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>思维导图编辑器</title>
  <link rel="stylesheet" href="../styles.css">
  <link type="text/css" rel="stylesheet" href="https://jsd.onmicrosoft.cn/npm/jsmind@0.8.7/style/jsmind.css" />
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/css/bootstrap.min.css" />
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.4/dist/jquery.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/js/bootstrap.bundle.min.js"></script>
  <script type="module">
    // 预加载AI模块
    import { AIExpander } from './ai-expander.js';
    import { AIConfigManager } from './ai-config.js';
    // 将类导出到全局作用域
    window.AIExpander = AIExpander;
    window.AIConfigManager = AIConfigManager;
  </script>
  <style>
    body {
      font-family: 'Consolas', 'Monaco', monospace;
      background: #f5f5f5;
      height: 100vh;
      display: flex;
      flex-direction: column;
    }

    .main-container {
      flex: 1;
      display: flex;
      height: calc(100vh - 60px);
    }

    #fullScreenMindmap {
      width: 70%;
      height: 100%;
      position: relative;
      background: white;
      overflow: auto;
      /* 添加滚动条支持 */
    }

    /* jsmind 节点容器滚动支持 */
    #fullScreenMindmap .jsmind-inner {
      overflow: auto !important;
    }

    /* 确保思维导图节点容器可以滚动 */
    #fullScreenMindmap .jmnodes {
      overflow: visible !important;
    }

    /* 自定义滚动条样式 */
    #fullScreenMindmap::-webkit-scrollbar {
      width: 8px;
      height: 8px;
    }

    #fullScreenMindmap::-webkit-scrollbar-track {
      background: #f1f1f1;
      border-radius: 4px;
    }

    #fullScreenMindmap::-webkit-scrollbar-thumb {
      background: #c1c1c1;
      border-radius: 4px;
    }

    #fullScreenMindmap::-webkit-scrollbar-thumb:hover {
      background: #a8a8a8;
    }

    #nodeDetails {
      width: 30%;
      height: 100%;
      padding: 20px;
      border-left: 1px solid #ddd;
      overflow-y: auto;
      background: #f8f9fa;
    }



    .node-info {
      background: white;
      padding: 15px;
      border-radius: 4px;
      margin-bottom: 15px;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
    }

    .form-group {
      margin-bottom: 15px;
    }

    .form-group label {
      display: block;
      margin-bottom: 5px;
      font-weight: bold;
      color: #495057;
    }

    .form-group input,
    .form-group textarea {
      width: 100%;
      padding: 8px;
      border: 1px solid #ced4da;
      border-radius: 4px;
      font-family: inherit;
    }

    .form-group textarea {
      resize: vertical;
      min-height: 500px;
    }

    .notes-section {
      background: white;
      padding: 15px;
      border-radius: 4px;
      margin-top: 15px;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
    }

    .note-item {
      padding: 10px;
      border-left: 3px solid #007bff;
      background: #f8f9fa;
      margin-bottom: 10px;
      border-radius: 0 4px 4px 0;
    }

    .note-item h5 {
      margin: 0 0 5px 0;
      color: #fad503;
      font-size: 14px;
    }

    .note-item p {
      margin: 0;
      color: #495057;
      font-size: 12px;
      line-height: 1.4;
    }

    /* 自动更新动画 */
    @keyframes pulse {
      0% {
        transform: scale(1);
        opacity: 1;
      }

      50% {
        transform: scale(1.2);
        opacity: 0.7;
      }

      100% {
        transform: scale(1);
        opacity: 1;
      }
    }

    @keyframes fadeIn {
      from {
        opacity: 0;
        transform: translateY(-10px);
      }

      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .auto-update-show {
      animation: fadeIn 0.3s ease-in-out;
    }

    /* 框选矩形与多选高亮 */
    #selectionRect {
      position: fixed;
      border: 1px dashed #4c9aff;
      background: rgba(76, 154, 255, 0.15);
      pointer-events: none;
      display: none;
      z-index: 999;
    }



    /* 多选节点悬停效果 - 已移除，不再使用 */
    /* #fullScreenMindmap .jmnode.multi-selected:hover { background-color: #3a8ce2; box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3); } */

    /* 选中节点的脉冲动画 - 已移除，不再使用 */
    @keyframes pulse-multi {
      /* 动画已禁用，保留空关键帧避免引用错误 */
    }

    /* 单选和多选节点样式统一定义 */
    #fullScreenMindmap .jmnode.selected:not(.multi-selected) {
      background-color: rgb(251, 255, 17);
      color: #fff;
      box-shadow: 2px 2px 8px #000;
    }

    /* 多选节点基础样式 - 已移除，只使用覆盖层样式 */
    /* #fullScreenMindmap .jmnode.multi-selected { background-color: #4c9aff; color: white; border: 4px solid #f8ad0b; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2); } */

    /* 节点文本换行样式 */
    #fullScreenMindmap .jmnode {
      white-space: normal;
      word-break: break-word;
      overflow: visible;
    }

    /* 多选节点展开器样式 - 已移除，不再使用 */
    /* #fullScreenMindmap .jmnode.multi-selected .jmexpander { background-color: #4c9aff; border-color: #ffcf4c; color: #fff; } */

    /* 多选节点内容样式 - 已移除，不再使用 */
    /* #fullScreenMindmap .jmnode.multi-selected * { color: #fff; background-color: rgba(76, 154, 255, 0.15); } */



    /* 编辑输入最小宽度，避免过短导致编辑体验差 */
    .jsmind-editor,
    #jsmind-editor {
      min-width: 100px;
      padding: 2px 6px;
      line-height: 1.4;
      font-size: 14px;
    }

    /* 多选覆盖层样式 - 简洁版 */
    .multi-overlay {
      position: absolute;
      left: -2px;
      top: -2px;
      right: -2px;
      bottom: -2px;
      border: 4px solid #ffd900;
      border-radius: 4px;
      pointer-events: none;
      z-index: 100;
    }

    /* 辅助类 */
    .mw-force-visible {
      display: block;
      visibility: visible;
    }

    /* 内联样式类 - 已移除，不再使用 */
    /* .jmnode.multi-selected-inline { background-color: rgba(76, 154, 255, 0.3); border: 2px solid #4c9aff; box-shadow: 0 0 0 3px rgba(76, 154, 255, 0.8); position: relative; } */
  </style>
</head>

<body>
  <div class="toolbar">
    <!-- 批量操作工具栏 -->
    <div id="batchOperations"
      style="display: inline-block; margin-top: 200px; padding: 5px 10px; background: rgba(76, 154, 255, 0.1); border-radius: 4px; border: 1px solid #4c9aff;">
      <span style="color: #4c9aff; font-size: 12px; margin-right: 10px;">已选中 <span id="selectedCount">0</span>
        个节点</span>
      <button class="btn" onclick="batchDelete()" style="background: #dc3545; margin-right: 5px;"
        title="删除选中的节点">删除</button>
      <button class="btn" onclick="batchMove()" style="background: #28a745; margin-right: 5px;"
        title="移动选中的节点">移动</button>
      <button class="btn" onclick="clearMultiSelection()" style="background: #6c757d; margin-right: 5px;"
        title="清除选择">清除</button>
      <button class="btn" onclick="debugMultiSelect()" style="background: #17a2b8; margin-right: 5px;" title="调试多选样式">🔍
        调试</button>
      <button class="btn" onclick="forceMultiSelectStyle()" style="background: #fd7e14;" title="强制应用多选样式">⚡
        强制样式</button>
    </div>

    <button class="btn" onclick="exportData()">查看JSON</button>
    <button class="btn" onclick="downloadMindmap()">下载图片</button>

  </div>

  <div class="main-container">
    <div id="fullScreenMindmap"></div>

    <div id="nodeDetails">


      <div id="nodeInfo">

      </div>


      <div class="form-group">
        <label for="nodeTopic">节点主题:</label>
        <input type="text" id="nodeTopic" placeholder="输入节点主题...">
      </div>

      <div class="form-group">
        <label for="nodeNotes">节点备注:</label>
        <textarea id="nodeNotes" placeholder="输入节点备注..."></textarea>
      </div>

      <div style="margin-bottom: 15px; display: flex; gap: 10px;">
        <button class="btn" onclick="expandWithAI()"
          style="flex: 1; background: linear-gradient(135deg, #6da8e7, #6adbc8); color: white;">AI扩写</button>
        <button class="btn" onclick="AIExpander.showConfig()" style="flex: 0 0 40px; background: #ffffff;"
          title="AI配置">⚙️</button>
      </div>

      <!-- 自动更新提示 -->
      <div id="autoUpdateIndicator"
        style="display: none; margin-bottom: 10px; padding: 5px 10px; background: #d4edda; border: 1px solid #c3e6cb; border-radius: 4px; color: #155724; font-size: 12px; text-align: center;">
        <span style="display: inline-block; animation: pulse 1s ease-in-out;">✓</span> 已自动更新
      </div>

      <!-- 通知桥接器 -->
      <script src="../notification-bridge.js"></script>
      <script>
        // AI扩写函数
        function expandWithAI() {
          try {
            const selectedNode = jm.get_selected_node();
            if (!selectedNode) {
              showWarning('请先选择一个节点');
              return;
            }

            if (window.AIExpander) {
              window.AIExpander.expandNode(selectedNode.id, jm);
            } else {
              showError('AI扩写模块未加载，请刷新页面重试');
            }
          } catch (e) {
            console.error('AI扩写出错:', e);
            showError('AI扩写出错: ' + e.message);
          }
        }
      </script>
    </div>
  </div>
  </div>

  <script src="https://jsd.onmicrosoft.cn/npm/jsmind@0.8.7/es6/jsmind.js"></script>
  <script src="https://jsd.onmicrosoft.cn/npm/jsmind@0.8.7/es6/jsmind.draggable-node.js"></script>
  <script src="https://unpkg.com/dom-to-image@2.6.0/dist/dom-to-image.min.js"></script>
  <!-- 使用修复版本的截图插件，避免HTTPS安全警告 -->
  <script src="jsmind.screenshot.fixed.js"></script>
  <script type="module" src="../converter/sync.js"></script>
  <script type="module" src="../converter/load.js"></script>
  <script>
    let jm = null;
    let currentNodeTree = null;

    // 初始化思维导图
    function initMindmap() {
      if (jm) {
        loadNodeTree(); // 不传参数，让函数自己从localStorage获取
        return;
      }

      const options = {
        container: 'fullScreenMindmap',           // 容器ID，必填
        editable: true,                         // 是否可编辑，默认为true
        theme: 'primary',                       // 主题：primary|success|info|warning|danger|greensea|nephrite|belizehole|wisteria|asphalt
        mode: 'side',                           // 显示模式：full|side右侧
        support_html: true,                     // 节点是否支持HTML，默认为true
        view: {
          engine: 'svg',                   // 思维导图各节点之间线条的绘制引擎，canvas|svg
          hmargin: 100,                       // 水平边距
          vmargin: 50,                        // 垂直边距
          line_width: 2,                      // 连接线宽度
          line_color: '#555',                 // 连接线颜色
          expander_style: 'circle',           // 展开器样式：number|circle|square


          node_overflow: 'wrap',              // 文字过长处理：hidden|wrap，改为wrap确保多选时内容不被隐藏



        },
        layout: {
          hspace: 30,                         // 节点水平间距
          vspace: 20,                         // 节点垂直间距
          pspace: 13                          // 节点与连接线的间距
        },
        shortcut: {
          enable: true,                         // 是否启用快捷键
          handles: {},                        // 自定义处理函数

          // 快捷键映射
          mapping: {
            addchild: 9,                    // Tab - 添加子节点
            addbrother: 13,                 // Enter - 添加兄弟节点
            editnode: 113,                  // F2 - 编辑节点
            delnode: 46,                    // Delete - 删除节点
            toggle: 32,                     // Space - 展开/折叠节点

            // 切换选中
            left: 37,                       // 选中左侧节点
            up: 38,                         // 
            right: 39,                      // 
            down: 40,                       // 

          }
        },

        // 预设主题配置
        // theme: 'info',  // 使用jsmind内置主题：primary, warning, danger, success, info, orange, etc.

      };

      jm = new jsMind(options);

      // 将jsMind实例赋值给window，供其他模块访问
      window.jm = jm;

      // 配置思维导图容器的滚动行为
      setupMindmapScrolling();

      // 包装核心API以捕获新增/移动节点，做"类型对齐"并保存
      (function wrapMindAPIs() {
        // 新增节点包装
        const __origAdd = jm.add_node && jm.add_node.bind(jm);
        if (__origAdd) {
          jm.add_node = function (parent_node, nodeid, topic, data) {
            const ret = __origAdd(parent_node, nodeid, topic, data);
            try {
              const id = nodeid || (ret && ret.id);
              if (id && typeof applySiblingOrParentType === 'function') {
                applySiblingOrParentType(id);
              }
              // 若父节点为列表，则将自己与子孙全部归一为列表
              try {
                const pid = (typeof parent_node === 'string' ? parent_node : (parent_node && parent_node.id))
                  || (id && jm.get_node(id) && jm.get_node(id).parent && jm.get_node(id).parent.id);
                if (pid) {
                  const p = jm.get_node(pid);
                  if (p && typeof getNodeType === 'function' && getNodeType(p) === 'list') {
                    normalizeSubtreeUnderList(id, p);
                  }
                }
              } catch (e2) {
                // 忽略归一列表处理错误
              }
              if (typeof debouncedSave === 'function') debouncedSave();
            } catch (e) {
              // 忽略后置处理错误
            }
            return ret;
          };
        }
        // 移动节点包装
        const __origMove = jm.move_node && jm.move_node.bind(jm);
        if (__origMove) {
          jm.move_node = function (nodeid, beforeid, parentid, direction) {
            const ret = __origMove(nodeid, beforeid, parentid, direction);
            try {
              if (nodeid && typeof applySiblingOrParentType === 'function') {
                applySiblingOrParentType(nodeid);
              }
              // 若新父节点为列表，则将自己与子孙全部归一为列表
              try {
                if (parentid) {
                  const p = jm.get_node(parentid);
                  if (p && typeof getNodeType === 'function' && getNodeType(p) === 'list') {
                    normalizeSubtreeUnderList(nodeid, p);
                  }
                }
              } catch (e2) {
                // 忽略归一列表处理错误
              }
              if (typeof debouncedSave === 'function') debouncedSave();
            } catch (e) {
              // 忽略后置处理错误
            }
            return ret;
          };
        }
      })();

      // 初始化完成后加载数据
      loadNodeTree();

      // 绑定事件
      jm.add_event_listener(function (type, data) {
        if (type === jsMind.event_type.select) {
          const selectedNodeid = jm.get_selected_node();
          if (selectedNodeid) {
            // 检查是否处于批量移动模式
            if (window.__batchMoving && window.__batchMoveIds && window.__batchMoveIds.length > 0) {
              // 批量移动模式：执行移动操作
              try {
                const targetNodeId = selectedNodeid;
                const idsToMove = [...window.__batchMoveIds];

                // 取消批量移动模式
                if (window.cancelBatchMove) {
                  window.cancelBatchMove();
                }

                // 执行批量移动
                let anchorId = targetNodeId;
                for (const nodeId of idsToMove) {
                  if (!nodeId || nodeId === targetNodeId) continue;
                  try {
                    jm.move_node(nodeId, anchorId, jm.get_node(targetNodeId).parent.id);
                    anchorId = nodeId;
                  } catch (e) {
                    console.warn('节点移动失败:', nodeId, e);
                  }
                }

                showSuccess(`成功移动 ${idsToMove.length} 个节点`);
              } catch (e) {
                console.error('批量移动失败:', e);
                showError('批量移动失败');
              }
            } else {
              // 正常模式：显示节点详情
              showNodeDetails(selectedNodeid);
            }
          }
        }
      });

    }

    // 配置思维导图容器的滚动行为
    function setupMindmapScrolling() {
      if (!jm) return;

      const container = document.getElementById('fullScreenMindmap');
      if (!container) return;

      // 等待jsmind完全初始化
      setTimeout(() => {
        // 查找jsmind创建的jmnodes容器
        const jmnodes = container.querySelector('.jmnodes');
        const jsmindInner = container.querySelector('.jsmind-inner');

        if (jmnodes) {
          // 确保jmnodes可以超出容器边界
          jmnodes.style.overflow = 'visible';
          jmnodes.style.position = 'relative';
        }

        if (jsmindInner) {
          // 确保内部容器有滚动条
          jsmindInner.style.overflow = 'auto';
          jsmindInner.style.width = '100%';
          jsmindInner.style.height = '100%';
        }

        // 已移除冗余滚动调试输出
      }, 500); // 延迟500ms确保jsmind完成DOM创建
    }

    // 加载NodeTree数据
    function loadNodeTree(nodeTreeData) {
      if (!jm) return;

      // 如果没有提供数据，尝试从localStorage获取
      if (!nodeTreeData) {
        const cachedData = localStorage.getItem('mindword_nodetree_data');
        if (cachedData) {
          try {
            nodeTreeData = JSON.parse(cachedData);
          } catch (error) {
            nodeTreeData = getDefaultNodeTree();
          }
        } else {
          nodeTreeData = getDefaultNodeTree();
        }
      }

      try {
        // 确保数据格式正确
        if (typeof nodeTreeData === 'string') {
          nodeTreeData = JSON.parse(nodeTreeData);
        }

        jm.show(nodeTreeData);
        currentNodeTree = nodeTreeData;

        // 延迟执行DOM操作，确保元素已加载
        setTimeout(() => {


          // 自动选择根节点并显示详情
          const rootNode = jm.get_root();
          if (rootNode) {
            jm.select_node(rootNode.id);
            showNodeDetails(rootNode);
          }
        }, 100);
      } catch (error) {
        // 如果加载失败，尝试加载默认数据
        try {
          jm.show(getDefaultNodeTree());
        } catch (defaultError) {
          console.error('加载默认数据失败:', defaultError);
        }
      }
    }

    // 获取当前NodeTree
    function getCurrentNodeTree() {
      return jm ? jm.get_data() : null;
    }

    // 显示节点详情
    function showNodeDetails(node) {
      // 允许传入 id 或 node 对象，统一为 node
      if (node && typeof node === 'string') {
        node = jm && jm.get_node ? jm.get_node(node) : node;
      }
      if (!node) return;

      const nodeInfo = document.getElementById('nodeInfo');
      const nodeTopic = document.getElementById('nodeTopic');
      const nodeNotes = document.getElementById('nodeNotes');
      if (!nodeInfo || !nodeTopic || !nodeNotes) return;

      // 安全字段读取
      const level = (node.level != null) ? node.level
        : (node.data && node.data.level != null ? node.data.level : 0);
      const ordered = (node.ordered != null) ? node.ordered
        : (node.data && node.data.ordered != null ? node.data.ordered : undefined);
      const marker = (node.marker != null) ? node.marker
        : (node.data && node.data.marker != null ? node.data.marker : undefined);
      const type = (node.type != null) ? node.type
        : (node.data && node.data.type != null ? node.data.type : undefined);
      const notes = (node.notes != null) ? node.notes
        : (node.data && node.data.notes != null ? node.data.notes : '');

      // 构造调试快照（避免循环引用）
      const snapshot = {
        id: node.id,
        topic: node.topic || '',
        type: type,
        level: level,
        ordered: ordered,
        marker: marker,
        notes: notes,
        parentId: node.parent && node.parent.id ? node.parent.id : null,
        childrenIds: Array.isArray(node.children) ? node.children.map(c => c && c.id).filter(Boolean) : []
      };


      nodeTopic.value = snapshot.topic || '';
      nodeNotes.value = notes || '';

      // 设置自动更新事件监听
      setupAutoUpdate();
    }

    // 设置自动更新功能
    function setupAutoUpdate() {
      const nodeTopic = document.getElementById('nodeTopic');
      const nodeNotes = document.getElementById('nodeNotes');

      if (!nodeTopic || !nodeNotes) return;

      // 移除之前的事件监听避免重复
      nodeTopic.removeEventListener('input', handleAutoUpdate);
      nodeNotes.removeEventListener('input', handleAutoUpdate);

      // 添加新的事件监听
      nodeTopic.addEventListener('input', handleAutoUpdate);
      nodeNotes.addEventListener('input', handleAutoUpdate);
    }

    // 处理自动更新
    let autoUpdateTimer = null;
    function handleAutoUpdate() {
      // 清除之前的定时器
      if (autoUpdateTimer) {
        clearTimeout(autoUpdateTimer);
      }

      // 延迟500ms执行更新，避免频繁更新
      autoUpdateTimer = setTimeout(() => {
        const selected = jm.get_selected_node();
        if (!selected) return;

        const nodeTopic = document.getElementById('nodeTopic');
        const nodeNotes = document.getElementById('nodeNotes');

        const newTopic = nodeTopic.value.trim();
        const newNotes = nodeNotes.value.trim();

        // 检查是否有变化
        let hasChanges = false;

        if (newTopic !== selected.topic) {
          jm.update_node(selected.id, newTopic);
          hasChanges = true;
        }

        // 确保 data 存在，避免空引用
        if (!selected.data) selected.data = {};
        const prevNotes = (selected.notes != null ? selected.notes : (selected.data.notes != null ? selected.data.notes : ''));
        if (newNotes !== prevNotes) {
          selected.data.notes = newNotes;
          hasChanges = true;
        }

        if (hasChanges) {
          refreshAllNotesDisplay();
          saveToLocalStorage();
          showAutoUpdateIndicator();
        }
      }, 500);
    }

    // 显示自动更新提示
    function showAutoUpdateIndicator() {
      const indicator = document.getElementById('autoUpdateIndicator');
      if (!indicator) return;

      indicator.style.display = 'block';
      indicator.classList.add('auto-update-show');

      // 2秒后隐藏提示
      setTimeout(() => {
        indicator.style.display = 'none';
        indicator.classList.remove('auto-update-show');
      }, 2000);
    }

    // 更新节点备注
    function updateNodeNotes() {
      if (!jm) return;

      const selected = jm.get_selected_node();
      if (!selected) {
        showWarning('请先选择一个节点');
        return;
      }

      const nodeTopic = document.getElementById('nodeTopic');
      const nodeNotes = document.getElementById('nodeNotes');

      const newTopic = nodeTopic.value.trim();
      const newNotes = nodeNotes.value.trim();

      // 检查是否有任何变化需要更新
      let hasChanges = false;

      // 更新节点主题（如果有变化）
      if (newTopic !== selected.topic) {
        jm.update_node(selected.id, newTopic);
        hasChanges = true;
      }

      // 更新节点备注（如果有变化）
      if (newNotes !== (selected.notes || '')) {
        // 直接更新根级别的notes字段（与其他代码保持一致）
        selected.data.notes = newNotes;
        hasChanges = true;
      }

      // 如果没有变化，提示用户
      if (!hasChanges) {
        showInfo('节点内容没有变化！');
        return;
      }

      refreshAllNotesDisplay();

      // // 同步到父页面
      // if (window.parent !== window) {
      //     window.parent.postMessage({
      //         type: 'mindmapUpdated',
      //         data: jm.get_data()
      //     }, '*');
      // }

      // 保存到localStorage并同步
      saveToLocalStorage();

      showSuccess('节点更新成功！');
    }

    // 刷新所有备注显示
    function refreshAllNotesDisplay() {
      if (!jm) return;

      const notesList = document.getElementById('notesList');
      if (!notesList) return; // 防止DOM元素不存在

      const nodeTree = jm.get_data();

      if (!nodeTree || !nodeTree.data) {
        notesList.innerHTML = '<p style="color: #6c757d;">暂无节点数据</p>';
        return;
      }

      const nodesWithNotes = [];

      function collectNodes(node) {
        if (!node) return;

        const notes = node.notes;  // 直接从根级别读取notes
        if (notes && notes.trim()) {
          nodesWithNotes.push({
            id: node.id,
            topic: node.topic || '未命名节点',
            notes: notes.trim(),
            level: node.level || 0
          });
        }

        if (node.children) {
          node.children.forEach(collectNodes);
        }
      }

      collectNodes(nodeTree.data);

      if (nodesWithNotes.length === 0) {
        notesList.innerHTML = '<p style="color: #6c757d;">暂无节点包含备注信息</p>';
        return;
      }

      nodesWithNotes.sort((a, b) => a.level - b.level);

      let html = '';
      nodesWithNotes.forEach(node => {
        const levelIndent = '　'.repeat(node.level);
        html += `
                    <div class="note-item">
                        <h5>${levelIndent}${node.topic}</h5>
                        <p>${node.notes}</p>
                        <small style="color: #6c757d;">ID: ${node.id}</small>
                    </div>
                `;
      });

      notesList.innerHTML = html;
    }

    // 设置鼠标悬停显示备注
    function setupHoverNotes() {
      const container = document.getElementById('fullScreenMindmap');
      const notesOverlay = document.getElementById('notesOverlay');
      const hoverNote = document.getElementById('hoverNote');

      let hoverTimeout;

      container.addEventListener('mousemove', function (e) {
        if (!jm) return;

        const rect = container.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;

        let node = null;
        try {
          if (jm.get_node_by_coordinate) {
            node = jm.get_node_by_coordinate(x, y);
          } else {
            const target = e.target;
            if (target && target.closest('.jmnode')) {
              const nodeId = target.closest('.jmnode').getAttribute('nodeid');
              if (nodeId) {
                node = jm.get_node(nodeId);
              }
            }
          }
        } catch (error) {
          // 静默处理错误
        }

        if (node && node.notes && node.notes.trim()) {
          clearTimeout(hoverTimeout);
          hoverTimeout = setTimeout(() => {
            hoverNote.textContent = node.notes;
            notesOverlay.style.display = 'block';
            notesOverlay.style.left = Math.min(x + 10, rect.width - 260) + 'px';
            notesOverlay.style.top = Math.max(y - 50, 10) + 'px';
          }, 300);
        } else {
          clearTimeout(hoverTimeout);
          hoverTimeout = setTimeout(() => {
            notesOverlay.style.display = 'none';
          }, 100);
        }
      });

      container.addEventListener('mouseleave', function () {
        clearTimeout(hoverTimeout);
        notesOverlay.style.display = 'none';
      });
    }



    /* 画布框选多选功能 */
    function setupBoxSelection() {
      const container = document.getElementById('fullScreenMindmap');
      if (!container) return;

      // 在 jsmind 内部容器内绘制框选矩形，确保坐标与滚动一致
      const inner = container.querySelector('.jsmind-inner') || container;
      // 使容器可聚焦，确保在 iframe 中可接收空格键
      inner.setAttribute('tabindex', '0');
      inner.style.outline = 'none';
      inner.addEventListener('mouseenter', () => { try { inner.focus({ preventScroll: true }); } catch (e) { } });
      inner.addEventListener('mousedown', () => { try { inner.focus({ preventScroll: true }); } catch (e) { } });
      // 节点容器（jsMind 会把节点放在 .jmnodes 下）
      const nodesRoot = container.querySelector('.jmnodes') || inner;

      // 已移除冗余节点分析日志

      // 创建框选矩形元素（若不存在） - 使用视口坐标系，挂到 document.body 避免被缩放层影响
      let rectEl = document.querySelector('#selectionRect');
      if (!rectEl) {
        rectEl = document.createElement('div');
        rectEl.id = 'selectionRect';
        document.body.appendChild(rectEl);
      }

      let isSelecting = false;
      let isSelectingPrimed = false;
      let isPanning = false;
      let isDownOnNode = false;
      let isDraggingNode = false; // 记录是否正在拖拽节点
      let startX = 0, startY = 0;
      let startClientX = 0, startClientY = 0;
      let startScrollLeft = 0, startScrollTop = 0;
      let addMode = false; // 是否叠加选择（Shift/Meta），空格为画布拖拽
      let isSpacePressed = false; // 空格按下时启用画布拖拽

      // 计算内层容器的缩放比例（CSS transform: scale），用于坐标换算
      function getInnerScale() {
        const r = inner.getBoundingClientRect();
        const sxRaw = r.width / (inner.clientWidth || r.width);
        const syRaw = r.height / (inner.clientHeight || r.height);
        const sx = (isFinite(sxRaw) && sxRaw > 0) ? sxRaw : 1;
        const sy = (isFinite(syRaw) && syRaw > 0) ? syRaw : 1;
        return { sx, sy };
      }

      // 监听空格键状态；在输入框/文本域/可编辑内容内按空格不触发拖拽
      window.addEventListener('keydown', (e) => {
        if (e.code === 'Space' || e.key === ' ' || e.key === 'Spacebar') {
          const t = e.target;
          const isTyping = t && (
            t.tagName === 'INPUT' ||
            t.tagName === 'TEXTAREA' ||
            t.isContentEditable
          );
          if (!isTyping) {
            isSpacePressed = true;
            // 阻止页面滚动（空格默认会滚动页面）
            e.preventDefault();
          }
        }
      }, { passive: false });

      window.addEventListener('keyup', (e) => {
        if (e.code === 'Space' || e.key === ' ' || e.key === 'Spacebar') {
          isSpacePressed = false;
        }
      });
      const multiSelected = new Set();

      // 去重和节流控制变量
      let lastMultiSelectedIds = [];
      let isUpdatingHighlight = false;
      let highlightUpdateScheduled = false;

      function updateHighlight() {
        // 去重：检查多选集合是否真正发生变化
        const currentIds = Array.from(multiSelected).sort();
        const hasChanged = JSON.stringify(currentIds) !== JSON.stringify(lastMultiSelectedIds);

        if (!hasChanged && !highlightUpdateScheduled) {
          console.log('⏭️ 多选集合未变化，跳过更新');
          return;
        }

        // 节流：如果正在更新，标记需要再次更新，但不立即执行
        if (isUpdatingHighlight) {
          console.log('⏳ 更新进行中，标记需要再次更新');
          highlightUpdateScheduled = true;
          return;
        }

        // 使用 requestAnimationFrame 进行节流
        isUpdatingHighlight = true;
        requestAnimationFrame(() => {
          performHighlightUpdate();
          lastMultiSelectedIds = currentIds.slice(); // 保存当前状态
          isUpdatingHighlight = false;

          // 如果有排队的更新，执行它
          if (highlightUpdateScheduled) {
            highlightUpdateScheduled = false;
            console.log('🔄 执行排队的更新');
            updateHighlight();
          }
        });
      }

      function performHighlightUpdate() {
        console.log(`🎯 执行高亮更新，选中节点数: ${multiSelected.size}`);

        // 清理高亮：仅移除节点矩形上的多选类，并移除覆盖层
        const prevMulti = document.querySelectorAll('.jmnode.multi-selected');
        let clearCount = 0;
        prevMulti.forEach(el => {
          el.classList.remove('multi-selected');
          clearCount++;
        });
        // 额外：移除所有多选覆盖层，避免残留
        document.querySelectorAll('.multi-overlay').forEach(ov => ov.remove());

        // 应用高亮
        multiSelected.forEach(id => {
          const el = getNodeElement(id);
          if (el) {
            applyMultiSelectStyle(el, id);
          }
        });

        // 更新批量操作工具栏
        updateBatchToolbar();

        // 暴露便捷 API
        exposeMultiSelectAPI();
      }

      // 获取节点元素的辅助函数
      function getNodeElement(nodeId) {
        let el = document.querySelector(`jmnode[nodeid="${nodeId}"]`) ||
          document.querySelector(`.jmnode[nodeid="${nodeId}"]`) ||
          document.querySelector(`[nodeid="${nodeId}"]`);

        if (el && el.tagName !== 'Jmnode' && !el.classList.contains('jmnode')) {
          el = el.closest('jmnode') || el.closest('.jmnode') || el;
        }
        return el;
      }

      // 应用多选样式的核心函数
      function applyMultiSelectStyle(el, nodeId) {
        el.classList.add('multi-selected');

        // 创建覆盖层 - 确保高亮不被内部子层遮挡
        if (!el.querySelector(':scope > .multi-overlay')) {
          const ov = document.createElement('div');
          ov.className = 'multi-overlay';
          el.appendChild(ov);
        }

        // **关键修复**：确保节点元素本身可见，即使其内部的jmexpander被隐藏
        const computedStyle = window.getComputedStyle(el);
        if (computedStyle.display === 'none' || computedStyle.visibility === 'hidden') {
          el.classList.add('mw-force-visible');
        }
      }

      // 更新批量操作工具栏
      function updateBatchToolbar() {
        const batchOps = document.getElementById('batchOperations');
        const selectedCount = document.getElementById('selectedCount');
        const count = multiSelected.size;

        if (count > 0) {
          batchOps.style.display = 'inline-block';
          selectedCount.textContent = count;
        } else {
          batchOps.style.display = 'none';
        }
      }

      // 暴露便捷 API
      function exposeMultiSelectAPI() {
        window.getMultiSelection = () => Array.from(multiSelected);
        window.clearMultiSelection = () => {
          multiSelected.clear();
          if (window.jm && typeof jm.select_clear === 'function') {
            try { jm.select_clear(); } catch (err) { }
          }
          updateHighlight();
        };
        window.selectMultipleNodes = (ids) => {
          if (!Array.isArray(ids)) return;
          ids.forEach(id => id && multiSelected.add(id));
          updateHighlight();
        };
      }

      // 简化的调试函数
      window.debugMultiSelect = function () {
        console.log('多选集合大小:', multiSelected.size);
        console.log('多选节点ID:', Array.from(multiSelected));
      };

      // 强制重置样式函数
      window.forceMultiSelectStyle = function () {
        multiSelected.forEach(id => {
          const el = getNodeElement(id);
          if (el) {
            // 强制移除可能冲突的内联样式
            el.style.background = '';
            el.style.backgroundColor = '';
            el.style.backgroundImage = '';

            // 应用多选样式（复用核心逻辑）
            applyMultiSelectStyle(el, id);

            // **关键修复**：确保节点元素本身可见，即使其内部的jmexpander被隐藏
            const computedStyle = window.getComputedStyle(el);
            if (computedStyle.display === 'none' || computedStyle.visibility === 'hidden') {
              el.style.display = 'block !important';
              el.style.visibility = 'visible !important';
            }
          }
        });
      };

      function rectsIntersect(a, b) {
        return a.left <= b.right && a.right >= b.left && a.top <= b.bottom && a.bottom >= b.top;
      }

      function onMouseDown(e) {
        if (e.button !== 0) return; // 仅左键
        // 若正在编辑或点击到编辑输入，忽略本模块，交给 jsMind 处理
        const tt = e.target;
        if (tt && (tt.tagName === 'INPUT' || tt.tagName === 'TEXTAREA' || tt.isContentEditable || tt.id === 'jsmind-editor' || (tt.closest && (tt.closest('.jsmind-editor') || tt.closest('#jsmind-editor'))))) {
          return;
        }
        // 避免在节点/右侧面板/工具栏上触发框选/拖拽

        // 简化节点检测 - 直接检查目标元素及其父元素
        let nodeElement = null;
        const target = e.target;

        // 方法1: 检查目标元素本身是否有.jmnode类
        if (target.classList && target.classList.contains('jmnode')) {
          nodeElement = target;
        }
        // 方法2: 检查目标元素是否有nodeid属性
        else if (target.hasAttribute && target.hasAttribute('nodeid')) {
          nodeElement = target;
        }
        // 方法3: 检查父元素
        else if (target.closest) {
          nodeElement = target.closest('.jmnode');
          if (!nodeElement) {
            nodeElement = target.closest('[nodeid]');
          }
        }

        isDownOnNode = !!nodeElement;

        // 后备方案：检查鼠标位置是否在节点区域内
        if (!isDownOnNode) {
          const allNodes = document.querySelectorAll('[nodeid]');

          for (let i = 0; i < allNodes.length; i++) {
            const node = allNodes[i];
            const rect = node.getBoundingClientRect();
            const mouseX = e.clientX;
            const mouseY = e.clientY;

            if (mouseX >= rect.left && mouseX <= rect.right && mouseY >= rect.top && mouseY <= rect.bottom) {
              isDownOnNode = true;
              break;
            }
          }
        }

        // 如果点击在空白区域（非节点、非工具栏、非批量操作面板），清除选择
        if (!isDownOnNode && !e.target.closest('#toolbar') && !e.target.closest('#batchOperations')) {
          multiSelected.clear();
          if (window.jm && typeof jm.select_clear === 'function') { try { jm.select_clear(); } catch (err) { } }
          updateHighlight();
        }

        if (isDownOnNode) {
          // 在节点上按下，标记为拖拽状态，禁用框选
          isDraggingNode = true;
          isSelecting = false;
          isSelectingPrimed = false;
          rectEl.style.display = 'none';


          // 如果按住Shift键点击节点，切换选择状态
          if (e.shiftKey || e.metaKey) {
            const clickedNode = e.target.closest('.jmnode');
            if (clickedNode) {
              const nodeId = clickedNode.getAttribute('nodeid');
              if (nodeId) {
                if (multiSelected.has(nodeId)) {
                  multiSelected.delete(nodeId);
                } else {
                  multiSelected.add(nodeId);
                }
                updateHighlight();
                e.preventDefault();
                return;
              }
            }
          }

          // **关键修复**：如果当前节点在多选集合中，阻止jsMind的拖拽插件处理
          // 避免多选节点拖拽时出现 "Cannot read properties of null (reading 'tagName')" 错误
          const clickedNode = e.target.closest('.jmnode');
          if (clickedNode) {
            const nodeId = clickedNode.getAttribute('nodeid');
            if (nodeId && multiSelected.has(nodeId) && multiSelected.size > 1) {
              // 多选节点被点击，阻止jsMind拖拽插件的默认行为
              e.preventDefault();
              e.stopPropagation();
              console.log('阻止jsMind拖拽插件处理多选节点');
              return;
            }
          }

          // 单个节点时，不阻止事件冒泡，让jsMind处理拖拽
          return;
        }

        if (e.target.closest('#nodeDetails') || e.target.closest('.toolbar')) {
          // 在面板/工具栏上按下，禁止框选
          isSelecting = false;
          isSelectingPrimed = false;
          rectEl.style.display = 'none';

          // **不阻止事件冒泡**，让其他功能正常工作
          return;
        }

        // 空格 + 拖拽 => 画布平移
        if (isSpacePressed) {
          isPanning = true;
          const r = inner.getBoundingClientRect();
          startClientX = e.clientX;
          startClientY = e.clientY;
          startScrollLeft = inner.scrollLeft;
          startScrollTop = inner.scrollTop;
          inner.style.cursor = 'grabbing';
          e.preventDefault();
          return;
        }

        // 普通拖拽 => 待判定框选（仅当移动超阈值才真正开始）
        isSelecting = false;
        isSelectingPrimed = true;
        addMode = !!(e.shiftKey || e.metaKey);

        // 记录起点的视口(client)坐标，后续全部以 client 坐标系绘制，避免缩放/滚动换算误差
        startClientX = e.clientX;
        startClientY = e.clientY;
        // 兼容性保留逻辑坐标（但不用于碰撞检测）
        startX = startClientX;
        startY = startClientY;

        // 暂不清空，等真正开始框选时再决定是否清空
        Object.assign(rectEl.style, {
          display: 'none',
          left: `${startClientX}px`,
          top: `${startClientY}px`,
          width: '0px',
          height: '0px'
        });

        // 阻止默认选择行为，避免文字选中
        e.preventDefault();
      }

      function onMouseMove(e) {
        // 编辑输入命中时不参与框选/拖拽判定
        const tmm = e.target;
        if (tmm && ((tmm.id === 'jsmind-editor') || (tmm.closest && (tmm.closest('.jsmind-editor') || tmm.closest('#jsmind-editor'))) || tmm.tagName === 'INPUT' || tmm.tagName === 'TEXTAREA' || tmm.isContentEditable)) {
          return;
        }
        // 画布平移模式
        if (isPanning) {
          const dx = e.clientX - startClientX;
          const dy = e.clientY - startClientY;
          inner.scrollLeft = startScrollLeft - dx;
          inner.scrollTop = startScrollTop - dy;
          e.preventDefault();
          return;
        }

        // 如果正在拖拽节点，完全跳过框选逻辑
        if (isDownOnNode || isDraggingNode) {
          // 隐藏框选矩形，但**不阻止**jsMind的事件处理
          rectEl.style.display = 'none';

          // **新增**：多选节点拖拽时的视觉反馈
          if (isDraggingNode && multiSelected.size > 1) {
            // 为多选节点添加拖拽时的特殊样式
            multiSelected.forEach(nodeId => {
              const nodeEl = document.querySelector(`[nodeid="${nodeId}"]`);
              if (nodeEl) {
                nodeEl.style.opacity = '0.8';
                nodeEl.style.transform = 'scale(1.1)';
                nodeEl.style.transition = 'all 0.1s ease';
              }
            });
          }

          return;
        }

        // 智能拖拽检测：如果鼠标按下时未检测到节点，但移动时检测到在节点上，则认为是拖拽
        if (!isDownOnNode && !isDraggingNode && isSelectingPrimed) {
          const hoveredNode = document.elementFromPoint(e.clientX, e.clientY);
          if (hoveredNode && (hoveredNode.classList.contains('jmnode') || hoveredNode.closest('.jmnode'))) {
            isDraggingNode = true;
            isSelecting = false;
            isSelectingPrimed = false;
            rectEl.style.display = 'none';
            return;
          }
        }

        if (!isSelecting && !isSelectingPrimed) return;

        // 使用视口(client)坐标系绘制选框，避免 transform/scroll 换算误差
        const curClientX = e.clientX;
        const curClientY = e.clientY;

        const x = Math.min(startClientX, curClientX);
        const y = Math.min(startClientY, curClientY);
        const w = Math.abs(curClientX - startClientX);
        const h = Math.abs(curClientY - startClientY);

        // 移动超过阈值(>4px)才真正开始框选
        if (isSelectingPrimed && !isSelecting) {
          if (w > 4 || h > 4) {
            isSelecting = true;
            isSelectingPrimed = false;
            if (!addMode) multiSelected.clear();
            rectEl.style.display = 'block';
          } else {
            return;
          }
        }

        // 修复：直接使用逻辑坐标，因为inner容器已经应用了transform scale
        // selectionRect作为inner的子元素，会自动继承缩放效果

        // 边界检查：确保矩形不会超出inner容器的逻辑边界
        const maxX = inner.scrollWidth;
        const maxY = inner.scrollHeight;
        const clampedX = Math.max(0, Math.min(x, maxX));
        const clampedY = Math.max(0, Math.min(y, maxY));
        const clampedW = Math.min(w, maxX - clampedX);
        const clampedH = Math.min(h, maxY - clampedY);

        Object.assign(rectEl.style, {
          left: `${clampedX}px`,
          top: `${clampedY}px`,
          width: `${clampedW}px`,
          height: `${clampedH}px`
        });

        // 选框与节点均使用 client(getBoundingClientRect) 坐标系进行相交检测（直接使用视口坐标）
        const selClient = {
          left: x,
          top: y,
          right: x + w,
          bottom: y + h
        };



        // 节点查询
        let nodeElements = [];
        const allNodeElements = document.querySelectorAll('[nodeid]');

        if (allNodeElements.length > 0) {
          nodeElements = Array.from(allNodeElements);
        } else {
          if (nodesRoot) {
            nodeElements = Array.from(nodesRoot.querySelectorAll('.jmnode'));
          }

          if (nodeElements.length === 0) {
            nodeElements = Array.from(document.querySelectorAll('.jmnode'));
          }
        }

        let intersectedCount = 0;
        nodeElements.forEach(el => {
          const nb = el.getBoundingClientRect();
          const intersects = rectsIntersect(selClient, {
            left: nb.left, top: nb.top, right: nb.right, bottom: nb.bottom
          });
          const id = el.getAttribute('nodeid');
          if (!id) return;

          if (intersects) {
            multiSelected.add(id);
            intersectedCount++;
          } else if (!addMode) {
            // 替换模式时，实时移除未命中的节点
            multiSelected.delete(id);
          }
        });

        // 已移除框选统计日志

        updateHighlight();
      }

      function onMouseUp() {
        // 结束画布平移
        if (isPanning) {
          isPanning = false;
          inner.style.cursor = '';
          return;
        }

        // 若处于预备状态但未超过阈值，则取消
        if (isSelectingPrimed && !isSelecting) {
          isSelectingPrimed = false;
          return;
        }

        // 若本次拖拽起点在节点上或正在拖拽节点，则不进行框选
        if (isDownOnNode || isDraggingNode) {
          // **新增**：多选节点拖拽结束时的样式恢复
          if (isDraggingNode && multiSelected.size > 1) {
            // 恢复多选节点的原始样式
            multiSelected.forEach(nodeId => {
              const nodeEl = document.querySelector(`[nodeid="${nodeId}"]`);
              if (nodeEl) {
                nodeEl.style.opacity = '';
                nodeEl.style.transform = '';
                nodeEl.style.transition = '';
              }
            });
          }

          isDownOnNode = false;
          isDraggingNode = false;
          isSelecting = false;
          isSelectingPrimed = false;
          rectEl.style.display = 'none';
          return;
        }

        if (!isSelecting) return;

        isSelecting = false;
        rectEl.style.display = 'none';
        updateHighlight();
      }

      // 绑定事件到 inner，这样滚动与坐标系一致
      // **不使用捕获阶段**，避免干扰jsMind的事件处理
      inner.addEventListener('mousedown', onMouseDown);
      inner.addEventListener('mousemove', onMouseMove);
      // mouseup 绑定到 window，避免在快速拖动出容器时丢事件
      window.addEventListener('mouseup', onMouseUp);
      // 在编辑输入上阻止事件传播，避免拖拽/框选/双击干扰（捕获阶段，保留默认以保证光标定位）
      const isEditTarget = (t) => !!(t && ((t.id === 'jsmind-editor') || (t.closest && (t.closest('.jsmind-editor') || t.closest('#jsmind-editor'))) || t.tagName === 'INPUT' || t.tagName === 'TEXTAREA' || t.isContentEditable));
      ['mousedown', 'mousemove', 'click', 'dblclick'].forEach(ev => {
        document.addEventListener(ev, function (e) {
          const t = e.target;
          if (isEditTarget(t)) {
            e.stopImmediatePropagation();
            e.stopPropagation();
            // 不要 preventDefault，确保光标与选择正常
          }
        }, true);
      });

      // 添加双击事件监听，用于切换节点选择状态（编辑态下不处理，避免冲突）
      inner.addEventListener('dblclick', function (e) {
        if (document.querySelector('.jsmind-editor') || document.querySelector('#jsmind-editor') || (e.target && (e.target.tagName === 'INPUT' || e.target.isContentEditable || (e.target.closest && (e.target.closest('.jsmind-editor') || e.target.closest('#jsmind-editor')))))) {
          return;
        }
        const clickedNode = e.target.closest('.jmnode');
        if (clickedNode) {
          const nodeId = clickedNode.getAttribute('nodeid');
          if (nodeId) {
            if (multiSelected.has(nodeId)) {
              multiSelected.delete(nodeId);
            } else {
              multiSelected.add(nodeId);
            }
            updateHighlight();
            e.preventDefault();
          }
        }
      });

      // 使用jsMind原生事件系统检测拖拽
      if (window.jsMind && jm) {
        // 监听所有jsMind事件
        jm.add_event_listener(function (type, data) {
          // 拖拽开始事件
          if (type === jsMind.event_type.move_node) {
            if (data && data.data && Array.isArray(data.data) && data.data.length >= 3) {
              isDraggingNode = true;
              isSelecting = false;
              isSelectingPrimed = false;
              rectEl.style.display = 'none';
            }
          }

          // 监听节点选择变化（可能表示拖拽结束）
          if (type === jsMind.event_type.select_node || type === jsMind.event_type.select_clear) {
            if (isDraggingNode) {
              setTimeout(() => {
                isDraggingNode = false;
              }, 100);
            }
          }
        });
      } else {
        // 备用拖拽检测机制
        let dragStartTimer = null;

        // 监听mousedown事件，检测是否在节点上
        inner.addEventListener('mousedown', function (e) {
          if (e.target && e.target.closest && e.target.closest('.jmnode')) {
            // 延迟设置拖拽状态，避免误触发
            dragStartTimer = setTimeout(() => {
              isDraggingNode = true;
              isSelecting = false;
              isSelectingPrimed = false;
              rectEl.style.display = 'none';
            }, 100); // 100ms延迟
          }
        }, true);

        // 监听mouseup事件，重置拖拽状态
        window.addEventListener('mouseup', function () {
          if (dragStartTimer) {
            clearTimeout(dragStartTimer);
            dragStartTimer = null;
          }
          if (isDraggingNode) {
            isDraggingNode = false;
          }
        });

        // 监听mousemove事件，如果在节点上移动且按下了鼠标，认为是拖拽
        inner.addEventListener('mousemove', function (e) {
          if (e.buttons === 1 && e.target && e.target.closest && e.target.closest('.jmnode')) {
            if (!isDraggingNode) {
              isDraggingNode = true;
              isSelecting = false;
              isSelectingPrimed = false;
              rectEl.style.display = 'none';
            }
          }
        }, true);
      }

      // 批量删除（Delete/Backspace）已多选的节点（捕获阶段优先于内置删除）
      document.addEventListener('keydown', (e) => {
        const key = e.key || '';
        if ((key === 'Delete' || key === 'Backspace') && typeof window.getMultiSelection === 'function') {
          const ids = window.getMultiSelection();
          if (Array.isArray(ids) && ids.length > 0) {
            e.preventDefault();
            e.stopPropagation();
            ids.filter(id => id && id !== 'root').forEach(id => {
              try { jm.remove_node(id); } catch (err) { }
            });
            if (typeof window.clearMultiSelection === 'function') window.clearMultiSelection();
            if (typeof debouncedSave === 'function') debouncedSave();
          }
        }
      }, true);

      // 批量删除函数（供按钮调用）
      window.batchDelete = function () {
        const ids = window.getMultiSelection();
        if (!Array.isArray(ids) || ids.length === 0) {
          showWarning('请先选择要删除的节点');
          return;
        }

        if (!confirm(`确定要删除选中的 ${ids.length} 个节点吗？`)) return;

        let deletedCount = 0;
        ids.filter(id => id && id !== 'root').forEach(id => {
          try {
            jm.remove_node(id);
            deletedCount++;
          } catch (err) {
            console.warn(`删除节点 ${id} 失败:`, err);
          }
        });

        if (typeof window.clearMultiSelection === 'function') window.clearMultiSelection();
        if (typeof debouncedSave === 'function') debouncedSave();

        showSuccess(`成功删除 ${deletedCount} 个节点`);
      };

      // 批量移动函数
      window.batchMove = function () {
        const ids = window.getMultiSelection();
        if (!Array.isArray(ids) || ids.length === 0) {
          showWarning('请先选择要移动的节点');
          return;
        }

        // 设置批量移动模式
        window.__batchMoving = true;
        window.__batchMoveIds = ids;

        // 显示移动提示
        const hint = document.createElement('div');
        hint.id = 'batchMoveHint';
        hint.style.cssText = `
          position: fixed;
          top: 50%;
          left: 50%;
          transform: translate(-50%, -50%);
          background: rgba(76, 154, 255, 0.9);
          color: white;
          padding: 15px 25px;
          border-radius: 8px;
          font-size: 14px;
          z-index: 1000;
          box-shadow: 0 4px 12px rgba(0,0,0,0.3);
          text-align: center;
          max-width: 300px;
        `;
        hint.innerHTML = `
          <div style="font-weight: bold; margin-bottom: 8px;">批量移动模式</div>
          <div>点击目标节点，将选中的 ${ids.length} 个节点移动到该节点后面</div>
          <div style="margin-top: 10px; font-size: 12px; opacity: 0.8;">按 ESC 键取消</div>
        `;
        document.body.appendChild(hint);

        // 添加ESC键取消功能
        const escHandler = function (e) {
          if (e.key === 'Escape') {
            cancelBatchMove();
          }
        };
        document.addEventListener('keydown', escHandler);

        // 取消批量移动函数
        window.cancelBatchMove = function () {
          window.__batchMoving = false;
          window.__batchMoveIds = [];
          const hint = document.getElementById('batchMoveHint');
          if (hint) hint.remove();
          document.removeEventListener('keydown', escHandler);
          delete window.cancelBatchMove;
        };

        showInfo('批量移动模式已激活，点击目标节点完成移动');
      };
    }

    function exportData() {
      if (!jm) return;
      try {
        const data = jm.get_data();
        const jsonText = JSON.stringify(data, null, 2);
        const pre = document.getElementById('jsonPreview');
        if (pre) pre.textContent = jsonText;
        if (window.jQuery && $('#jsonModal').modal) {
          $('#jsonModal').modal('show');
        } else {
          const w = window.open('', '_blank', 'width=900,height=700');
          if (w) {
            w.document.write('<pre style="white-space:pre-wrap;word-break:break-word;">' +
              (jsonText.replace(/</g, '<')) + '</pre>');
            w.document.close();
          } else {
            showWarning('请允许弹窗以查看JSON');
          }
        }
      } catch (e) {
        showError('查看JSON失败: ' + e.message);
      }
    }

    // 提示信息函数
    function showWarning(msg) {
      console.warn(msg);
      alert(msg);
    }

    function showError(msg) {
      console.error(msg);
      alert(msg);
    }

    function showSuccess(msg) {
      console.log(msg);
      alert(msg);
    }

    function showInfo(msg) {
      console.log(msg);
      alert(msg);
    }

    // 获取默认NodeTree
    function getDefaultNodeTree() {
      return {
        "meta": {
          "name": "jsMind remote",
          "author": "mindword",
          "version": "1.0.0"
        },
        "format": "node_tree",
        "data": {
          "id": "root",
          "topic": "欢迎使用思维导图",
          "children": [
            {
              "id": "sub1",
              "topic": "点击节点编辑",
              "direction": "right",
              "children": [
                {
                  "id": "sub1_1",
                  "topic": "双击编辑文本",
                  "data": {
                    "notes": "双击节点可以编辑文本内容"
                  }
                },
                {
                  "id": "sub1_2",
                  "topic": "拖拽调整位置",
                  "data": {
                    "notes": "拖拽节点可以调整位置和层级关系"
                  }
                }
              ]
            },
            {
              "id": "sub2",
              "topic": "右侧编辑详情",
              "direction": "right",
              "data": {
                "notes": "在右侧面板可以编辑节点的详细信息"
              }
            }
          ]
        }
      };
    }

    // 保存当前数据到localStorage
    function saveToLocalStorage() {
      if (!jm) return;

      const currentData = jm.get_data();
      const dataString = JSON.stringify(currentData);

      // 避免触发本地监听器（防止循环加载）
      lastStorageData = dataString;
      // 标记抑制：本页即将写入 nodetree，一次自发写入
      window.__mindmapSuppressCount = (window.__mindmapSuppressCount || 0) + 1;
      localStorage.setItem('mindword_nodetree_data', dataString);
      // 同步数据到各个系统
      try {
        // 1. 优先使用syncAll函数（如果存在）
        if (typeof syncAll === 'function') {
          // 动态加载转换器（如果需要）
          if (!window.converter) {
            console.log('正在加载转换器...');
            import('../converter/converter.js')
              .then(module => {
                window.converter = new module.ConverterManager();
                console.log('转换器已加载');
                // 转换器就绪后，统一从思维导图源同步并写三份缓存
                if (typeof syncAll === 'function') {
                  window.__mindmapSelfUpdateUntil = Date.now() + 1500;
                  // 标记抑制：syncAll 执行过程中可能再次写入 nodetree
                  window.__mindmapSuppressCount = (window.__mindmapSuppressCount || 0) + 1;
                  syncAll('mindmap', true, true, currentData);
                }
              })
              .catch(error => {
                console.warn('转换器加载失败，使用降级模式:', error);
                // 降级处理：直接保存到localStorage
                localStorage.setItem('mindword_nodetree_data', JSON.stringify(currentData));
              });
          } else {
            // 转换器已存在，直接调用：从思维导图源同步并写三份缓存
            if (typeof syncAll === 'function') {
              window.__mindmapSelfUpdateUntil = Date.now() + 1500;
              // 标记抑制：syncAll 执行过程中可能再次写入 nodetree
              window.__mindmapSuppressCount = (window.__mindmapSuppressCount || 0) + 1;
              syncAll('mindmap', true, true, currentData);
            }
          }
        } else {
          // 2. 降级处理：保存到localStorage
          console.log('syncAll函数不存在，保存到localStorage');
          localStorage.setItem('mindword_nodetree_data', JSON.stringify(currentData));
        }
        // 同步到父页面
        if (window.parent !== window) {
          window.parent.postMessage({
            type: 'mindmapUpdated',
            data: currentData
          }, '*');
        }
      } catch (error) {
        console.warn('同步方法调用失败:', error);
        // 最终降级处理
        localStorage.setItem('mindword_nodetree_data', JSON.stringify(currentData));
      }
    }

    // 防抖保存
    let saveTimer = null;
    function debouncedSave() {
      clearTimeout(saveTimer);
      saveTimer = setTimeout(() => saveToLocalStorage(), 300);
    }

    // 类型对齐辅助函数：读取/写入节点类型（优先根级别，兼容 data.type）
    function getNodeType(n) {
      if (!n) return undefined;

      if (typeof n.type !== 'undefined') {
        return n.type;
      } else if (n.data && typeof n.data.type !== 'undefined') {
        return n.data.type;
      } else if (n.data && n.data.data && typeof n.data.data.type !== 'undefined') {
        return n.data.data.type;
      }
      return undefined;
    }
    function setNodeType(n, t) {
      if (!n) return;
      n.type = t;
      if (n.data) {
        if (n.data.data) {
          n.data.data.type = t;
        } else {
          n.data.type = t;
        }
      }
    }

    // 设置节点层级（标题类型专用）
    function setNodeLevel(n, level) {
      if (!n || level < 1 || level > 6) return;
      n.level = level;
      if (n.data) {
        if (n.data.data) {
          n.data.data.level = level;
        } else {
          n.data.level = level;
        }
      }
    }
    // 读取节点层级（兼容根级和 data.level）
    function getNodeLevel(n) {
      if (!n) return null;
      if (typeof n.level !== 'undefined') return n.level;
      if (n.data && typeof n.data.level !== 'undefined') return n.data.level;
      if (n.data && n.data.data && typeof n.data.data.level !== 'undefined') return n.data.data.level;

      // Fallback 1：如果节点topic是数字，尝试解析为层级
      if (n.topic && /^\d+$/.test(n.topic.trim())) {
        const topicLevel = parseInt(n.topic.trim());
        if (topicLevel >= 0 && topicLevel <= 6) {
          return topicLevel;
        }
      }

      // Fallback 2：基于节点在父节点中的位置估算层级
      if (n.parent) {
        const parent = jm.get_node(n.parent.id);
        if (parent && parent.children && parent.children.length > 0) {
          // 计算节点在兄弟节点中的位置
          const siblingIndex = parent.children.findIndex(child => child && child.id === n.id);
          if (siblingIndex >= 0) {
            // 简单的启发式：如果父节点有明确的层级，子节点应该比父节点低一级
            const parentLevel = getNodeLevel(parent);
            if (parentLevel !== null && parentLevel >= 1 && parentLevel < 6) {
              const estimatedLevel = parentLevel + 1;
              return estimatedLevel;
            }
          }
        }
      }

      return null;
    }

    // 将节点强制设为列表类型，并尽量继承列表标识
    function forceListType(n, inheritFrom) {
      if (!n) return;
      const oldType = getNodeType(n);
      let ordered = false;
      let marker = '-';
      if (inheritFrom) {
        const inhData = inheritFrom.data || {};
        ordered = (inhData.ordered != null) ? inhData.ordered : (inheritFrom.ordered != null ? inheritFrom.ordered : false);
        marker = (inhData.marker != null) ? inhData.marker : (inheritFrom.marker != null ? inheritFrom.marker : (ordered ? '1.' : '-'));
      }
      n.type = 'list';
      n.ordered = ordered;
      n.marker = marker;
      if (!n.data) n.data = {};

      // 修复：处理 jsMind 的数据结构变化
      if (n.data.data) {
        // 如果存在嵌套的 data 结构
        n.data.data.type = 'list';
        n.data.data.ordered = ordered;
        n.data.data.marker = marker;
      } else {
        // 传统的数据结构
        n.data.type = 'list';
        n.data.ordered = ordered;
        n.data.marker = marker;
      }

      delete n.level;
      if (n.data) {
        if (n.data.data) {
          delete n.data.data.level;
        } else {
          delete n.data.level;
        }
      }
    }

    // 将某节点及其全部子孙归一为列表（用于被挂载到列表父节点之下）
    function normalizeSubtreeUnderList(rootId, parentNodeForInherit) {
      if (!jm) return;
      const root = jm.get_node(rootId);
      if (!root) return;

      const inheritFrom = parentNodeForInherit || (root.parent ? jm.get_node(root.parent.id) : null);

      const stack = [root];

      while (stack.length > 0) {
        const cur = stack.pop();
        forceListType(cur, inheritFrom);

        if (cur.children && cur.children.length) {
          for (const ch of cur.children) {
            if (ch) stack.push(ch);
          }
        }
      }
    }



    // 根据同级（若有）或父节点（若无同级）对齐当前节点类型
    function applySiblingOrParentType(nodeOrId) {
      if (!jm) return;
      let node = null;
      if (nodeOrId && typeof nodeOrId === 'object' && nodeOrId.id) {
        node = nodeOrId;
      } else {
        node = jm.get_node(nodeOrId);
      }
      if (!node) return;

      // 收集同级（排除自己）
      let siblings = [];
      if (node.parent) {
        const parentNode = jm.get_node(node.parent.id);
        if (parentNode && parentNode.children && parentNode.children.length > 0) {
          siblings = parentNode.children.filter(c => c && c.id !== node.id);
        }
      }

      // 参考类型：优先同级的第一个有类型的节点，否则父节点类型
      let refType;
      let refLevel;

      if (siblings.length > 0) {
        for (const s of siblings) {
          const t = getNodeType(s);
          if (typeof t !== 'undefined') {
            refType = t;
            refLevel = getNodeLevel(s);
            break;
          }
        }
      }

      if (typeof refType === 'undefined' && siblings.length === 0 && node.parent) {
        const p = jm.get_node(node.parent.id);
        const pType = getNodeType(p);
        const pLevel = getNodeLevel(p) || 0;

        if (pType === undefined) {
          refType = 'list';
        } else {
          refType = (pType === 'heading' && pLevel >= 6) ? 'list' : pType;

          if (refType === 'heading') {
            if (pLevel >= 1) {
              refLevel = pLevel + 1;
            } else {
              if (p.topic && /^\d+$/.test(p.topic.trim())) {
                const parentTopicLevel = parseInt(p.topic.trim());
                if (parentTopicLevel >= 0 && parentTopicLevel < 6) {
                  refLevel = parentTopicLevel + 1;
                } else {
                  refLevel = 2;
                }
              } else {
                refLevel = 2;
              }
            }
          }
        }
      }

      if (typeof refType === 'undefined') return; // 没有可参考类型则不改
      const curType = getNodeType(node);
      const curLevel = getNodeLevel(node);

      if (curType !== refType) {
        setNodeType(node, refType);

        // 如果是标题类型且有参考层级，设置合适的层级
        if (refType === 'heading' && typeof refLevel !== 'undefined' && refLevel > 0) {
          setNodeLevel(node, refLevel);
        }

        // 类型变化后触发一次轻量保存（不额外调用全量同步）
        debouncedSave();
      } else if (refType === 'heading' && typeof refLevel !== 'undefined' && curLevel !== refLevel) {
        // 类型相同但层级不同，调整层级
        setNodeLevel(node, refLevel);
        debouncedSave();
      }
    }

    // 设置思维导图变化监听器
    function setupMindmapChangeWatcher() {
      if (!jm) return;

      // 监听jsMind的各种变化事件
      jm.add_event_listener(function (type, data) {
        // 只在特定事件类型时触发保存
        const saveEvents = [
          jsMind.event_type.edit,
          jsMind.event_type.add_node,
          jsMind.event_type.remove_node,
          jsMind.event_type.move_node,
          jsMind.event_type.move
        ];

        if (saveEvents.includes(type)) {
          // 专门处理 move_node：用事件返回的 [nodeId, beforeId, parentId, direction] 先强制重挂载，再归一/保存
          try {
            if (type === jsMind.event_type.move_node && data && Array.isArray(data.data) && data.data.length >= 3) {
              const movedId = data.data[0];
              const beforeId = data.data.length > 1 ? data.data[1] : null;
              const newParentId = data.data[2];
              const direction = data.data.length > 3 ? data.data[3] : null;

              // 批量跟随移动：如果存在多选并且当前移动的是多选集合中的一个，则把其余选中节点也移动到相同的新父节点，依次跟在 movedId 之后
              try {
                if (!window.__batchMoving && typeof window.getMultiSelection === 'function') {
                  const selectedIds = window.getMultiSelection ? window.getMultiSelection() : [];
                  if (Array.isArray(selectedIds) && selectedIds.length > 1 && selectedIds.includes(movedId)) {
                    window.__batchMoving = true;
                    // 先将 movedId 作为锚点，之后的节点依次插入到它后面
                    let anchorId = movedId;
                    for (const sid of selectedIds) {
                      if (!sid || sid === movedId) continue;
                      try {
                        // 将其他节点移动到与 movedId 相同的新父节点，并排在 anchorId 后面
                        jm.move_node(sid, anchorId, newParentId, direction);
                        anchorId = sid;
                      } catch (eMoveBatch) {
                        // 忽略某个节点移动失败，继续其他
                      }
                    }
                  }
                }
              } finally {
                // 短暂延迟后解除批量标记，允许后续正常 move 事件
                setTimeout(() => { window.__batchMoving = false; }, 0);
              }

              // 1) 强制重挂载（确保结构真的变化）
              try {
                jm.move_node(movedId, beforeId, newParentId, direction);
              } catch (eMove) {
                // 忽略重挂载错误
              }

              // 2) 延后一帧读取最新节点与父节点，做类型对齐与列表归一，再保存
              setTimeout(() => {
                try {
                  const fresh = jm.get_node(movedId);
                  const parentNode = jm.get_node(newParentId);

                  if (fresh) {
                    applySiblingOrParentType(fresh, parentNode);

                    if (parentNode && typeof getNodeType === 'function') {
                      const parentType = getNodeType(parentNode);
                      // 检查父节点是否为列表类型，或者看起来像是列表（有列表特征）
                      const hasListFeatures = parentNode.data && (parentNode.data.listMarker || parentNode.data.marker || parentNode.data.listLevel !== undefined);

                      if (parentType === 'list' || (parentType === undefined && hasListFeatures)) {
                        normalizeSubtreeUnderList(movedId, parentNode);
                      }
                    }
                  }

                  debouncedSave();
                } catch (eLater) {
                  console.warn('move_node 延后处理失败:', eLater);
                }
              }, 0);
            }
          } catch (e0) {
            console.warn('基于返回ID处理 move_node 失败:', e0);
          }

          // 尝试获取受影响节点对象（兼容多种事件数据形态）
          let node = null;
          try {
            // 1) 常见：data.node 可能是对象或 id
            let maybe = data && (data.node != null ? data.node : null);
            // 2) move 事件有时直接把节点对象放在 data 上
            if (!maybe && data && typeof data === 'object' && data.id) {
              maybe = data;
            }
            // 3) 如果 maybe 是 id 字符串
            if (maybe && typeof maybe === 'string') {
              node = jm.get_node(maybe);
            } else if (maybe && typeof maybe === 'object' && maybe.id) {
              node = maybe;
            }
            // 4) 兜底：用当前选中节点
            if (!node) {
              const sel = jm.get_selected_node && jm.get_selected_node();
              if (sel) {
                node = typeof sel === 'string' ? jm.get_node(sel) : sel;
              }
            }
          } catch (e) {
            console.warn('事件数据中无法解析节点:', e);
          }

          // 类型对齐：延后到下一轮事件循环，确保jsMind已更新父子关系
          if (node) {
            setTimeout(() => {
              try {
                const fresh = jm.get_node(node.id);
                if (!fresh) return;

                // 获取父节点
                const parentNode = fresh.parent ? jm.get_node(fresh.parent.id) : null;
                applySiblingOrParentType(fresh, parentNode);

                // 若父为列表，则将自己与子孙全部归一为列表（兜底，防止未走API包装）
                try {
                  const p = fresh.parent ? jm.get_node(fresh.parent.id) : null;
                  if (p && typeof getNodeType === 'function' && getNodeType(p) === 'list') {
                    normalizeSubtreeUnderList(fresh.id, p);
                  }
                } catch (e2) {
                  // 忽略归一化错误
                }

                debouncedSave();
              } catch (e3) {
                console.warn('延后处理失败:', e3);
              }
            }, 0);
          }
        }
      });
    }


    // 监听localStorage变化（包括同一页面内的修改）
    let lastStorageData = null;
    let storageCheckTimer = null;
    let lastChangeTime = 0;

    // 检查localStorage数据是否变化的函数（带防抖）
    function checkLocalStorageChange() {
      const now = Date.now();
      if (window.__mindmapSelfUpdateUntil && now < window.__mindmapSelfUpdateUntil) {
        return;
      }

      let currentData;
      try {
        currentData = localStorage.getItem('mindword_nodetree_data');
      } catch (e) {
        return;
      }

      // 若为本页自发写入，消费一次抑制计数并跳过刷新
      if (window.__mindmapSuppressCount && window.__mindmapSuppressCount > 0) {
        window.__mindmapSuppressCount--;
        lastStorageData = currentData;
        return;
      }

      if (currentData !== lastStorageData) {
        lastStorageData = currentData;
        lastChangeTime = now;

        // 防抖处理：延迟500ms执行，避免频繁刷新
        clearTimeout(storageCheckTimer);
        storageCheckTimer = setTimeout(() => {
          try {
            loadNodeTree();
          } catch (e) {
            // 忽略重新加载错误
          }
        }, 500);
      }
    }


    // 设置localStorage变化监听器
    function setupLocalStorageWatcher() {
      // 保存初始数据
      lastStorageData = localStorage.getItem('mindword_nodetree_data');

      // 使用setInterval定期检查变化（每500ms检查一次）
      setInterval(checkLocalStorageChange, 500);

      // 同时监听storage事件（处理其他页面的变化）
      window.addEventListener('storage', function (e) {
        if (e.key === 'mindword_nodetree_data') {
          checkLocalStorageChange();
        }
      });

      // 监听自定义事件（用于同一页面内的通知）
      window.addEventListener('mindwordDataUpdated', function () {
        checkLocalStorageChange();
      });
    }

    // 下载思维导图为图片
    function downloadMindmap() {
      if (!jm) return;
      try {
        // 创建新的截图插件实例，使用白色背景
        var screenshot_plugin = new JmScreenshot(jm, {
          background: '#ffffff'  // 设置白色背景
        });
        screenshot_plugin.shoot();
      } catch (error) {
        // 静默处理下载错误
      }
    }



    // 页面加载完成后初始化
    window.addEventListener('load', async function () {
      // 初始化转换器
      try {
        if (!window.converter) {
          const module = await import('../converter/converter.js');
          window.converter = new module.ConverterManager();
          // 广播就绪事件（供需要时监听）
          window.dispatchEvent(new Event('converterReady'));
        }
      } catch (error) {
        // 忽略转换器初始化错误
      }

      initMindmap();
      setupLocalStorageWatcher();
      setupMindmapChangeWatcher();
      // 启用框选多选
      setupBoxSelection();

      // 初始化AI扩写功能
      if (window.AIExpander) {
        window.aiExpander = new window.AIExpander();
        window.aiExpander.init(jm);
      }
    });



  </script>
</body>

</html>