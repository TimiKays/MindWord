<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>思维导图编辑器</title>
  <link rel="stylesheet" href="../styles.css">
  <link type="text/css" rel="stylesheet" href="../jsmind-local/jsmind.css" />
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/css/bootstrap.min.css" />
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.4/dist/jquery.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/js/bootstrap.bundle.min.js"></script>



  <link rel="stylesheet" href="mindmap.css">

</head>

</head>

<body>
  <div class="toolbar">
    <!-- 批量操作工具栏 -->


    <span class="ico-btn" role="button" onclick="downloadMindmap()" tabindex="0" title="下载图片"
      style="--ico: url('res/download.svg'); "></span>
    <span class="ico-btn" role="button" onclick="exportData()" tabindex="0" title="查看JSON"
      style="--ico: url('res/code.svg'); "></span>


    <!-- 图标选择器下拉菜单（已定制：隐藏默认 caret、只保留网格内第一个“清除”按钮） -->
    <style>
      /* 隐藏 Bootstrap 的下拉小箭头并去掉可能的聚焦动画/outline */
      #iconPickerBtn.dropdown-toggle::after {
        display: none !important;
      }

      #iconPickerBtn:focus {
        outline: none !important;
        box-shadow: none !important;
      }

      /* 工具栏内图标按钮保证 emoji 可见 */
      #iconGridToolbar .icon-picker-item {
        font-family: "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji", system-ui, sans-serif;
        color: #222 !important;
        font-size: 20px !important;
        line-height: 1;
        padding: 0;
        background: white !important;
      }

      /* 去掉下拉菜单自身的动画（若存在） */
      #iconPickerDropdown .dropdown-menu {
        transition: none !important;
        -webkit-transition: none !important;
        -moz-transition: none !important;

      }
    </style>

    <div class="dropdown" id="iconPickerDropdown" style="display: inline-block;">

      <span id="iconPickerBtn" class="ico-btn dropdown-toggle" role="button" data-toggle="dropdown" aria-haspopup="true"
        aria-expanded="false" title="选择图标" tabindex="0" style="--ico: url('res/tag.svg');"></span>
      <div class="dropdown-menu" aria-labelledby="iconPickerBtn"
        style="width: 360px; max-height: 420px; overflow-y: auto; overflow-x: hidden;">
        <div style="padding: 12px;">
          <h6 style="margin: 0 0 8px 0; font-size: 14px; font-weight: 600;">选择图标</h6>
          <div id="iconGridToolbar"
            style="display: grid; grid-template-columns: repeat(7, 1fr); gap: 6px; padding-bottom:8px; box-sizing: border-box; column-gap:6px;">
            <!-- 图标将通过JavaScript动态生成（第一个为清除） -->
          </div>
        </div>
        <!-- 已移除重复的底部清除按钮（仅保留网格中的第一个清除按钮） -->
      </div>
    </div>

    <!-- batchOperations 保留在 DOM 中但会被移动到画布左上（通过脚本在非移动端显示） -->
    <div id="batchOperations"
      style="display: none; float: right; padding: 1px 6px; background: rgba(76, 154, 255, 0.1); border-radius: 4px; border: 1px solid #4c9aff;">
      <span style="color: #4c9aff; font-size: 12px; ">已选中 <span id="selectedCount">0</span>
        个节点</span>
    </div>

    <!-- 右侧三个简单复选框：详情面板 / 显示节点类型 / 显示列表节点 -->
    <div id="toolbarToggles"
      style="margin-left:auto;display:flex;gap:12px;align-items:flex-end;justify-content:flex-end;">
      <span id="toggleNodeDetailsBtn" class="ico-btn state-on" role="button" tabindex="0" aria-pressed="true"
        title="详情面板" style="--ico: url('res/detail.svg'); "></span>
      <label class="mw-toggle-showtype"
        style="display:none;flex-direction:column;align-items:center;font-size:12px;margin:0 4px;">
        <input id="toggleShowNodeTypeCheckbox" type="checkbox" style="width:18px;height:18px;margin-bottom:6px;">
        <span style="display:block;margin-top:0;">显示类型</span>
      </label>
      <label class="mw-toggle-showtitleonly"
        style="display:none;flex-direction:column;align-items:center;font-size:12px;margin:0 4px;">
        <input id="toggleShowListNodesCheckbox" type="checkbox" style="width:18px;height:18px;margin-bottom:6px;">
        <span style="display:block;margin-top:0;">只看标题</span>
      </label>
    </div>





  </div>

  <div class="main-container">
    <div id="fullScreenMindmap"></div>



    <!-- 浮动节点详情面板（可关闭），保留内部字段和功能 -->
    <div id="nodeDetails" role="dialog" aria-hidden="true" aria-label="节点详情">
      <div class="panel-header">
        <strong>节点详情</strong>
        <button class="panel-close-btn" aria-label="关闭节点详情" onclick="hideNodeDetails()">✕</button>
      </div>

      <div id="nodeDetailsEmpty" style="display:none; padding:24px; text-align:center; color:#64748b;">
        <img src="../res/empty.svg" alt="空状态" style="width:72px;height:72px;opacity:0.9;margin-bottom:12px;">
        <div>请选择一个节点</div>
      </div>

      <div id="nodeDetailsForm">
        <div id="nodeInfo"></div>

        <div class="form-group">
          <label for="nodeTopic">节点主题:</label>
          <textarea id="nodeTopic" placeholder="输入节点主题..." rows="3"
            style="width:100%; resize:vertical; line-height:1.4em;"></textarea>
        </div>

        <div class="form-group">
          <label for="nodeNotes">节点备注:</label>
          <textarea id="nodeNotes" placeholder="输入节点备注..."></textarea>
        </div>

        <div style="margin-bottom: 15px; display: flex; gap: 10px;">
          <button class="btn" onclick="expandWithAI()"
            style="flex: 1; background: linear-gradient(135deg, #6da8e7, #6adbc8); color: white;">AI扩写</button>
          <button class="btn" onclick="AIExpander.showConfig()" style="flex: 0 0 40px; background: #ffffff;"
            title="AI配置">⚙️</button>
        </div>

        <!-- 自动更新提示 -->
        <div id="autoUpdateIndicator"
          style="display: none; margin-bottom: 10px; padding: 5px 10px; background: #d4edda; border: 1px solid #c3e6cb; border-radius: 4px; color: #155724; font-size: 12px; text-align: center;">
          <span style="display: inline-block; animation: pulse 1s ease-in-out;">✓</span> 已自动更新
        </div>

      </div>

      <!-- 通知桥接器 -->
      <script src="../notification-bridge.js"></script>

    </div>
  </div>
  </div>

  <script src="../jsmind-local/jsmind.js"></script>
  <script src="../jsmind-local/jsmind.draggable-node.js"></script>
  <script src="https://unpkg.com/dom-to-image@2.6.0/dist/dom-to-image.min.js"></script>
  <!-- 使用与jsMind 0.5.7版本匹配的截图插件 -->
  <script src="../jsmind-local/jsmind.screenshot.js"></script>
  <script type="module" src="../converter/sync.js"></script>
  <script type="module" src="../converter/load.js"></script>
  <script src="plugins/undo_manager.js"></script>




  <script src="icons.js"></script>
  <script type="module" src="mindmap-core.js"></script>
  <script>

    /* mindmap-ui.js - UI related extracted scripts */


    // --- extracted block from original HTML ---
    // AI扩写函数（改为使用父层托管的 AI 弹窗组件，modal 模式）
    function expandWithAI() {
      try {
        const selectedNode = jm.get_selected_node();
        if (!selectedNode) {
          showWarning('请先选择一个节点');
          return;
        }

        // 构造 requestId
        function genId() { return 'r_' + Math.random().toString(36).slice(2, 10); }
        const requestId = genId();

        // 准备 templateData：使用预设模板（扩展子节点），并注入真实上下文
        var topic = selectedNode.topic || '';
        // 优先从最新节点数据读取备注；回退到详情面板输入
        var _nodeLatest = null;
        try { _nodeLatest = jm.get_node ? jm.get_node(selectedNode.id) : selectedNode; } catch (_) { _nodeLatest = selectedNode; }
        var notes = (_nodeLatest && _nodeLatest.data && _nodeLatest.data.notes) ? _nodeLatest.data.notes
          : (document.getElementById('nodeNotes') ? document.getElementById('nodeNotes').value : '');

        // 计算 fullPath 与 siblingNodes（若可用）
        function _computeFullPath(n) {
          try {
            if (typeof window.getNodeFullPath === 'function') return window.getNodeFullPath(n);
          } catch (_) { /* ignore */ }
          try {
            var path = [];
            var cur = n;
            while (cur) {
              path.unshift(cur.topic || '');
              var p = jm.get_parent ? jm.get_parent(cur.id) : null;
              if (!p) break;
              cur = p;
            }
            return path.join(' / ');
          } catch (e) {
            return n.topic || '';
          }
        }
        // 统一使用真实节点对象，避免轻量对象丢失父链/children
        var realSel = null;
        try { realSel = jm.get_node ? jm.get_node(selectedNode.id) : selectedNode; } catch (_) { realSel = selectedNode; }

        // 完整路径：从根到当前节点
        function _computeFullPathStrict(n) {
          try {
            // 若有外部工具函数则优先
            if (typeof window.getNodeFullPath === 'function') return window.getNodeFullPath(n);
          } catch (_) { /* ignore */ }
          try {
            var path = [];
            var cur = n;
            while (cur) {
              path.unshift(cur.topic || '');
              cur = (jm.get_parent && cur.id) ? jm.get_parent(cur.id) : null;
            }
            return path.join(' / ');
          } catch (e) { return n && (n.topic || ''); }
        }
        var fullPath = '';
        try {
          fullPath = (realSel && realSel.data && (realSel.data.fullPath || (realSel.data.data && realSel.data.data.fullPath))) || '';
        } catch (e) {
          fullPath = (realSel && realSel.topic) ? realSel.topic : '';
        }

        // 兄弟节点：直接从节点数据中读取（优先使用 data.siblingNodes）
        var siblingNodes = '';
        try {
          var sib = (realSel && realSel.data && (realSel.data.siblingNodes || (realSel.data.data && realSel.data.data.siblingNodes))) || [];
          if (Array.isArray(sib)) {
            siblingNodes = sib.filter(Boolean).join(', ');
          } else if (typeof sib === 'string') {
            siblingNodes = sib;
          }
        } catch (e) { siblingNodes = ''; }

        // 从 prompt-templates.json 中读取“扩展子节点”模板内容（若无法访问则回退）
        var templateText = '';
        try {
          var tplList = window.__prompt_templates || null;
          if (!tplList) {
            // lazy load from ai/newai/prompt-templates.json if available via fetch (silent)
            try {
              // sync attempt may fail in file://; fallback to default string
              // we will try to read from a global if demo pages preloaded templates
              tplList = window.__prompt_templates || tplList;
            } catch (err) { tplList = tplList || null; }
          }
          if (Array.isArray(tplList)) {
            for (var ti = 0; ti < tplList.length; ti++) {
              var t = tplList[ti];
              if (t && t.name === '扩展子节点') { templateText = t.content || ''; break; }
            }
          }
        } catch (e) { templateText = ''; }

        // 最终回退策略：如果没有模板则使用 topic 或简单占位符
        if (!templateText || !String(templateText).trim()) {
          templateText = topic || '{{name}}';
        }

        var payload = {
          // modal 模式：不设置 mode 或确保不是 'direct'
          platformConfig: {}, // 可选：留空由父页面选择已保存平台或打开配置
          modelConfig: {},
          templateData: {
            templateText: templateText,
            placeholders: {
              // 对齐新组件默认占位符格式 {{name}}
              name: { desc: '节点主题', value: topic },
              notes: { desc: '节点备注', value: notes },
              fullPath: { desc: '节点完整路径', value: fullPath },
              siblingNodes: { desc: '同级兄弟节点（以逗号分隔）', value: siblingNodes },
              nodeId: { desc: '节点ID', value: selectedNode.id },
              // 补充上下文摘要，复用旧逻辑思想：提供可读文本，便于模板直接引用 {{context}}
              context: {
                desc: '节点上下文摘要',
                value: (function () {
                  try {
                    var lines = [];
                    lines.push('节点: ' + (topic || ''));
                    lines.push('路径: ' + (fullPath || ''));
                    if (notes) lines.push('备注: ' + notes);
                    if (parent && (parent.topic || '')) lines.push('父节点: ' + (parent.topic || ''));
                    if (siblingNodes) lines.push('同级兄弟: ' + siblingNodes);
                    var childTitles = (selectedNode.children || []).map(function (c) { return c.topic || ''; }).filter(Boolean).join(', ');
                    if (childTitles) lines.push('已有子节点: ' + childTitles);
                    return lines.join('\\n');
                  } catch (e) {
                    return (topic || '') + '\\n' + (fullPath || '');
                  }
                })()
              }
            }
          },
          options: {}
        };

        // 指定预置模板 key 与参数映射，便于弹窗自动选中模板和展示参数
        try { payload.templateData.templateKey = '扩展子节点'; } catch (e) { }
        try { payload.params = payload.templateData.placeholders; } catch (e) { }

        // 临时消息处理器：等待 AI_MODAL_RESULT 回来
        const onMessage = function (e) {
          try {
            const msg = e && e.data;
            if (!msg || msg.type !== 'AI_MODAL_RESULT' || msg.requestId !== requestId) return;
            // 清理
            window.removeEventListener('message', onMessage);
            clearTimeout(timeoutT);

            if (msg.status === 'ok') {
              try {
                const detail = msg.detail || {};
                // 期望 detail 中包含生成的内容（例如 detail.output 或 detail.text）
                // 支持两种常见格式：detail.output（带 [OUTPUT] 包裹）或 detail.text
                const outText = detail.output || detail.text || (detail.result && detail.result.text) || '';
                if (!outText) {
                  showWarning('AI 未返回有效内容');
                  return;
                }

                // 将 AI 返回的文本解析为若干子节点（简单按换行分割标题行或 Markdown 标题）
                // 若返回结构化 [OUTPUT] 标签，尝试提取标签内内容
                let parsed = outText;
                const m = /\[OUTPUT\]([\s\S]*)\[\/OUTPUT\]/i.exec(outText);
                if (m && m[1]) parsed = m[1].trim();

                // 简单解析策略：按行取以 '#' 开头的标题或非空行作为子节点标题
                // 处理兼容性：先去除 \r 再按 '\n' 分割，避免正则字面量被格式化器拆行
                var normalized = (parsed || '').replace(/\r/g, '');
                var lines = normalized.split('\n').map(function (s) { return (s || '').trim(); }).filter(function (s) { return !!s; });
                var childTitles = [];
                lines.forEach(function (line) {
                  var h = (line || '').replace(/^#+\s*/, '').trim();
                  if (h) childTitles.push(h);
                });
                if (childTitles.length === 0) {
                  // 退回到按段落分割：按连续空行（'\n\n' 或 更多）分割
                  var paras = normalized.split(/\n{2,}/).map(function (s) { return (s || '').trim(); }).filter(function (s) { return !!s; });
                  paras.forEach(function (p) {
                    var firstLine = (p.split('\n')[0] || '').trim();
                    if (firstLine) childTitles.push(firstLine);
                  });
                }

                if (childTitles.length === 0) {
                  showWarning('无法从 AI 输出解析出子节点，请检查输出格式');
                  return;
                }

                // 插入子节点（使用 jm API，插入到 selectedNode 下）
                childTitles.forEach(function (title) {
                  try {
                    // 使用 jm.add_node(parentid, nodeid, topic)
                    const nid = 'n_' + Math.random().toString(36).slice(2, 9);
                    jm.add_node(selectedNode.id, nid, title);
                  } catch (e) {
                    console.warn('插入子节点失败', e);
                  }
                });

                // 保存 / 提示
                try { if (typeof debouncedSave === 'function') debouncedSave(); } catch (e) { }
                try { showSuccess && showSuccess('已为该节点生成 ' + childTitles.length + ' 个子节点'); } catch (e) { }
              } catch (err) {
                console.error('处理 AI 结果失败', err);
                showError('处理 AI 结果失败: ' + (err && err.message ? err.message : String(err)));
              }
            } else {
              // error
              const detailMsg = (msg.detail && msg.detail.message) ? msg.detail.message : 'AI 返回错误';
              showError('AI 生成失败: ' + detailMsg);
            }
          } catch (e) {
            console.warn('expandWithAI onMessage error', e);
          }
        };

        window.addEventListener('message', onMessage);

        // 超时保护（30s）：仅在非嵌入（非 modal）场景显示全局错误；嵌入场景由父页面/modal 处理超时
        const timeoutT = setTimeout(function () {
          try {
            // 先移除监听，避免后续重复触发
            window.removeEventListener('message', onMessage);
            // 若当前页面被嵌入到父页面（通常表示会由父页面显示 modal），则跳过本地的错误提示
            const isEmbedded = (window.parent && window.parent !== window);
            if (isEmbedded) {
              console.debug('[MW][AI] timeout skipped: parent/modal should handle it', requestId);
              // 可选：通知父窗口超时（注释掉以避免多余消息）
              // try { window.parent.postMessage({ type: 'AI_MODAL_TIMEOUT', requestId: requestId }, '*'); } catch (_) {}
              return;
            }
            // 非嵌入（headless）场景显示本地错误
            showError('AI 响应超时（30s）');
          } catch (e) { }
        }, 30000);

        // 发送请求给父页面
        try {
          console.log('[MW][AI] send AI_MODAL_OPEN_REQUEST', requestId, payload);
          window.parent.postMessage({ type: 'AI_MODAL_OPEN_REQUEST', requestId: requestId, payload: payload }, '*');
        } catch (e) {
          clearTimeout(timeoutT);
          window.removeEventListener('message', onMessage);
          console.error('发送 AI 请求失败', e);
          showError('发送 AI 请求失败: ' + e.message);
        }

      } catch (e) {
        console.error('AI扩写出错:', e);
        showError('AI扩写出错: ' + e.message);
      }
    }

    // 隐藏/显示浮动面板的 API（供 showNodeDetails 调用）
    function hideNodeDetails() {
      const p = document.getElementById('nodeDetails');
      if (p) {
        p.style.display = 'none';
        p.setAttribute('aria-hidden', 'true');
        // 安全移除拖拽监听（若在闭包中定义则不会抛错）
        if (typeof removeNodeDetailsDragHandlers === 'function') {
          try { removeNodeDetailsDragHandlers(); } catch (e) { /* ignore */ }
        } else if (typeof window.removeNodeDetailsDragHandlers === 'function') {
          try { window.removeNodeDetailsDragHandlers(); } catch (e) { /* ignore */ }
        }
      }
      // 同步关闭“详情面板”开关，直到用户手动再开启
      try {
        window.__nodeDetailsEnabled = false;
        const cb = document.getElementById('toggleNodeDetailsCheckbox');
        if (cb) {
          cb.checked = false;
          cb.setAttribute('aria-checked', 'false');
        }
        const btn = document.getElementById('toggleNodeDetailsBtn');
        if (btn) {
          btn.classList.remove('state-on');
          btn.classList.remove('state-default');
          btn.classList.add('state-off');
          btn.setAttribute('aria-pressed', 'false');
        }
      } catch (e) { /* ignore */ }
    }
    function showNodeDetailsPanel() {
      const p = document.getElementById('nodeDetails');
      if (p) {
        p.style.display = 'block';
        p.setAttribute('aria-hidden', 'false');
        // 仅当面板未被用户移动过时，才重置为默认靠右位置
        if (p.dataset.moved !== 'true') {
          p.style.right = '12px';
          p.style.left = 'auto';
          p.style.top = '80px';
        }
        // 初始化拖拽监听（幂等）
        try {
          if (typeof initNodeDetailsDragHandlers === 'function') {
            initNodeDetailsDragHandlers();
          } else if (typeof window.initNodeDetailsDragHandlers === 'function') {
            window.initNodeDetailsDragHandlers();
          }
        } catch (e) { /* ignore */ }
      }
    }

    /* 打开详情面板并提示“请选择一个节点” */
    function showEmptyDetailsPrompt() {
      try {
        if (window.__nodeDetailsEnabled === false) {
          try { console.log('[MW][details][UI] skip empty: toggle disabled'); } catch (e) { }
          return;
        }
        // 确保面板可见
        try { showNodeDetailsPanel(); } catch (e) { try { console.warn('[MW][details][UI] showNodeDetailsPanel failed', e); } catch (ee) { } }
        var panel = document.getElementById('nodeDetails');
        var empty = document.getElementById('nodeDetailsEmpty');
        var form = document.getElementById('nodeDetailsForm');
        var info = document.getElementById('nodeInfo');
        var topic = document.getElementById('nodeTopic');
        var notes = document.getElementById('nodeNotes');

        // 切换为空状态：显示空视图，隐藏表单
        if (empty) empty.style.display = 'block';
        if (form) form.style.display = 'none';

        if (topic) topic.value = '';
        if (notes) notes.value = '';

        // 关键日志：输出各元素与可见性
        try {
          console.log('[MW][details][UI] showEmptyDetailsPrompt:',
            {
              panelExists: !!panel,
              panelDisplay: panel && panel.style ? panel.style.display : undefined,
              panelAriaHidden: panel ? panel.getAttribute('aria-hidden') : undefined,
              emptyExists: !!empty,
              emptyDisplay: empty && empty.style ? empty.style.display : undefined,
              formExists: !!form,
              formDisplay: form && form.style ? form.style.display : undefined
            }
          );
        } catch (e) { }
      } catch (e) {
        try { console.warn('[MW][details][UI] showEmptyDetailsPrompt error', e); } catch (ee) { }
      }
    }

    try { window.showEmptyDetailsPrompt = showEmptyDetailsPrompt; } catch (e) { /* ignore */ }
    // 缩放中心修正：在鼠标/触摸位置设置 transform-origin，配合现有库缩放以该点为中心
    (function setupZoomOrigin() {
      const container = document.getElementById('fullScreenMindmap');
      if (!container) return;
      function setOrigin(clientX, clientY) {
        const rect = container.getBoundingClientRect();
        const x = clientX - rect.left;
        const y = clientY - rect.top;
        container.style.transformOrigin = `${x}px ${y}px`;
      }
      // 鼠标滚轮：在缩放前设置 origin
      container.addEventListener('wheel', function (e) {
        if (e.ctrlKey || e.metaKey || e.shiftKey || e.altKey) {
          // 若用户同时按键，仍支持，但优先设置 origin
        }
        setOrigin(e.clientX, e.clientY);
        // 不阻止原生滚动/缩放逻辑，让现有库处理实际缩放
      }, { passive: true });
      // 触摸：记录触摸点以设置 origin（用于双指缩放前）
      container.addEventListener('touchstart', function (e) {
        if (!e.touches || e.touches.length === 0) return;
        const t = e.touches[0];
        setOrigin(t.clientX, t.clientY);
      }, { passive: true });
    })();


    /* 拖拽支持：鼠标与触摸 */
    (function () {
      let dragging = false;
      let startX = 0, startY = 0;
      let origLeft = 0, origTop = 0;
      let handlersAdded = false;



      function onPointerDown(e) {
        const p = document.getElementById('nodeDetails');
        if (!p) return;
        dragging = true;
        p.style.transition = 'none';
        const rect = p.getBoundingClientRect();
        origLeft = rect.left;
        origTop = rect.top;
        if (e.type === 'touchstart') {
          startX = e.touches[0].clientX;
          startY = e.touches[0].clientY;
        } else {
          startX = e.clientX;
          startY = e.clientY;
        }
        // prevent iframe text selection during drag
        document.body.style.userSelect = 'none';
      }

      function onPointerMove(e) {
        if (!dragging) return;
        const p = document.getElementById('nodeDetails');
        if (!p) return;
        let cx = (e.type === 'touchmove') ? e.touches[0].clientX : e.clientX;
        let cy = (e.type === 'touchmove') ? e.touches[0].clientY : e.clientY;
        const dx = cx - startX;
        const dy = cy - startY;
        const left = origLeft + dx;
        const top = origTop + dy;
        // 限制到视口内
        const vw = Math.max(document.documentElement.clientWidth || 0, window.innerWidth || 0);
        const vh = Math.max(document.documentElement.clientHeight || 0, window.innerHeight || 0);
        const rect = p.getBoundingClientRect();
        const w = rect.width, h = rect.height;
        const minLeft = 8;
        const maxLeft = vw - w - 8;
        const minTop = 8;
        const maxTop = vh - h - 8;
        const nx = Math.min(Math.max(left, minLeft), Math.max(minLeft, maxLeft));
        const ny = Math.min(Math.max(top, minTop), Math.max(minTop, maxTop));
        // 记录临时位移量，onPointerUp 会基于此判断是否标记为已移动
        try {
          p.dataset._dragMovedX = String(dx);
          p.dataset._dragMovedY = String(dy);
        } catch (e) { /* ignore */ }
        p.style.right = 'auto';
        p.style.left = nx + 'px';
        p.style.top = ny + 'px';
      }

      function onPointerUp() {
        if (!dragging) return;
        dragging = false;
        document.body.style.userSelect = '';
        const p = document.getElementById('nodeDetails');
        if (p) p.style.transition = '';
        // 标记是否发生过显著位移，页面未刷新前保持位置
        try {
          if (p) {
            const movedX = parseFloat(p.dataset._dragMovedX || '0');
            const movedY = parseFloat(p.dataset._dragMovedY || '0');
            if (Math.abs(movedX) > 2 || Math.abs(movedY) > 2) {
              p.dataset.moved = 'true';
            }
            delete p.dataset._dragMovedX;
            delete p.dataset._dragMovedY;
          }
        } catch (e) { /* ignore */ }
      }

      function initNodeDetailsDragHandlers() {
        if (handlersAdded) return;
        const p = document.getElementById('nodeDetails');
        if (!p) return;
        // 使用 panel-header 作为抓手，如无则全面板可拖
        const handle = p.querySelector('.panel-header') || p;
        handle.addEventListener('mousedown', onPointerDown, { passive: true });
        window.addEventListener('mousemove', onPointerMove, { passive: true });
        window.addEventListener('mouseup', onPointerUp, { passive: true });
        handle.addEventListener('touchstart', onPointerDown, { passive: true });
        window.addEventListener('touchmove', onPointerMove, { passive: true });
        window.addEventListener('touchend', onPointerUp, { passive: true });
        handlersAdded = true;
      }



      // 如果面板已显示，初始化一次
      document.addEventListener('DOMContentLoaded', function () {
        const p = document.getElementById('nodeDetails');
        if (p && p.style.display !== 'none') initNodeDetailsDragHandlers();
      });
      // 在窗口大小变化时微调位置，避免超出
      window.addEventListener('resize', function () {
        const p = document.getElementById('nodeDetails');
        if (!p || p.style.display === 'none') return;
        const rect = p.getBoundingClientRect();
        const vw = Math.max(document.documentElement.clientWidth || 0, window.innerWidth || 0);
        const vh = Math.max(document.documentElement.clientHeight || 0, window.innerHeight || 0);
        const maxLeft = Math.max(8, vw - rect.width - 8);
        const maxTop = Math.max(8, vh - rect.height - 8);
        let left = rect.left;
        let top = rect.top;
        if (left > maxLeft) left = maxLeft;
        if (top > maxTop) top = maxTop;
        p.style.left = left + 'px';
        p.style.top = top + 'px';
      });

    })();


    // --- extracted block from original HTML ---
    (function () {
      // 节点详情开关（默认开启）
      window.__nodeDetailsEnabled = (window.__nodeDetailsEnabled === undefined) ? true : !!window.__nodeDetailsEnabled;

      function updateToggleUI() {
        var enabled = !!window.__nodeDetailsEnabled;
        // 复选框（兼容保留）
        var cb = document.getElementById('toggleNodeDetailsCheckbox');
        if (cb) {
          cb.checked = enabled;
          cb.setAttribute('aria-checked', enabled ? 'true' : 'false');
        }
        // 图标按钮（新）
        var btn = document.getElementById('toggleNodeDetailsBtn');
        if (btn) {
          btn.classList.remove('state-on', 'state-off', 'state-default');
          btn.classList.add(enabled ? 'state-on' : 'state-off');
          btn.setAttribute('aria-pressed', enabled ? 'true' : 'false');
        }
      }

      // 切换处理：启用时若存在选中节点立即显示详情；禁用时隐藏面板并阻止后续弹出
      function handleToggleChange(checked) {
        window.__nodeDetailsEnabled = !!checked;
        if (!window.__nodeDetailsEnabled) {
          if (typeof hideNodeDetails === 'function') {
            try { hideNodeDetails(); } catch (e) { /* ignore */ }
          }
        } else {
          // 启用时：若有选中节点，立即显示其详情；否则打开面板并提示“请选择一个节点”
          try {
            var sel = null;
            if (window.jm && typeof window.jm.get_selected_node === 'function') {
              sel = window.jm.get_selected_node();
            }
            if (sel) {
              try { showNodeDetails(sel); } catch (e) { /* ignore */ }
            } else {
              // 无选中节点：打开面板并显示空状态
              try { showEmptyDetailsPrompt(); } catch (e) { /* ignore */ }
            }
          } catch (e) { /* ignore */ }
        }
        updateToggleUI();
      }

      // 挂载事件
      document.addEventListener('DOMContentLoaded', function () {
        // 初始化 UI（无论是否有复选框或按钮）
        updateToggleUI();

        // 复选框（兼容）
        var cb = document.getElementById('toggleNodeDetailsCheckbox');
        if (cb) {
          cb.addEventListener('change', function (e) {
            handleToggleChange(!!e.target.checked);
          }, { passive: true });
          cb.addEventListener('keydown', function (e) {
            if (e.key === ' ' || e.key === 'Enter') {
              setTimeout(function () { handleToggleChange(!!cb.checked); }, 0);
            }
          });
        }

        // 图标按钮（新）
        var btn = document.getElementById('toggleNodeDetailsBtn');
        if (btn) {
          btn.addEventListener('click', function () {
            handleToggleChange(!window.__nodeDetailsEnabled);
          });
          btn.addEventListener('keydown', function (e) {
            if (e.key === 'Enter' || e.key === ' ') {
              e.preventDefault();
              handleToggleChange(!window.__nodeDetailsEnabled);
            }
          });
        }
      });

      // 包装 showNodeDetails：若开关关闭则静默返回
      if (typeof window.showNodeDetails === 'function') {
        var _origShowNodeDetails = window.showNodeDetails;
        window.showNodeDetails = function (node) {
          if (window.__nodeDetailsEnabled === false) return;
          return _origShowNodeDetails.apply(this, arguments);
        };
      } else {
        // 若函数尚未定义，延迟包装（在后续定义时检测）
        var _tryWrap = function () {
          if (typeof window.showNodeDetails === 'function') {
            var _orig = window.showNodeDetails;
            window.showNodeDetails = function (node) {
              if (window.__nodeDetailsEnabled === false) return;
              return _orig.apply(this, arguments);
            };
            clearInterval(_tryWrapInterval);
          }
        };
        var _tryWrapInterval = setInterval(_tryWrap, 200);
      }
    })();


    // --- extracted block from original HTML ---
    (function mw_post_init_fix() {
      try {
        function isMobileNow() {
          var isSmallScreen = (window.matchMedia && window.matchMedia('(max-width: 768px)').matches);
          var hasTouch = ('ontouchstart' in window) || (navigator.maxTouchPoints && navigator.maxTouchPoints > 0);
          return isSmallScreen || (hasTouch && window.innerWidth <= 900);
        }

        function relocateBatchOpsIfNeeded() {
          try {
            var isMobile = isMobileNow();
            var batch = document.getElementById('batchOperations');
            var mw = document.getElementById('mw-batchops');
            if (!batch || !mw) return;
            if (!isMobile) {
              // copy count
              var sc = batch.querySelector('#selectedCount');
              var scVal = sc ? sc.textContent : '0';
              var targetStrong = mw.querySelector('#selectedCountDisplay');
              if (targetStrong) targetStrong.textContent = scVal;
              batch.style.display = 'none';
              mw.style.display = 'inline-flex';
              // keep references
              window.__mw_batch_source = batch;
              window.__mw_batch_target = mw;
            } else {
              batch.style.display = 'none';
              if (mw) mw.style.display = 'none';
            }
          } catch (e) { console.warn('[MW] relocateBatchOpsIfNeeded failed', e); }
        }

        function ensureDetailsToggleVisibleOnDesktop() {
          try {
            var cbDetails = document.getElementById('toggleNodeDetailsCheckbox');
            if (!cbDetails) return;
            var label = cbDetails.parentElement;
            if (!label) return;
            if (!isMobileNow()) {
              label.style.display = ''; // restore default
            }
          } catch (e) { /* ignore */ }
        }

        // sync selected count periodically (small cost, robust)
        function startSelectedCountSync() {
          try {
            var source = document.getElementById('batchOperations');
            var target = document.getElementById('mw-batchops');
            if (!source || !target) return;
            var sSrc = source.querySelector('#selectedCount');
            var sTgt = target.querySelector('#selectedCountDisplay');
            if (!sSrc || !sTgt) return;
            var last = null;
            setInterval(function () {
              try {
                var now = sSrc.textContent || sSrc.innerText || '0';
                if (now !== last) {
                  last = now;
                  sTgt.textContent = now;
                }
              } catch (e) { }
            }, 250);
          } catch (e) { /* ignore */ }
        }

        // run on load and on resize/orientationchange
        function boot() {
          relocateBatchOpsIfNeeded();
          ensureDetailsToggleVisibleOnDesktop();
          startSelectedCountSync();
        }

        if (document.readyState === 'complete' || document.readyState === 'interactive') {
          setTimeout(boot, 50);
        } else {
          document.addEventListener('DOMContentLoaded', function () { setTimeout(boot, 50); });
          window.addEventListener('load', function () { setTimeout(boot, 50); });
        }
        window.addEventListener('resize', function () { setTimeout(relocateBatchOpsIfNeeded, 60); });
        window.addEventListener('orientationchange', function () { setTimeout(relocateBatchOpsIfNeeded, 60); });
      } catch (e) {
        console.error('[MW] post init fix error', e);
      }
    })();


    // toolbar 图标选择器初始化 —— 更稳健的实现：使用 textContent、等待 availableIcons 与 jm 就绪
    (function () {
      function createToolbarIconGrid() {
        var grid = document.getElementById('iconGridToolbar');
        if (!grid) return;
        grid.innerHTML = '';

        // 首位为清除图标按钮（网格内唯一的清除）
        var clearBtn = document.createElement('button');
        clearBtn.type = 'button';
        clearBtn.className = 'icon-picker-item';
        clearBtn.title = '清除图标';
        clearBtn.style.cssText = 'alpha:0.3;width:40px;height:40px;border:1px dashed #ddd;color:#dbdbdb !important;border-radius:4px;background:#fff;cursor:pointer;font-size:18px;display:flex;align-items:center;justify-content:center;';
        clearBtn.textContent = '🚫';
        clearBtn.onclick = function (e) { e.stopPropagation(); clearIconFromToolbar(); };
        grid.appendChild(clearBtn);

        // 如果 MWIcons.getGroups 可用，按组渲染（带分组标题）
        var groups = (window.MWIcons && typeof window.MWIcons.getGroups === 'function') ? window.MWIcons.getGroups() : null;

        if (groups && Object.keys(groups).length > 0) {
          // 创建分组容器
          Object.keys(groups).forEach(function (groupKey) {
            var group = groups[groupKey];
            // 分组标题
            var header = document.createElement('div');
            header.style.cssText = 'grid-column: 1 / -1; font-size:12px; font-weight:600; color:#333; padding:6px 0 4px 0;';
            header.textContent = (groupKey.charAt(0).toUpperCase() + groupKey.slice(1));
            grid.appendChild(header);

            // 分组图标网格（7列内使用相同样式）
            group.forEach(function (icon) {
              var btn = document.createElement('button');
              btn.type = 'button';
              btn.className = 'icon-picker-item';
              btn.title = icon.name || '';
              btn.style.cssText = 'width:40px;height:40px;border:1px solid #ddd;border-radius:4px;background:white;cursor:pointer;font-size:20px;display:flex;align-items:center;justify-content:center;';
              btn.textContent = icon.emoji || '';
              btn.onclick = function (ev) {
                ev.stopPropagation();
                applyIconToSelection(icon.emoji);
                try { $('#iconPickerDropdown .dropdown-toggle').dropdown('toggle'); } catch (e) { }
              };
              btn.onmouseover = function () { btn.style.background = '#f0f0f0'; };
              btn.onmouseout = function () { btn.style.background = 'white'; };
              grid.appendChild(btn);
            });
          });
          return;
        }

        // 兼容回退：扁平化 window.availableIcons 或全局 availableIcons
        var icons = (window.availableIcons && window.availableIcons.length) ? window.availableIcons
          : (typeof availableIcons !== 'undefined' && availableIcons && availableIcons.length) ? availableIcons
            : [];
        if (!icons || icons.length === 0) {
          // 显示占位提示（用户看到不会空白）
          var ph = document.createElement('div');
          ph.style.cssText = 'grid-column: 1 / -1; color:#6c757d; font-size:12px; padding:6px; text-align:center;';
          ph.textContent = '图标库加载中...';
          grid.appendChild(ph);
          return;
        }

        icons.forEach(function (icon) {
          var btn = document.createElement('button');
          btn.type = 'button';
          btn.className = 'icon-picker-item';
          btn.title = icon.name || '';
          btn.style.cssText = 'width:40px;height:40px;border:1px solid #ddd;border-radius:4px;background:white;cursor:pointer;font-size:20px;display:flex;align-items:center;justify-content:center;';
          btn.textContent = icon.emoji || '';
          btn.onclick = function (ev) {
            ev.stopPropagation();
            applyIconToSelection(icon.emoji);
            // 关闭 dropdown（Bootstrap）
            try { $('#iconPickerDropdown .dropdown-toggle').dropdown('toggle'); } catch (e) { }
          };
          btn.onmouseover = function () { btn.style.background = '#f0f0f0'; };
          btn.onmouseout = function () { btn.style.background = 'white'; };
          grid.appendChild(btn);
        });
      }

      // 安全的初始化：如果 availableIcons 尚未就绪，重复尝试几次
      function initWithRetry(attemptsLeft) {
        try {
          if ((window.availableIcons && window.availableIcons.length > 0) || (typeof availableIcons !== 'undefined' && availableIcons && availableIcons.length > 0) || attemptsLeft <= 0) {
            createToolbarIconGrid();
            return;
          }
        } catch (e) { /* ignore */ }

        setTimeout(function () { initWithRetry(attemptsLeft - 1); }, 120);
      }

      // 将 emoji 应用到当前选中节点（支持多选）
      function applyIconToSelection(emoji) {
        if (!window.jm) {
          console.warn('jm 未初始化，无法应用图标');
          return;
        }

        // 获取多选（框选）或单选
        var ids = [];
        try {
          if (typeof window.getMultiSelection === 'function') {
            ids = window.getMultiSelection() || [];
          }
        } catch (e) { ids = []; }

        // 若无多选，则尝试用 jm.get_selected_node（单选）
        if (!ids || ids.length === 0) {
          try {
            var sel = jm.get_selected_node && jm.get_selected_node();
            if (sel) {
              var selId = (typeof sel === 'string') ? sel : (sel.id || null);
              if (selId) ids = [selId];
            }
          } catch (e) { }
        }

        if (!ids || ids.length === 0) {
          showWarning && showWarning('请先选中 1 个或多个节点');
          return;
        }

        // 对每个节点的 topic 前面插入 emoji（若已存在表情则替换）
        // 使用宽松的 emoji 去除正则（兼容性差时也能工作）
        var emojiStrip = /^[^\w\u4e00-\u9fff\s]+/u;
        ids.forEach(function (id) {
          try {
            var node = jm.get_node(id);
            if (!node) return;
            var topic = node.topic || '';
            // 移除开头的非字母数字与非中文字符（多半是 emoji 或符号）
            topic = topic.replace(emojiStrip, '').trim();
            var newTopic = (emoji ? (emoji + ' ' + topic) : topic);
            jm.update_node(node.id, newTopic);
          } catch (e) {
            console.warn('应用图标失败', e);
          }
        });

        // 保存并提示
        try { if (typeof debouncedSave === 'function') debouncedSave(); } catch (e) { }
        try { showSuccess && showSuccess('已应用图标'); } catch (e) { }
      }

      // 从选中节点清除图标（相当于 applyIconToSelection('')）
      window.clearIconFromToolbar = function () {
        if (!window.jm) return;
        var ids = [];
        try {
          if (typeof window.getMultiSelection === 'function') ids = window.getMultiSelection() || [];
        } catch (e) { ids = []; }
        if (!ids || ids.length === 0) {
          try {
            var sel = jm.get_selected_node && jm.get_selected_node();
            if (sel) {
              var selId = (typeof sel === 'string') ? sel : (sel.id || null);
              if (selId) ids = [selId];
            }
          } catch (e) { }
        }
        if (!ids || ids.length === 0) {
          showWarning && showWarning('请先选中 节点');
          return;
        }

        var emojiStrip = /^[^\w\u4e00-\u9fff\s]+/u;
        ids.forEach(function (id) {
          try {
            var node = jm.get_node(id);
            if (!node) return;
            var topic = node.topic || '';
            topic = topic.replace(emojiStrip, '').trim();
            jm.update_node(node.id, topic);
          } catch (e) { console.warn('清除图标失败', e); }
        });
        try { if (typeof debouncedSave === 'function') debouncedSave(); } catch (e) { }
        try { showSuccess && showSuccess('已清除图标'); } catch (e) { }
      };

      // 初始化入口：最多重试 8 次（每次 120ms）
      if (document.readyState === 'complete' || document.readyState === 'interactive') {
        setTimeout(function () { initWithRetry(8); }, 120);
      } else {
        document.addEventListener('DOMContentLoaded', function () { setTimeout(function () { initWithRetry(8); }, 120); });
      }

      // 在 jm 初始化后再执行一次，防止 race
      window.MW_scheduleOnce && window.MW_scheduleOnce('initToolbarIconGrid', function () {
        initWithRetry(4);
      }, 300);
    })();
  </script>

</body>

</html>
</body>

</html>