<!--
 * MindWord - æ ‘å¿ƒ | åƒç”»å›¾ä¸€æ ·å†™æ–‡æ¡£çš„æ€ç»´å¯¼å›¾å†™ä½œå·¥å…·
 * GitHub: https://github.com/TimiKays/MindWord
 * 
 * Copyright 2025 Timi Kays
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
-->

<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Markdown ç¼–è¾‘å™¨</title>
    <link rel="stylesheet" href="../styles.css">
    <!-- Bootstrap CSS for notifications -->
    <link href="/local-deps/bootstrap.min.css" rel="stylesheet">
    <!-- HTMLè½¬Markdownå·¥å…·åº“ -->
    <script src="../utils/html-to-markdown.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background-color: #f8f9fa;
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* ä¿ç•™æ–‡ä»¶è¾“å…¥æ¡†æ ·å¼ */
        .file-input {
            display: none;
        }

        /* ä¸»è¦å†…å®¹åŒºåŸŸ */
        .edit-content {
            flex: 1;
            display: flex;
            overflow: hidden;
            position: relative;
        }

        /* ç¼–è¾‘å™¨å®¹å™¨ */
        .editor-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            background-color: #fff;
            border-right: 1px solid #e1e5e9;
            height: 100%;
            /* ç¡®ä¿å æ»¡çˆ¶å®¹å™¨é«˜åº¦ */
            min-height: 0;
            /* å…è®¸ flex å­å…ƒç´ æ­£ç¡®æ”¶ç¼©/æ‰©å±• */
        }

        .editor-header {
            background-color: #f8f9fa;
            padding: 12px 16px;
            border-bottom: 1px solid #e1e5e9;
            font-weight: 500;
            color: #495057;
        }

        .editor {
            flex: 1;
            display: block;
            min-height: 0;
            height: 100%;
            border: none;
            outline: none;
            padding: 20px;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 14px;
            line-height: 1.6;
            resize: none;
            background-color: #fff;
            color: #333;
            /* Firefox æ»šåŠ¨æ¡æ ·å¼ - ç¾è§‚ä¼˜åŒ–ï¼šä¸åŠ¨æ—¶éšè—å˜å°å˜ç»† */
            scrollbar-width: thin;
            scrollbar-color: transparent transparent;
            transition: scrollbar-color 0.3s ease;
        }

        .editor:hover,
        .editor.scrolling {
            scrollbar-color: rgba(193, 193, 193, 0.6) transparent;
        }

        /* WebKit æ»šåŠ¨æ¡æ ·å¼ä¼˜åŒ– */
        .editor::-webkit-scrollbar {
            width: 3px;
            height: 3px;
            transition: width 0.3s ease, height 0.3s ease;
        }

        .editor::-webkit-scrollbar-track {
            background: transparent;
            border-radius: 2px;
        }

        .editor::-webkit-scrollbar-thumb {
            background: transparent;
            border-radius: 2px;
            transition: background 0.3s ease, width 0.3s ease, height 0.3s ease;
        }

        /* æ‚¬åœæˆ–æ»šåŠ¨æ—¶æ˜¾ç¤ºæ»šåŠ¨æ¡ */
        .editor:hover::-webkit-scrollbar,
        .editor.scrolling::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        .editor:hover::-webkit-scrollbar-thumb,
        .editor.scrolling::-webkit-scrollbar-thumb {
            background: rgba(193, 193, 193, 0.6);
        }

        .editor:hover::-webkit-scrollbar-thumb:hover,
        .editor.scrolling::-webkit-scrollbar-thumb:hover {
            background: rgba(168, 168, 168, 0.8);
        }

        .editor:focus {
            box-shadow: inset 0 0 0 2px #3b82f6;
        }

        /* å¸®åŠ©é¢æ¿ */
        .help-panel {
            position: absolute;
            top: 0;
            right: 0;
            width: 350px;
            height: 100%;
            background-color: #fff;
            border-left: 1px solid #e1e5e9;
            box-shadow: -2px 0 8px rgba(0, 0, 0, 0.1);
            z-index: 200;
            transform: translateX(100%);
            transition: transform 0.3s ease;
            display: flex;
            flex-direction: column;
        }

        .help-panel.open {
            transform: translateX(0);
        }

        .help-header {
            background-color: #a7cae7;
            color: rgb(255, 255, 255);
            padding: 8px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            font-weight: 500;
        }

        .help-close {
            background: none;
            border: none;
            color: white;
            cursor: pointer;
            font-size: 18px;
            padding: 4px;
            border-radius: 4px;
        }

        .help-close:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }

        .help-content {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
            font-size: 14px;
            line-height: 1.6;
            /* Firefox æ»šåŠ¨æ¡æ ·å¼ - ç¾è§‚ä¼˜åŒ–ï¼šä¸åŠ¨æ—¶éšè—å˜å°å˜ç»† */
            scrollbar-width: thin;
            scrollbar-color: transparent transparent;
            transition: scrollbar-color 0.3s ease;
        }

        .help-content:hover,
        .help-content.scrolling {
            scrollbar-color: rgba(193, 193, 193, 0.6) transparent;
        }

        /* WebKit æ»šåŠ¨æ¡æ ·å¼ä¼˜åŒ– */
        .help-content::-webkit-scrollbar {
            width: 3px;
            height: 3px;
            transition: width 0.3s ease, height 0.3s ease;
        }

        .help-content::-webkit-scrollbar-track {
            background: transparent;
            border-radius: 2px;
        }

        .help-content::-webkit-scrollbar-thumb {
            background: transparent;
            border-radius: 2px;
            transition: background 0.3s ease, width 0.3s ease, height 0.3s ease;
        }

        /* æ‚¬åœæˆ–æ»šåŠ¨æ—¶æ˜¾ç¤ºæ»šåŠ¨æ¡ */
        .help-content:hover::-webkit-scrollbar,
        .help-content.scrolling::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        .help-content:hover::-webkit-scrollbar-thumb,
        .help-content.scrolling::-webkit-scrollbar-thumb {
            background: rgba(193, 193, 193, 0.6);
        }

        .help-content:hover::-webkit-scrollbar-thumb:hover,
        .help-content.scrolling::-webkit-scrollbar-thumb:hover {
            background: rgba(168, 168, 168, 0.8);
        }

        .help-section {
            margin-bottom: 24px;
        }

        .help-section h3 {
            color: #374151;
            margin-bottom: 12px;
            font-size: 16px;
            border-bottom: 2px solid #e5e7eb;
            padding-bottom: 6px;
        }

        .help-section p {
            color: #6b7280;
            margin-bottom: 8px;
        }

        .help-section code {
            background-color: #f3f4f6;
            padding: 2px 6px;
            border-radius: 4px;
            font-family: 'Monaco', 'Menlo', monospace;
            font-size: 13px;
            color: #dc2626;
        }

        .help-list {
            list-style: none;
            margin: 8px 0;
        }

        .help-list li {
            padding: 4px 0;
            color: #4b5563;
        }

        .help-list li::before {
            content: "â€¢";
            color: #6366f1;
            font-weight: bold;
            margin-right: 8px;
        }



        /* æ¨¡æ€æ¡† */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
        }

        .modal.show {
            opacity: 1;
            visibility: visible;
        }

        .modal-content {
            background-color: #fff;
            border-radius: 12px;
            padding: 24px;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
            transform: scale(0.9);
            transition: transform 0.3s ease;
        }

        .modal.show .modal-content {
            transform: scale(1);
        }

        .modal-header {
            margin-bottom: 16px;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .modal-title {
            font-size: 18px;
            font-weight: 600;
            color: #374151;
        }

        .modal-close {
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: #6b7280;
            padding: 4px;
        }

        .modal-close:hover {
            color: #374151;
        }

        .json-content {
            background-color: #f3f4f6;
            border: 1px solid #d1d5db;
            border-radius: 8px;
            padding: 16px;
            font-family: 'Monaco', 'Menlo', monospace;
            font-size: 13px;
            line-height: 1.5;
            white-space: pre-wrap;
            max-height: 400px;
            overflow-y: auto;
            color: #374151;
        }

        /* æ‹–æ‹½ä¸Šä¼ æ•ˆæœ - ç¼–è¾‘å™¨ç‰¹æœ‰ */
        .editor.dragover {
            background-color: #eff6ff;
            border: 2px dashed #3b82f6;
        }
    </style>

</head>

<body>
    <!-- å·¥å…·æ  -->
    <div class="toolbar">
        <!-- <button class="ico-btn" id="export-btn" title="å¯¼å‡º" aria-label="å¯¼å‡º">
            <img src="../res/download.svg" alt="å¯¼å‡º" />
        </button> -->
        <span id="export-btn" class="ico-btn" role="button" tabindex="0" title="å¯¼å‡º"
            style="--ico: url('res/download.svg'); "></span>

        <span id="upload-btn" class="ico-btn" role="button" tabindex="0" title="ä¸Šä¼ "
            style="--ico: url('res/upload.svg'); "></span>

        <span id="help-btn" class="ico-btn" role="button" tabindex="0" title="å¸®åŠ©"
            style="--ico: url('res/help.svg'); "></span>




        <style>
            /* ==== Editor: help button è°ƒæ•´ï¼Œç§»é™¤æŒ‰é’®èƒŒæ™¯é¿å… svg ä¸æŒ‰é’®èƒŒæ™¯å å±‚ ==== */
            .toolbar .help-btn {
                background: transparent !important;
                border: none !important;
                padding: 0 !important;
                width: 40px;
                height: 40px;
                display: inline-flex;
                align-items: center;
                justify-content: center;
                border-radius: 50%;
                box-shadow: none !important;
            }

            .toolbar .help-btn .help-svg {
                width: 28px;
                height: 28px;
                display: block;
                pointer-events: none;
                /* é¿å… svg æœ¬èº«æ¥ç®¡ hover å¯¼è‡´é¢å¤–æ•ˆæœ */
            }

            /* ç§»é™¤æ‰€æœ‰äº¤äº’çŠ¶æ€ä¸‹å¯èƒ½çš„èƒŒæ™¯/è¾¹æ¡†/é˜´å½±ï¼Œç¡®ä¿å•å±‚è§†è§‰ */
            .toolbar .help-btn:hover,
            .toolbar .help-btn:focus,
            .toolbar .help-btn:active {
                background: transparent !important;
                box-shadow: none !important;
                outline: none !important;
            }

            /* é˜²æ­¢çˆ¶çº§æ ·å¼é€šè¿‡ outline/shadow é€ æˆäºŒæ¬¡è§†è§‰ï¼ˆæ›´é«˜ä¼˜å…ˆçº§ï¼‰ */
            .toolbar .help-btn::before,
            .toolbar .help-btn::after {
                content: none !important;
            }

            /* å°å±ç¡®ä¿åŒæ ·åœ†å½¢ä¸”ä¸è¢«æ‰©å±• */
            @media (max-width: 1020px) {
                .toolbar .help-btn {
                    width: 36px;
                    height: 36px;
                }

                .toolbar .help-btn .help-svg {
                    width: 20px;
                    height: 20px;
                }
            }
        </style>

        <input type="file" class="file-input" id="file-input" accept=".md,.zip" />
    </div>

    <!-- ä¸»å†…å®¹åŒºåŸŸ -->
    <div class="edit-content">
        <!-- ç¼–è¾‘å™¨ -->
        <div class="editor-container">
            <!-- ä¿å­˜æç¤º -->
            <div class="save-notification" id="save-notification"></div>

            <textarea class="editor" id="editor" placeholder="# æ¬¢è¿ä½¿ç”¨ MindWord

## åŠŸèƒ½ç‰¹æ€§

- å®æ—¶é¢„è§ˆ
ä¸€ä¾§ä¿®æ”¹ï¼Œå¦ä¸€ä¾§å®æ—¶é«˜äº®åŒæ­¥

- å¯¼å‡ºåŠŸèƒ½
æ‰€æœ‰æ•°æ®å‡å¯æ— æŸå¯¼å…¥å¯¼å‡º

- å›¾ç‰‡æ”¯æŒ
å¯ctrl+vç²˜è´´å›¾ç‰‡åˆ°ç¼–è¾‘å™¨ä¸­

- è‡ªåŠ¨ä¿å­˜
æ¯æ¬¡ä¿®æ”¹åç³»ç»Ÿè‡ªåŠ¨ä¿å­˜æ•°æ®åˆ°æœ¬åœ°

- AIæ‰©å†™
åŒ…å«AIæ‰©å†™å­èŠ‚ç‚¹ã€æ‰©å†™åŒçº§èŠ‚ç‚¹ã€æ‰©å†™å¤‡æ³¨ï¼ˆæ­£æ–‡æ®µè½ï¼‰ã€ç”Ÿæˆåˆå§‹æ ‘ç­‰ã€‚

## å¿«é€Ÿå¼€å§‹

è¾“å…¥ Markdown è¯­æ³•ï¼Œå³ä¾§ä¼šå®æ—¶æ˜¾ç¤ºé¢„è§ˆæ•ˆæœã€‚

### ç¤ºä¾‹

**ç²—ä½“æ–‡æœ¬** å’Œ *æ–œä½“æ–‡æœ¬*

- åˆ—è¡¨é¡¹ 1
- åˆ—è¡¨é¡¹ 2
  - å­åˆ—è¡¨é¡¹

1. æœ‰åºåˆ—è¡¨
2. ç¬¬äºŒé¡¹

``ä»£ç ç‰‡æ®µ``

> è¿™æ˜¯ä¸€ä¸ªå¼•ç”¨

### è¡¨æ ¼ç¤ºä¾‹

| åŠŸèƒ½ | çŠ¶æ€ |
|------|------|
| ç¼–è¾‘ | âœ… |
| é¢„è§ˆ | âœ… |
| å¯¼å›¾ | âœ… |

ç‚¹å‡»å³ä¸Šè§’çš„ **?** æŸ¥çœ‹å®Œæ•´å¸®åŠ©æ–‡æ¡£ã€‚"></textarea>
        </div>

        <!-- å¸®åŠ©é¢æ¿ -->
        <div class="help-panel" id="help-panel">
            <div class="help-header">
                <span>ğŸ“š å¸®åŠ©æ–‡æ¡£</span>
                <button class="help-close" id="help-close">&times;</button>
            </div>
            <div class="help-content">


                <div class="help-section">
                    <h3>ğŸ“ æ”¯æŒçš„Markdownæ ¼å¼</h3>

                    <p><strong>èŠ‚ç‚¹ç±»å‹ï¼ˆä¼šç”Ÿæˆæ€ç»´å¯¼å›¾èŠ‚ç‚¹ï¼‰ï¼š</strong></p>
                    <ul class="help-list">
                        <li><code># æ ‡é¢˜</code> - ä¸€çº§æ ‡é¢˜</li>
                        <li><code>## æ ‡é¢˜</code> - äºŒçº§æ ‡é¢˜</li>
                        <li><code>### æ ‡é¢˜</code> - ä¸‰çº§æ ‡é¢˜</li>
                        <li><code>- æ— åºåˆ—è¡¨</code> - åˆ—è¡¨é¡¹</li>
                        <li><code>1. æœ‰åºåˆ—è¡¨</code> - ç¼–å·åˆ—è¡¨</li>
                    </ul>

                    <p><strong>éèŠ‚ç‚¹æ ¼å¼ï¼ˆä¸å½±å“æ€ç»´å¯¼å›¾ï¼‰ï¼š</strong></p>
                    <ul class="help-list">
                        <li>æ™®é€šæ®µè½æ–‡æœ¬</li>
                        <li><code>**ç²—ä½“**</code> - <strong>ç²—ä½“</strong></li>
                        <li><code>*æ–œä½“*</code> - <em>æ–œä½“</em></li>
                        <li><code>`ä»£ç `</code> - <code>è¡Œå†…ä»£ç </code></li>
                        <li><code>&gt; å¼•ç”¨</code> - å¼•ç”¨å—</li>
                        <li><code>![å›¾ç‰‡](url)</code> - å›¾ç‰‡</li>
                        <li><code>[é“¾æ¥](url)</code> - è¶…é“¾æ¥</li>
                        <li>è¡¨æ ¼ã€ä»£ç å—ç­‰</li>
                    </ul>
                </div>

                <div class="help-section">
                    <h3>ğŸ–¼ï¸ å›¾ç‰‡æ”¯æŒ</h3>
                    <ul class="help-list">
                        <li>ç›´æ¥ç²˜è´´å›¾ç‰‡ï¼ˆCtrl+Vï¼‰</li>
                        <li>æ‹–æ‹½å›¾ç‰‡æ–‡ä»¶åˆ°ç¼–è¾‘å™¨</li>
                        <li>ä½¿ç”¨ Markdown è¯­æ³•æ’å…¥</li>
                        <li>å¯¼å‡ºæ—¶è‡ªåŠ¨æ‰“åŒ…æ‰€æœ‰å›¾ç‰‡</li>
                    </ul>
                </div>

                <div class="help-section">
                    <h3>ğŸ’¾ ä¿å­˜åŠŸèƒ½</h3>
                    <ul class="help-list">
                        <li>å®æ—¶è‡ªåŠ¨ä¿å­˜åˆ°æµè§ˆå™¨å­˜å‚¨</li>
                        <li>Ctrl+S æ‰‹åŠ¨ä¿å­˜</li>
                        <li>é‡æ–°æ‰“å¼€é¡µé¢è‡ªåŠ¨æ¢å¤å†…å®¹</li>
                        <li>æ”¯æŒå¯¼å‡º .md æ–‡ä»¶æˆ– .zip åŒ…</li>
                    </ul>
                </div>

                <div class="help-section">
                    <h3>ğŸ”§ è°ƒè¯•åŠŸèƒ½</h3>
                    <ul class="help-list">

                        <li>æ”¯æŒä¸Šä¼  .md æˆ– .zip æ–‡ä»¶</li>
                        <li>è‡ªåŠ¨å¤„ç†å›¾ç‰‡å¼•ç”¨å…³ç³»</li>
                    </ul>
                </div>
            </div>
        </div>
    </div>



    <!-- çŠ¶æ€æ¶ˆæ¯ -->
    <div class="status-message" id="status-message"></div>

    <script src="/local-deps/jszip.min.js"></script>
    <script>
        // ===================================
        // ğŸ¯ æ ¸å¿ƒåŠŸèƒ½ç±»
        // ===================================

        class MarkdownEditor {
            constructor() {
                this.editor = document.getElementById('editor');
                this.images = new Map(); // å­˜å‚¨å›¾ç‰‡æ•°æ®
                this.lastSaveTime = 0;
                this.saveTimeout = null;
                this.lastImageInsertTime = 0; // è®°å½•ä¸Šæ¬¡æ’å…¥å›¾ç‰‡çš„æ—¶é—´ï¼Œé¿å…é‡å¤ä¿å­˜

                this.init();
                this.loadFromStorage();
            }

            init() {
                this.bindEvents();
                // this.setupAutoSave();
                this.setupImagePaste();
                this.setupDragDrop();
                this.setupScrollbarOptimization();

                // ç›‘å¬è·¨é¡µé¢/iframe çš„ç¼“å­˜å˜åŒ–ï¼Œmarkdown æœ‰å˜æ›´åˆ™åˆ·æ–°è‡ªå·±å¹¶æ‰§è¡ŒåŒæ­¥
                window.addEventListener('storage', (e) => {
                    if (e.key === 'mindword_markdown_data') {
                        // å†·å´çª—å£ï¼šé¿å… mindmap->editor æ³¨å…¥å storage äº‹ä»¶å†æ¬¡è§¦å‘é‡å¤åŒæ­¥
                        try {
                            const now = Date.now();
                            const until = Math.max(
                                Number(localStorage.getItem('mw_sync_cooldown_until') || 0),
                                window.__mw_editor_cooldown_until || 0
                            );
                            if (now < until) {
                                // æ§åˆ¶å°æç¤ºä¸€æ¬¡ï¼Œä¾¿äºè°ƒè¯•
                                try { console.log('[EDITOR] storage ignored due to cooldown', { now, until }); } catch (e) { }
                                return;
                            }
                        } catch (e) { }
                        const newVal = e.newValue ?? '';
                        if (newVal !== this.getContent()) {
                            this.setContent(newVal);
                            window.showSuccess && window.showSuccess('å·²åŒæ­¥');
                        }
                        if (window.syncAll) {
                            try {
                                window.syncAll('markdown', true, true);
                            } catch (err) {
                                console.warn('storage è§¦å‘ syncAll å¤±è´¥:', err);
                            }
                        }
                    }
                });
            }

            // ===================================
            // ğŸ“ ç¼–è¾‘å™¨äº‹ä»¶ç»‘å®š
            // ===================================

            bindEvents() {
                // å·¥å…·æ æŒ‰é’®
                document.getElementById('export-btn').addEventListener('click', () => this.exportContent());
                document.getElementById('upload-btn').addEventListener('click', () => this.uploadFile());
                document.getElementById('help-btn').addEventListener('click', () => this.toggleHelp());
                document.getElementById('help-close').addEventListener('click', () => this.toggleHelp());

                // æ–‡ä»¶ä¸Šä¼ 
                document.getElementById('file-input').addEventListener('change', (e) => this.handleFileUpload(e));


                // é”®ç›˜å¿«æ·é”®
                document.addEventListener('keydown', (e) => this.handleKeyboard(e));

                // ç¼–è¾‘å™¨å†…å®¹å˜åŒ–
                this.editor.addEventListener('input', () => this.onContentChange());

            }

            // ===================================
            // ğŸ¨ æ»šåŠ¨æ¡ä¼˜åŒ–
            // ===================================

            setupScrollbarOptimization() {
                // ä¸ºç¼–è¾‘å™¨æ·»åŠ æ»šåŠ¨äº‹ä»¶ç›‘å¬
                if (this.editor) {
                    let scrollTimeout;
                    this.editor.addEventListener('scroll', () => {
                        this.editor.classList.add('scrolling');
                        clearTimeout(scrollTimeout);
                        scrollTimeout = setTimeout(() => {
                            this.editor.classList.remove('scrolling');
                        }, 500); // æ»šåŠ¨åœæ­¢500msåéšè—æ»šåŠ¨æ¡
                    }, { passive: true });
                }

                // ä¸ºå¸®åŠ©é¢æ¿å†…å®¹æ·»åŠ æ»šåŠ¨äº‹ä»¶ç›‘å¬
                const helpContent = document.querySelector('.help-content');
                if (helpContent) {
                    let helpScrollTimeout;
                    helpContent.addEventListener('scroll', () => {
                        helpContent.classList.add('scrolling');
                        clearTimeout(helpScrollTimeout);
                        helpScrollTimeout = setTimeout(() => {
                            helpContent.classList.remove('scrolling');
                        }, 500); // æ»šåŠ¨åœæ­¢500msåéšè—æ»šåŠ¨æ¡
                    }, { passive: true });
                }
            }

            // ===================================
            // âŒ¨ï¸ é”®ç›˜å¿«æ·é”®
            // ===================================

            handleKeyboard(e) {
                if (e.ctrlKey && e.key === 's') {
                    e.preventDefault();
                    this.saveToStorage(true);
                }

                if (e.key === 'Escape') {
                    this.hideJSON();
                }
            }

            // ===================================
            // ğŸ’¾ è‡ªåŠ¨ä¿å­˜åŠŸèƒ½
            // ===================================

            // setupAutoSave() {
            //     this.autoSaveInterval = setInterval(() => {
            //         if (this.hasUnsavedChanges()) {
            //             this.saveToStorage(false);
            //         }
            //     }, 5000); // æ¯5ç§’è‡ªåŠ¨ä¿å­˜
            // }

            onContentChange() {
                this.lastSaveTime = Date.now();

                // å¦‚æœåˆšåˆšæ’å…¥å›¾ç‰‡ï¼Œå»¶è¿Ÿç¨é•¿ä¸€ç‚¹æ—¶é—´å†ä¿å­˜ï¼Œç¡®ä¿å†…å®¹å®Œå…¨æ›´æ–°
                const timeSinceImageInsert = Date.now() - this.lastImageInsertTime;
                const delay = timeSinceImageInsert < 1000 ? 3000 : 2000; // å¦‚æœåˆšæ’å…¥å›¾ç‰‡ï¼Œå»¶è¿Ÿ3ç§’

                // é˜²æŠ–ä¿å­˜
                clearTimeout(this.saveTimeout);
                this.saveTimeout = setTimeout(() => {
                    console.log(`[editor] onContentChange triggering saveToStorage (delay: ${delay}ms)`);
                    this.saveToStorage(false);
                }, delay);

                // é€šçŸ¥å…¶ä»–çª—å£å†…å®¹å˜åŒ–
                this.broadcastChange();
            }

            hasUnsavedChanges() {
                const current = this.getContent();
                const saved = localStorage.getItem('mindword_markdown_data');
                return current !== saved;
            }

            /**
             * ä»markdownå†…å®¹ä¸­æå–æ‰€æœ‰å›¾ç‰‡å¼•ç”¨ï¼Œè¡¥å……ç¼ºå¤±çš„å›¾ç‰‡å¯¹è±¡
             */
            async extractAndSupplementImages(content) {
                const imageRegex = /!\[([^\]]*)\]\(([^)]+)\)/g;
                let match;
                let foundImageIds = [];

                while ((match = imageRegex.exec(content)) !== null) {
                    const imageName = match[1]; // å›¾ç‰‡åç§°
                    const imageId = match[2]; // å›¾ç‰‡IDæˆ–URL

                    // åªå¤„ç†æœ¬åœ°å›¾ç‰‡IDï¼ˆæ’é™¤http://, https://ç­‰å¤–éƒ¨é“¾æ¥ï¼‰
                    if (imageId && !imageId.match(/^(https?:\/\/|data:)/)) {
                        foundImageIds.push(imageId);
                        // å¦‚æœå›¾ç‰‡å·²å­˜åœ¨äºimages Mapä¸­ï¼Œè·³è¿‡å¤„ç†ï¼Œé¿å…ä¿®æ”¹ç°æœ‰æ•°æ®
                        if (this.images.has(imageId)) {
                            console.log(`[editor] å›¾ç‰‡ ${imageId} å·²å­˜åœ¨äºå†…å­˜ä¸­ï¼Œè·³è¿‡å¤„ç†`);
                            continue;
                        }

                        console.log(`[editor] å›¾ç‰‡ ${imageId} ä¸å­˜åœ¨äºå†…å­˜ä¸­ï¼Œå°è¯•ä»IndexedDBåŠ è½½`);

                        // å°è¯•ä»IndexedDBåŠ è½½å›¾ç‰‡
                        try {
                            const imageData = await window.imageStorage.getImage(imageId);
                            if (imageData && imageData.blob) {
                                // éªŒè¯å¹¶ä¿®æ­£å›¾ç‰‡ç±»å‹ï¼šæœç»text/htmlç­‰éå›¾ç‰‡ç±»å‹
                                let imageType = imageData.type;
                                if (!imageType || !imageType.startsWith('image/')) {
                                    console.warn(`[editor] ä»IndexedDBåŠ è½½çš„å›¾ç‰‡ ${imageId} ç±»å‹æ— æ•ˆ: ${imageType}ï¼Œå¼ºåˆ¶è®¾ä¸ºimage/png`);
                                    imageType = 'image/png';
                                }

                                // ä»blobè½¬æ¢å›dataUrl
                                try {
                                    const dataUrl = await window.imageStorage.blobToDataUrl(imageData.blob);
                                    if (dataUrl && dataUrl.startsWith('data:')) {
                                        this.images.set(imageId, {
                                            name: imageData.name || imageName || imageId,
                                            data: dataUrl,
                                            type: imageType
                                        });
                                        console.log(`[editor] ä»IndexedDBæˆåŠŸåŠ è½½å›¾ç‰‡: ${imageId}, type: ${imageType}`);
                                    } else {
                                        console.error(`[editor] blobToDataUrl è¿”å›æ— æ•ˆæ•°æ®: ${dataUrl ? dataUrl.substring(0, 50) + '...' : 'null/empty'}`);
                                    }
                                } catch (convertError) {
                                    console.error(`[editor] blobè½¬dataUrlå¤±è´¥ ${imageId}:`, convertError);
                                }
                            } else {
                                console.warn(`[editor] å›¾ç‰‡ ${imageId} åœ¨IndexedDBä¸­ä¹Ÿä¸å­˜åœ¨ï¼Œè·³è¿‡`);
                            }
                        } catch (e) {
                            console.warn(`[editor] ä»IndexedDBåŠ è½½å›¾ç‰‡ ${imageId} å¤±è´¥:`, e);
                        }
                    }
                }

                console.log(`[editor] extractAndSupplementImages found ${foundImageIds.length} image references:`, foundImageIds);
            }

            /**
             * æ¸…ç†æœªåœ¨Markdownå†…å®¹ä¸­å¼•ç”¨çš„å›¾ç‰‡
             */
            async cleanupUnusedImages() {
                const content = this.getContent();
                let removedCount = 0;

                // è·å–æ‰€æœ‰åœ¨Markdownä¸­è¢«å¼•ç”¨çš„å›¾ç‰‡ID
                const referencedIds = new Set();
                const imageRegex = /!\[([^\]]*)\]\(([^)]+)\)/g;
                let match;

                while ((match = imageRegex.exec(content)) !== null) {
                    const imageId = match[2]; // è·å–å›¾ç‰‡IDæˆ–URL
                    // åªå¤„ç†æœ¬åœ°å›¾ç‰‡IDï¼ˆæ’é™¤http://, https://ç­‰å¤–éƒ¨é“¾æ¥ï¼‰
                    if (imageId && !imageId.match(/^(https?:\/\/|data:)/)) {
                        referencedIds.add(imageId);
                    }
                }

                // æ¸…ç†æœ¬åœ°images Mapä¸­çš„æœªå¼•ç”¨å›¾ç‰‡
                for (const [id, data] of this.images.entries()) {
                    if (!referencedIds.has(id)) {
                        this.images.delete(id);
                        removedCount++;
                    }
                }

                if (removedCount > 0) {
                    console.log(`æ¸…ç†äº† ${removedCount} å¼ æœªä½¿ç”¨çš„æœ¬åœ°å›¾ç‰‡`);
                }

                // æ¸…ç†æ•°æ®åº“ä¸­çš„æœªå¼•ç”¨å›¾ç‰‡
                if (window.imageStorage) {
                    const activeDocId = window.__mw_activeDocId || null;
                    const dbRemovedCount = await window.imageStorage.cleanupUnusedImages(referencedIds, activeDocId);
                    if (dbRemovedCount > 0) {
                        console.log(`ä»æ•°æ®åº“ä¸­æ¸…ç†äº† ${dbRemovedCount} å¼ æœªä½¿ç”¨çš„å›¾ç‰‡`);
                    }
                }

                return removedCount;
            }



            async saveToStorage(manual = false) {
                console.log(`[editor] saveToStorage called, manual=${manual}, activeDocId=${window.__mw_activeDocId}`);

                const content = this.getContent();
                console.log(`[editor] å½“å‰å†…å®¹é•¿åº¦: ${content.length}, å›¾ç‰‡æ•°é‡: ${this.images.size}`);
                await this.extractAndSupplementImages(content);
                console.log(`[editor] extractAndSupplementImages å®Œæˆåå›¾ç‰‡æ•°é‡: ${this.images.size}`);
                await this.cleanupUnusedImages();
                console.log(`[editor] cleanupUnusedImages å®Œæˆåå›¾ç‰‡æ•°é‡: ${this.images.size}`);

                localStorage.setItem('mindword_markdown_data', content);

                // å¦‚æœæ²¡æœ‰æœ‰æ•ˆçš„æ–‡æ¡£IDï¼Œå°è¯•ä»localStorageæ¢å¤
                if (!window.__mw_activeDocId) {
                    const savedDocId = localStorage.getItem('mindword_active_doc_id');
                    if (savedDocId) {
                        window.__mw_activeDocId = savedDocId;
                        console.log(`[editor] Recovered activeDocId from localStorage for save: ${savedDocId}`);
                    } else {
                        console.warn('[editor] No active document ID, skipping image save to IndexedDB');
                        return;
                    }
                }

                // ä¿å­˜å›¾ç‰‡åˆ° IndexedDBï¼Œä¸ºæ¯ä¸ªå›¾ç‰‡æ·»åŠ å½“å‰æ–‡æ¡£ID
                const imagesWithDocId = new Map();
                const activeDocId = window.__mw_activeDocId;

                console.log(`[editor] å‡†å¤‡ä¿å­˜ ${this.images.size} å¼ å›¾ç‰‡ï¼Œæ–‡æ¡£ID: ${activeDocId}`);
                for (const [id, imageData] of this.images.entries()) {
                    console.log(`[editor] å¤„ç†å›¾ç‰‡ ${id}:`, {
                        name: imageData.name,
                        hasData: !!imageData.data,
                        dataLength: imageData.data ? imageData.data.length : 0,
                        type: imageData.type
                    });

                    imagesWithDocId.set(id, {
                        ...imageData,
                        documentId: imageData.documentId || activeDocId  // åªåœ¨å›¾ç‰‡æ²¡æœ‰documentIdæ—¶æ‰ä½¿ç”¨å½“å‰æ–‡æ¡£ID
                    });
                }

                console.log(`[editor] è°ƒç”¨ saveImages ä¿å­˜ ${imagesWithDocId.size} å¼ å›¾ç‰‡`);
                await window.imageStorage.saveImages(imagesWithDocId);
                console.log(`[editor] saveImages å®Œæˆ`);

                localStorage.setItem('mindword-save-time', Date.now().toString());

                // ä½¿ç”¨ converter çš„åŒæ­¥èƒ½åŠ›ï¼Œè”åŠ¨æ›´æ–° AST ä¸ NodeTree å¹¶å†™å…¥ç¼“å­˜
                if (window.syncAll) {
                    try {
                        window.syncAll('markdown', true, true);
                    } catch (e) {
                        console.warn('syncAll è°ƒç”¨å¤±è´¥:', e);
                    }
                }

                // ä¸»åŠ¨é€šçŸ¥çˆ¶é¡µåšè½¯åŒæ­¥ï¼ˆæ¨é€åˆ°é¢„è§ˆä¸å¯¼å›¾ï¼‰
                try { window.parent.postMessage({ type: 'editor-sync-request' }, '*'); } catch (e) { }

                // è‹¥å½“å‰ä¸ºâ€œæ¥æ”¶çˆ¶é¡µä¸‹å‘å†…å®¹â€çš„å†™å…¥é˜¶æ®µï¼ŒæŠ‘åˆ¶å›å‘ mw_document_changedï¼Œé¿å…å›å£°è¦†ç›–
                if (!window.__mw_receiving) {
                    try {
                        const activeId = window.__mw_activeDocId || null;
                        // å°† Map entries è½¬ä¸ºå¯¼å‡º/å­˜åº“é€šç”¨çš„æ•°ç»„æ ¼å¼ï¼Œä¿ç•™IDä¿¡æ¯
                        const imgList = Array.from(this.images.entries()).map(([id, data]) => ({
                            id: id,
                            name: data.name || '',
                            mime: data.type || 'image/png',
                            dataUrl: data.data || ''
                        }));
                        window.parent.postMessage({
                            type: 'mw_document_changed',
                            payload: { id: activeId, md: content, images: imgList, origin: 'editor' }
                        }, '*');
                    } catch (e) { }
                }

                if (manual) {
                    this.showMessage('âœ… æ‰‹åŠ¨ä¿å­˜æˆåŠŸ', 'success');
                } else {
                    // è‡ªåŠ¨ä¿å­˜æ—¶æ˜¾ç¤ºå°ç»¿é’©æç¤ºï¼ˆç»Ÿä¸€èµ°å…¨å±€é€šçŸ¥ï¼‰
                    if (!window.__mw_receiving) {
                        window.showSuccess && window.showSuccess('å·²è‡ªåŠ¨ä¿å­˜');
                    }
                }
            }

            async loadFromStorage() {
                const savedContent = localStorage.getItem('mindword_markdown_data');

                // ä» IndexedDB åŠ è½½å½“å‰æ–‡æ¡£çš„å›¾ç‰‡
                const activeDocId = window.__mw_activeDocId || null;
                this.images = await window.imageStorage.getImagesMap(activeDocId);
                console.log(`[editor] Loaded ${this.images.size} images from IndexedDB for document ${activeDocId}`);

                if (savedContent) {
                    this.setContent(savedContent);
                } else {
                    // å¦‚æœ localStorage æ²¡æœ‰å†…å®¹ï¼Œåˆ™å°† textarea çš„ placeholder ä½œä¸ºåˆå§‹å†…å®¹å†™å…¥ç¼–è¾‘å™¨
                    try {
                        const ta = document.getElementById('editor');
                        const placeholderText = (ta && ta.placeholder) ? ta.placeholder : '';
                        if (placeholderText) {
                            this.setContent(placeholderText);
                            try {
                                // ä¿å­˜åˆ° localStorageï¼Œé¿å…åˆ·æ–°ä¸¢å¤±ç¤ºä¾‹å†…å®¹
                                try { localStorage.setItem('mindword_markdown_data', placeholderText); } catch (e) { /* ignore */ }
                                // è§¦å‘å…¨å±€åŒæ­¥ï¼Œæ›´æ–°é¢„è§ˆä¸æ€ç»´å¯¼å›¾ï¼ˆè‹¥ syncAll å¯ç”¨ï¼‰
                                try { if (typeof window.syncAll === 'function') window.syncAll('markdown', true, true); } catch (e) { console.warn('è°ƒç”¨ syncAll æ›´æ–°è§†å›¾å¤±è´¥', e); }
                                // è§¦å‘äº‹ä»¶é€šçŸ¥å…¶ä»–æ¨¡å—ï¼ˆå¦‚ localStorage ç›‘å¬å™¨ï¼‰
                                try { window.dispatchEvent(new Event('mindwordDataUpdated')); } catch (e) { /* ignore */ }
                            } catch (e) {
                                console.warn('placeholder -> initial sync failed', e);
                            }
                        }
                    } catch (e) {
                        // å¿½ç•¥é”™è¯¯ï¼Œä¿æŒåŸæœ‰ç©ºçŠ¶æ€
                    }
                }
            }

            // ===================================
            // ğŸ–¼ï¸ å›¾ç‰‡å¤„ç†åŠŸèƒ½
            // ===================================

            setupImagePaste() {
                this.editor.addEventListener('paste', (e) => {
                    const items = e.clipboardData.items;
                    const types = e.clipboardData.types;

                    // é¦–å…ˆæ£€æŸ¥æ˜¯å¦æœ‰å›¾ç‰‡
                    let hasImage = false;
                    for (let item of items) {
                        if (item.type.indexOf('image') !== -1) {
                            e.preventDefault();
                            const file = item.getAsFile();
                            this.handleImageFile(file);
                            hasImage = true;
                            break;
                        }
                    }

                    // å¦‚æœæ²¡æœ‰å›¾ç‰‡ï¼Œæ£€æŸ¥æ˜¯å¦æœ‰å¯Œæ–‡æœ¬å†…å®¹ï¼ˆHTMLï¼‰
                    if (!hasImage) {
                        // æ£€æŸ¥æ˜¯å¦æœ‰HTMLå†…å®¹
                        const htmlData = e.clipboardData.getData('text/html');
                        if (htmlData) {
                            // æœ‰HTMLå†…å®¹ï¼Œè½¬æ¢ä¸ºMarkdown
                            e.preventDefault();
                            const markdownText = this.convertHtmlToMarkdown(htmlData);
                            this.insertAtCursor(markdownText);
                        }
                        // åªæœ‰çº¯æ–‡æœ¬ï¼Œå…è®¸é»˜è®¤å¤„ç†
                    }
                });
            }

            setupDragDrop() {
                this.editor.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    this.editor.classList.add('dragover');
                });

                this.editor.addEventListener('dragleave', (e) => {
                    e.preventDefault();
                    this.editor.classList.remove('dragover');
                });

                this.editor.addEventListener('drop', (e) => {
                    e.preventDefault();
                    this.editor.classList.remove('dragover');

                    const files = e.dataTransfer.files;
                    for (let file of files) {
                        if (file.type.startsWith('image/')) {
                            this.handleImageFile(file);
                        }
                    }
                });
            }

            async handleImageFile(file) {
                // æ£€æŸ¥æ˜¯å¦æœ‰æœ‰æ•ˆçš„æ–‡æ¡£IDï¼Œå¦‚æœæ²¡æœ‰å°è¯•ä»localStorageæ¢å¤
                if (!window.__mw_activeDocId) {
                    const savedDocId = localStorage.getItem('mindword_active_doc_id');
                    if (savedDocId) {
                        window.__mw_activeDocId = savedDocId;
                        console.log(`[editor] Recovered activeDocId from localStorage: ${savedDocId}`);
                    } else {
                        console.error('[editor] Cannot add image: no active document ID');
                        this.showMessage('âŒ æ— æ³•æ·»åŠ å›¾ç‰‡ï¼šæ²¡æœ‰æ´»åŠ¨çš„æ–‡æ¡£', 'error');
                        return;
                    }
                }

                const id = this.generateImageId();
                const reader = new FileReader();

                reader.onload = (e) => {
                    const dataUrl = e.target.result;

                    // éªŒè¯å¹¶ä¿®æ­£å›¾ç‰‡ç±»å‹ï¼šæœç»text/htmlç­‰éå›¾ç‰‡ç±»å‹
                    let imageType = file.type;
                    if (!imageType || !imageType.startsWith('image/')) {
                        console.warn(`[editor] ç²˜è´´çš„å›¾ç‰‡ç±»å‹æ— æ•ˆ: ${imageType}ï¼Œå¼ºåˆ¶è®¾ä¸ºimage/png`);
                        imageType = 'image/png';
                    }

                    console.log(`[editor] æ·»åŠ å›¾ç‰‡åˆ°å†…å­˜: id=${id}, name=${file.name}, type=${imageType}`);
                    this.images.set(id, {
                        name: file.name,
                        data: dataUrl,
                        type: imageType,
                        documentId: window.__mw_activeDocId
                    });

                    // æ’å…¥Markdownå›¾ç‰‡è¯­æ³•
                    const imageMarkdown = `![${file.name}](${id})`;
                    console.log(`[editor] æ’å…¥Markdown: ${imageMarkdown}`);
                    this.insertAtCursor(imageMarkdown);

                    // è®°å½•å›¾ç‰‡æ’å…¥æ—¶é—´ï¼Œç”¨äºonContentChangeåˆ¤æ–­
                    this.lastImageInsertTime = Date.now();

                    // æ³¨æ„ï¼šinsertAtCursorä¼šè§¦å‘onContentChangeï¼Œè¿›è€Œè‡ªåŠ¨ä¿å­˜ï¼Œè¿™é‡Œä¸éœ€è¦æ‰‹åŠ¨ä¿å­˜
                    // this.saveToStorage(false);
                    this.showMessage('ğŸ–¼ï¸ å›¾ç‰‡å·²æ·»åŠ ', 'success');
                };

                reader.readAsDataURL(file);
            }

            generateImageId() {
                return 'img_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            }

            // ä»Markdownå†…å®¹ä¸­æå–å›¾ç‰‡ID
            extractImageIdFromMarkdown(imageName) {
                if (!this.editor) return null;

                const content = this.editor.getValue();
                // åŒ¹é… ![imageName](imageId) æ ¼å¼çš„å›¾ç‰‡å¼•ç”¨
                const regex = new RegExp(`!\\[${imageName.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')}\\]\\(([^)]+)\\)`, 'g');
                const matches = [...content.matchAll(regex)];

                if (matches.length > 0) {
                    // è¿”å›ç¬¬ä¸€ä¸ªåŒ¹é…çš„å›¾ç‰‡ID
                    return matches[0][1];
                }
                return null;
            }

            insertAtCursor(text) {
                // ä½¿ç”¨å·¥å…·åº“çš„insertAtCursorå‡½æ•°ï¼Œä¿æŒç¼–è¾‘å™¨çŠ¶æ€åŒæ­¥
                HtmlMarkdownUtils.insertAtCursor(this.editor, text);

                // è§¦å‘ç¼–è¾‘å™¨ç‰¹æœ‰çš„å†…å®¹å˜åŒ–å›è°ƒ
                this.onContentChange();
            }

            // ===================================
            // ğŸ“¤ å¯¼å‡ºåŠŸèƒ½
            // ===================================

            async exportContent() {
                const content = this.getContent();
                const hasImages = this.images.size > 0;
                const fileName = this.getDocumentFileName(content);

                if (!hasImages) {
                    // åªå¯¼å‡ºMDæ–‡ä»¶
                    this.downloadFile(`${fileName}.md`, content, 'text/markdown');
                    this.showMessage('ğŸ“„ MDæ–‡ä»¶å·²å¯¼å‡º', 'success');
                } else {
                    // å¯¼å‡ºZIPåŒ…
                    await this.exportZip(content, fileName);
                    this.showMessage('ğŸ“¦ ZIPåŒ…å·²å¯¼å‡º', 'success');
                }
            }

            async exportZip(content, fileName) {
                const zip = new JSZip();

                // æ·»åŠ MDæ–‡ä»¶
                zip.file(`${fileName}.md`, content);

                // æ·»åŠ å›¾ç‰‡æ–‡ä»¶å¤¹
                const imagesFolder = zip.folder('images');

                for (let [id, imageData] of this.images) {
                    const extension = this.getImageExtension(imageData.type);
                    const filename = `${id}${extension}`;

                    // è½¬æ¢dataURLä¸ºblob
                    const base64Data = imageData.data.split(',')[1];
                    imagesFolder.file(filename, base64Data, { base64: true });
                }

                // ç”ŸæˆZIPå¹¶ä¸‹è½½
                const zipBlob = await zip.generateAsync({ type: 'blob' });
                this.downloadFile(`${fileName}.zip`, zipBlob, 'application/zip');
            }

            getImageExtension(mimeType) {
                const extensions = {
                    'image/jpeg': '.jpg',
                    'image/png': '.png',
                    'image/gif': '.gif',
                    'image/webp': '.webp',
                    'image/svg+xml': '.svg'
                };
                return extensions[mimeType] || '.png';
            }

            downloadFile(filename, content, mimeType) {
                const blob = content instanceof Blob ? content : new Blob([content], { type: mimeType });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                a.click();
                URL.revokeObjectURL(url);
            }

            // è·å–æ–‡æ¡£æ–‡ä»¶å - å¤ç”¨ app.html ä¸­çš„æ ‡é¢˜æå–å‡½æ•°
            getDocumentFileName(content) {
                try {
                    // ä¼˜å…ˆä½¿ç”¨ app.html ä¸­å·²æœ‰çš„æ ‡é¢˜æå–å‡½æ•°
                    if (typeof mw_extractTitleFromMd === 'function') {
                        const title = mw_extractTitleFromMd(content);
                        // æ¸…ç†æ–‡ä»¶åä¸­çš„ç‰¹æ®Šå­—ç¬¦
                        const cleanTitle = title.replace(/[<>:"/\\|?*\x00-\x1f]/g, '_');
                        // é™åˆ¶é•¿åº¦
                        return cleanTitle.length > 50 ? cleanTitle.substring(0, 50) : cleanTitle;
                    }

                    // å¤‡ç”¨æ–¹æ¡ˆï¼šå¦‚æœæ²¡æœ‰ mw_extractTitleFromMdï¼Œä½¿ç”¨ç®€å•å®ç°
                    const lines = content.split('\n');
                    for (let line of lines) {
                        line = line.trim();
                        if (line.startsWith('#')) {
                            let title = line.replace(/^#+\s*/, '').trim();
                            title = title.replace(/[<>:"/\\|?*\x00-\x1f]/g, '_');
                            return title.length > 50 ? title.substring(0, 50) : title;
                        }
                    }
                    return 'document';
                } catch (e) {
                    return 'document';
                }
            }

            // ===================================
            // ğŸ“ æ–‡ä»¶ä¸Šä¼ åŠŸèƒ½
            // ===================================

            uploadFile() {
                document.getElementById('file-input').click();
            }

            async handleFileUpload(e) {
                const file = e.target.files[0];
                if (!file) return;

                const loadingBtn = document.getElementById('upload-btn');
                const originalText = loadingBtn.innerHTML;
                loadingBtn.innerHTML = '<div class="loading"></div> åŠ è½½ä¸­...';
                loadingBtn.disabled = true;

                try {
                    if (file.name.endsWith('.md')) {
                        await this.loadMarkdownFile(file);
                    } else if (file.name.endsWith('.zip')) {
                        await this.loadZipFile(file);
                    } else {
                        throw new Error('ä¸æ”¯æŒçš„æ–‡ä»¶æ ¼å¼');
                    }

                    this.showMessage('ğŸ“ æ–‡ä»¶åŠ è½½æˆåŠŸ', 'success');
                } catch (error) {
                    this.showMessage(`âŒ åŠ è½½å¤±è´¥: ${error.message}`, 'error');
                } finally {
                    loadingBtn.innerHTML = originalText;
                    loadingBtn.disabled = false;
                    e.target.value = ''; // æ¸…é™¤é€‰æ‹©
                }
            }

            async loadMarkdownFile(file) {
                const content = await this.readFileAsText(file);
                this.setContent(content);
                this.images.clear(); // æ¸…é™¤ä¹‹å‰çš„å›¾ç‰‡
                this.saveToStorage(false);
            }

            async loadZipFile(file) {
                const zip = new JSZip();
                const zipContent = await zip.loadAsync(file);

                let markdownContent = '';
                const newImages = new Map();

                // æŸ¥æ‰¾MDæ–‡ä»¶
                for (let [filename, zipEntry] of Object.entries(zipContent.files)) {
                    if (filename.endsWith('.md') && !zipEntry.dir) {
                        markdownContent = await zipEntry.async('text');
                        break;
                    }
                }

                if (!markdownContent) {
                    throw new Error('ZIPæ–‡ä»¶ä¸­æœªæ‰¾åˆ°.mdæ–‡ä»¶');
                }

                // å»ºç«‹å›¾ç‰‡IDæ˜ å°„ï¼ˆç”¨äºä»æ–‡ä»¶åæŸ¥æ‰¾å›¾ç‰‡IDï¼‰
                const imageIdMap = new Map();

                // ä»markdownå†…å®¹ä¸­æå–å›¾ç‰‡å¼•ç”¨ï¼Œå»ºç«‹æ–‡ä»¶ååˆ°å›¾ç‰‡IDçš„æ˜ å°„
                const imageRegex = /!\[([^\]]*)\]\(([^)]+)\)/g;
                let match;
                while ((match = imageRegex.exec(markdownContent)) !== null) {
                    const imageId = match[2]; // å›¾ç‰‡ID
                    const imageName = match[1]; // å›¾ç‰‡åç§°

                    // ä»å›¾ç‰‡IDä¸­æå–æ–‡ä»¶åï¼ˆç§»é™¤æ‰©å±•åï¼‰
                    const fileNameWithoutExt = imageId.replace(/\.[^.]+$/, '');
                    imageIdMap.set(fileNameWithoutExt, imageId);
                }

                // å¤„ç†å›¾ç‰‡æ–‡ä»¶
                for (let [filename, zipEntry] of Object.entries(zipContent.files)) {
                    if (this.isImageFile(filename) && !zipEntry.dir) {
                        const imageData = await zipEntry.async('base64');
                        const mimeType = this.getMimeTypeFromExtension(filename);
                        const dataUrl = `data:${mimeType};base64,${imageData}`;

                        // ä»æ–‡ä»¶åï¼ˆä¸å«æ‰©å±•åï¼‰æŸ¥æ‰¾å¯¹åº”çš„å›¾ç‰‡ID
                        const fileNameWithoutExt = filename.replace(/^images\//, '').replace(/\.[^.]+$/, '');
                        const imageId = imageIdMap.get(fileNameWithoutExt) || this.generateImageId();

                        newImages.set(imageId, {
                            name: filename,
                            data: dataUrl,
                            type: mimeType
                        });
                    }
                }

                this.setContent(markdownContent);
                this.images = newImages;
                this.saveToStorage(false);
            }

            isImageFile(filename) {
                return /\.(jpg|jpeg|png|gif|webp|svg)$/i.test(filename);
            }

            getMimeTypeFromExtension(filename) {
                const ext = filename.toLowerCase().split('.').pop();
                const mimeTypes = {
                    'jpg': 'image/jpeg',
                    'jpeg': 'image/jpeg',
                    'png': 'image/png',
                    'gif': 'image/gif',
                    'webp': 'image/webp',
                    'svg': 'image/svg+xml'
                };
                return mimeTypes[ext] || 'image/png';
            }

            readFileAsText(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (e) => resolve(e.target.result);
                    reader.onerror = (e) => reject(new Error('æ–‡ä»¶è¯»å–å¤±è´¥'));
                    reader.readAsText(file);
                });
            }



            parseMarkdownToJSON(content) {
                const lines = content.split('\n');
                const result = {
                    metadata: {
                        createdAt: new Date().toISOString(),
                        nodeCount: 0,
                        imageCount: this.images.size,
                        hasImages: this.images.size > 0
                    },
                    nodes: [],
                    images: Object.fromEntries(this.images),
                    content: content
                };

                let nodeId = 0;
                const nodeStack = [];

                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i].trim();
                    if (!line) continue;

                    // æ ‡é¢˜èŠ‚ç‚¹
                    const headerMatch = line.match(/^(#{1,6})\s+(.+)$/);
                    if (headerMatch) {
                        const level = headerMatch[1].length;
                        const text = headerMatch[2];

                        const node = {
                            id: ++nodeId,
                            type: 'header',
                            level: level,
                            text: text,
                            children: []
                        };

                        this.addNodeToStack(nodeStack, node, level);
                        continue;
                    }

                    // åˆ—è¡¨èŠ‚ç‚¹
                    const listMatch = line.match(/^(\s*)([-*+]|\d+\.)\s+(.+)$/);
                    if (listMatch) {
                        const indent = listMatch[1].length;
                        const marker = listMatch[2];
                        const text = listMatch[3];
                        const level = Math.floor(indent / 2) + 1;

                        const node = {
                            id: ++nodeId,
                            type: marker.match(/\d+\./) ? 'ordered-list' : 'unordered-list',
                            level: level,
                            text: text,
                            children: []
                        };

                        this.addNodeToStack(nodeStack, node, level);
                        continue;
                    }
                }

                result.nodes = nodeStack.filter(node => node.level === 1);
                result.metadata.nodeCount = nodeId;

                return result;
            }

            addNodeToStack(stack, node, level) {
                // æ¸…ç†æ ˆä¸­æ›´æ·±å±‚çº§çš„èŠ‚ç‚¹
                while (stack.length > 0 && stack[stack.length - 1].level >= level) {
                    stack.pop();
                }

                // æ·»åŠ åˆ°çˆ¶èŠ‚ç‚¹
                if (stack.length > 0) {
                    stack[stack.length - 1].children.push(node);
                }

                stack.push(node);
            }

            // ===================================
            // ğŸ“š å¸®åŠ©é¢æ¿
            // ===================================

            toggleHelp() {
                const panel = document.getElementById('help-panel');
                panel.classList.toggle('open');
            }

            // ===================================
            // ğŸ’¬ æ¶ˆæ¯æç¤º
            // ===================================

            showMessage(message, type = 'success') {
                // ä½¿ç”¨é€šçŸ¥æ¡¥æ¥å™¨å‘é€é€šçŸ¥
                if (window.NotificationBridge) {
                    switch (type) {
                        case 'success':
                            window.NotificationBridge.showSuccess(message);
                            break;
                        case 'error':
                            window.NotificationBridge.showError(message);
                            break;
                        case 'warning':
                            window.NotificationBridge.showWarning(message);
                            break;
                        default:
                            window.NotificationBridge.showInfo(message);
                    }
                } else {
                    // å›é€€åˆ°æœ¬åœ°çŠ¶æ€æ¶ˆæ¯ï¼ˆä¸»è¦ç”¨äºéä¿å­˜æ“ä½œï¼‰
                    const messageEl = document.getElementById('status-message');
                    if (messageEl) {
                        messageEl.textContent = message;
                        messageEl.className = `status-message ${type}`;
                        messageEl.classList.add('show');

                        setTimeout(() => {
                            messageEl.classList.remove('show');
                        }, 3000);
                    }
                }
            }



            // ===================================
            // ğŸ”„ è·¨çª—å£é€šä¿¡
            // ===================================

            broadcastChange() {
                // å‘å…¶ä»–çª—å£å¹¿æ’­å†…å®¹å˜åŒ–
                const data = {
                    type: 'markdown-content-change',
                    content: this.getContent(),
                    timestamp: Date.now()
                };

                try {
                    window.parent.postMessage(data, '*');
                } catch (e) {
                    // å¿½ç•¥è·¨åŸŸé”™è¯¯
                }
            }

            // ===================================
            // ğŸ¨ å†…å®¹æ“ä½œè¾…åŠ©æ–¹æ³•
            // ===================================

            getContent() {
                return this.editor.value;
            }

            setContent(content) {
                this.editor.value = content;
            }

            convertHtmlToMarkdown(html) {
                // å¤ç”¨å·¥å…·åº“çš„convertHtmlToMarkdownå‡½æ•°
                return HtmlMarkdownUtils.convertHtmlToMarkdown(html);
            }
        }

        // ===================================
        // ğŸš€ åº”ç”¨åˆå§‹åŒ–
        // ===================================

        // å·¥å…·ï¼šæµ‹é‡æ–‡æœ¬åœ¨ textarea ä¸­æ¸²æŸ“é«˜åº¦ï¼ˆå¤ç”¨éšè— mirrorï¼‰
        function measureTextHeight(text, textarea) {
            try {
                let mirror = document.getElementById('mw-text-mirror');
                if (!mirror) {
                    mirror = document.createElement('div');
                    mirror.id = 'mw-text-mirror';
                    mirror.style.position = 'absolute';
                    mirror.style.visibility = 'hidden';
                    mirror.style.whiteSpace = 'pre-wrap';
                    mirror.style.wordWrap = 'break-word';
                    mirror.style.top = '0';
                    mirror.style.left = '-99999px';
                    document.body.appendChild(mirror);
                }
                const style = window.getComputedStyle(textarea);
                const props = [
                    'width', 'fontSize', 'fontFamily', 'fontWeight', 'lineHeight',
                    'paddingTop', 'paddingRight', 'paddingBottom', 'paddingLeft',
                    'borderLeftWidth', 'borderRightWidth', 'boxSizing', 'letterSpacing',
                    'whiteSpace'
                ];
                props.forEach(p => {
                    try { mirror.style[p] = style[p]; } catch (e) { }
                });
                // Ensure same width for wrapping
                mirror.style.width = textarea.clientWidth + 'px';
                // Set text content (use textContent to preserve whitespace)
                mirror.textContent = text || '';
                // Return the height of rendered content
                return mirror.scrollHeight || mirror.clientHeight || 0;
            } catch (e) {
                return 0;
            }
        }

        // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–ç¼–è¾‘å™¨
        document.addEventListener('DOMContentLoaded', () => {
            window.markdownEditor = new MarkdownEditor();
            console.log('ğŸ“ Markdown Editor å·²åˆå§‹åŒ–');

            // æ¥æ”¶æ¥è‡ªæ€ç»´å¯¼å›¾/çˆ¶é¡µé¢çš„é€‰ä¸­è·³è½¬è¯·æ±‚
            window.addEventListener('message', async function (e) {
                try {
                    // è°ƒè¯•æ—¥å¿—ï¼šæ‰“å° editor æ”¶åˆ°çš„åŸå§‹ message
                    try { console.log('[EDITOR RAW MESSAGE]', e && e.data); } catch (err) { }
                    if (!e.data || !e.data.type) return;
                    // æ”¯æŒ mindmap ç›´æ¥æ¶ˆæ¯æˆ– index è½¬å‘çš„ editor-scroll-to
                    if (e.data.type === 'mindmap-node-selected' || e.data.type === 'editor-scroll-to') {
                        const payload = e.data;
                        const nodeid = payload.nodeid || '';
                        const raw = (payload.raw || '').toString().trim();
                        const parentPath = payload.parentPath || '';

                        if (!raw) return;

                        // è·å–å…¨æ–‡ä¸æŒ‰è¡Œç´¢å¼•
                        const content = window.markdownEditor.getContent() || '';
                        // æŒ‰çœŸå®æ¢è¡Œæ‹†åˆ†ä¸ºè¡Œæ•°ç»„ï¼ˆä¿®å¤å› é”™è¯¯åˆ†éš”å¯¼è‡´æ¯è¡Œå˜æˆå•å­—ç¬¦çš„ bugï¼‰
                        const lines = content.split('\n');


                        // æ‰¾åˆ°æ‰€æœ‰åŒ…å« raw çš„è¡Œç´¢å¼•ï¼ˆå¦‚éœ€æ›´ä¸¥æ ¼åŒ¹é…å¯æ”¹ä¸ºæ­£åˆ™ï¼‰
                        const matches = [];
                        // ä¸¥æ ¼åŒ¹é…ï¼šå…ˆå‰¥ç¦»è¡Œé¦– Markdown æ ‡è®°ï¼ˆ#ã€-ã€æ•°å­—.ã€> ç­‰åŠå…¶åç©ºæ ¼ï¼‰ï¼Œå†ä¸ rawï¼ˆåŒæ ·å‰¥ç¦»å‰å¯¼#ï¼‰åšå®Œå…¨ç›¸ç­‰æ¯”è¾ƒ
                        const normalize = (s) => (s || '').toString().replace(/^\s*(#{1,6}\s+|[-*]\s+|\d+\.\s+|>\s+)/, '').trim();
                        const rawNormalized = normalize(raw.replace(/^\s*#{1,6}\s*/, ''));
                        for (let i = 0; i < lines.length; i++) {
                            const line = lines[i] || '';
                            const lineNormalized = normalize(line);
                            if (lineNormalized === rawNormalized) {
                                if (parentPath) {
                                    const parentLast = (parentPath || '').toString().split('/').pop().trim();
                                    let foundParent = false;
                                    for (let k = Math.max(0, i - 8); k <= i; k++) {
                                        if (parentLast && lines[k] && lines[k].includes(parentLast)) { foundParent = true; break; }
                                    }
                                    if (!foundParent) continue;
                                }
                                matches.push(i);
                            }
                        }

                        if (matches.length === 0) {
                            try { console.log('[EDITOR] æœªæ‰¾åˆ°ç›´æ¥åŒ…å« raw çš„è¡Œï¼Œå°è¯•å›é€€åŒ¹é…', { raw, parentPath, linesLength: lines.length }); } catch (e) { }
                            // å›é€€1ï¼šå¦‚æœ raw æœ‰ Markdown header (#)ï¼Œå»æ‰å‰å¯¼çš„ # å’Œç©ºæ ¼å†æœç´¢
                            var rawFallback = raw.replace(/^\s*#{1,6}\s*/, '').trim();
                            if (rawFallback && rawFallback !== raw) {
                                for (let i = 0; i < lines.length; i++) {
                                    if ((lines[i] || '').includes(rawFallback)) {
                                        matches.push(i);
                                    }
                                }
                            }
                            // å›é€€2ï¼šå¼±åŒ¹é… - æ¯ä¸ªç©ºæ ¼åˆ†è¯ï¼Œæ‰€æœ‰è¯å‡åœ¨åŒä¸€è¡Œ
                            if (matches.length === 0 && rawFallback) {
                                const tokens = rawFallback.split(/\s+/).filter(Boolean);
                                if (tokens.length > 0) {
                                    for (let i = 0; i < lines.length; i++) {
                                        const line = lines[i] || '';
                                        let ok = true;
                                        for (const t of tokens) {
                                            if (!line.includes(t)) { ok = false; break; }
                                        }
                                        if (ok) matches.push(i);
                                    }
                                }
                            }
                            // è°ƒè¯•ï¼šè‹¥ä»æœªå‘½ä¸­ï¼Œæ‰“å°é™„è¿‘å†…å®¹ä¾›æ’æŸ¥ï¼ˆå‰å5è¡Œï¼‰
                            if (matches.length === 0) {
                                try {
                                    const snippetIndex = Math.max(0, Math.floor(lines.length / 2) - 3);
                                    const snippet = lines.slice(snippetIndex, Math.min(lines.length, snippetIndex + 12));
                                    console.warn('[EDITOR] fallback ä»æœªå‘½ä¸­ rawï¼Œç»™å‡ºæ–‡æœ¬ç‰‡æ®µä¾›æ’æŸ¥', { raw, rawFallback, linesLength: lines.length, snippetIndex, snippet });
                                } catch (e) { }
                                return;
                            }
                        }

                        // å¾ªç¯è·³è½¬é€»è¾‘ï¼ˆnodeid ä¼˜å…ˆï¼Œå¦åˆ™ä½¿ç”¨ raw ä½œä¸º keyï¼‰
                        window.__mw_nodeMatchIndex = window.__mw_nodeMatchIndex || {};
                        const key = nodeid || raw;
                        let last = window.__mw_nodeMatchIndex[key] || -1;
                        last = (last + 1) % matches.length;
                        window.__mw_nodeMatchIndex[key] = last;
                        const targetLine = matches[last];

                        // è®¡ç®—å­—ç¬¦èŒƒå›´ä»¥ä¾¿ setSelectionRange
                        let charStart = 0;
                        for (let i = 0; i < targetLine; i++) charStart += (lines[i] ? lines[i].length : 0) + 1;
                        const charEnd = charStart + (lines[targetLine] ? lines[targetLine].length : 0);

                        // ä½¿ç”¨ textarea API æ»šåŠ¨å¹¶é€‰ä¸­
                        const textarea = document.getElementById('editor');
                        if (!textarea) return;
                        // ä¸èšç„¦ç¼–è¾‘å™¨ï¼ˆé¿å…æŠŠé”®ç›˜ç„¦ç‚¹åˆ‡èµ°ï¼‰
                        // ä½¿ç”¨éèšç„¦çš„é»„è‰² overlay é«˜äº®ï¼ˆå®ç°ï¼‰
                        (function applyEditorOverlayFull() {
                            try {
                                const textarea = document.getElementById('editor');
                                if (!textarea) return;

                                // è®¡ç®—è¡Œé«˜ä¸æµ‹é‡ topï¼ˆä»¥å­—ç¬¦åç§»æµ‹é‡åƒç´ é«˜åº¦ï¼‰
                                const style = window.getComputedStyle(textarea);
                                const lineHeight = parseFloat(style.lineHeight) || (parseFloat(style.fontSize) * 1.6) || 18;
                                const charStartForMeasure = charStart;
                                const textBeforeCursor = content.substring(0, charStartForMeasure);
                                const measuredTop = measureTextHeight(textBeforeCursor, textarea);

                                // æ»šåŠ¨åˆ°ç›®æ ‡ä½ç½®ï¼ˆä¸èšç„¦ï¼‰
                                const targetScrollTop = Math.max(0, measuredTop - textarea.clientHeight / 2);
                                textarea.scrollTop = targetScrollTop;
                                try { console.log('[EDITOR] measuredTop/targetScrollTop (overlay)', { measuredTop: measuredTop, targetScrollTop: targetScrollTop, lineHeight: lineHeight, charStart: charStartForMeasure }); } catch (e) { }

                                // åˆ›å»ºæˆ–å¤ç”¨ overlay å®¹å™¨ï¼ˆæŒ‚åˆ° document.bodyï¼‰
                                let overlay = document.getElementById('mw-editor-overlay');
                                if (!overlay) {
                                    overlay = document.createElement('div');
                                    overlay.id = 'mw-editor-overlay';
                                    overlay.style.position = 'absolute';
                                    overlay.style.background = 'linear-gradient(180deg, rgba(255,230,100,0.65), rgba(255,210,60,0.5))';
                                    overlay.style.borderRadius = '6px';
                                    overlay.style.pointerEvents = 'none';
                                    overlay.style.zIndex = 9999;
                                    overlay.style.boxShadow = '0 6px 18px rgba(0,0,0,0.12)';
                                    overlay.style.transition = 'opacity 0.24s ease, transform 0.18s ease';
                                    document.body.appendChild(overlay);
                                }

                                // è®¡ç®— overlay åœ¨è§†å£ä¸­çš„ä½ç½®
                                const taRect = textarea.getBoundingClientRect();
                                // measuredTop æ˜¯ç›¸å¯¹äº textarea å†…å®¹é¡¶éƒ¨çš„åƒç´ é«˜åº¦ï¼ˆåŒ…å« paddingï¼‰
                                // å¾®è°ƒ overlayTopï¼Œå‘ä¸Šè¡¥å¿ä¸€ä¸ªè¡Œé«˜çš„åå·®å› å­ï¼Œé¿å…è¦†ç›–åˆ°ä¸‹ä¸€è¡Œ
                                const rawTop = taRect.top + (measuredTop - textarea.scrollTop);
                                const adjust = Math.round((lineHeight || 18) * 0.9); // å¯è°ƒï¼š0.9 è¡Œé«˜è¡¥å¿
                                const overlayTop = Math.round(rawTop - adjust);
                                const overlayLeft = Math.round(taRect.left + 6);
                                const overlayWidth = Math.max(40, taRect.width - 12);
                                const overlayHeight = Math.max(lineHeight, 18);

                                overlay.style.left = overlayLeft + 'px';
                                overlay.style.top = overlayTop + 'px';
                                overlay.style.width = overlayWidth + 'px';
                                overlay.style.height = overlayHeight + 'px';
                                overlay.style.opacity = '1';
                                overlay.style.transform = 'translateY(0px)';

                                // è‹¥å·²æœ‰è¶…æ—¶å¥æŸ„ï¼Œæ¸…é™¤å¹¶é‡è®¾
                                if (window.__mw_editorOverlayTimeout) {
                                    clearTimeout(window.__mw_editorOverlayTimeout);
                                }

                                // åœ¨å åŠ é«˜äº®æ—¶çŸ­æš‚æ”¾å¤§å¹¶å›å½’ï¼Œæå‡å¯è§æ€§
                                overlay.style.transform = 'translateY(-4px) scale(1.02)';
                                setTimeout(() => {
                                    try { overlay.style.transform = 'translateY(0px) scale(1)'; } catch (e) { }
                                }, 60);

                                // è‡ªåŠ¨æ·¡å‡ºå¹¶ç§»é™¤ overlay
                                window.__mw_editorOverlayTimeout = setTimeout(function () {
                                    try {
                                        overlay.style.opacity = '0';
                                        overlay.style.transform = 'translateY(-6px) scale(0.98)';
                                        setTimeout(function () { try { overlay.remove(); } catch (e) { } }, 260);
                                        window.__mw_editorOverlayTimeout = null;
                                    } catch (e) { }
                                }, 1600);

                                try { console.log('[EDITOR] Applied non-focus overlay highlight for node', { nodeid: nodeid, targetLine: targetLine }); } catch (e) { }
                            } catch (e) { console.warn('[EDITOR] overlay apply failed', e); }
                        })();

                        // è°ƒè¯•æ—¥å¿—ï¼šé€‰åŒºä¸ä½ç½®
                        try { console.log('[EDITOR] setSelectionRange', { charStart, charEnd, targetLine }); } catch (e) { }

                        // ä½¿ç”¨ç²¾ç¡®æµ‹é‡æ¥è®¡ç®—è¦æ»šåŠ¨åˆ°çš„ä½ç½®ï¼Œé¿å…åŸºäºè¡Œé«˜çš„è¯¯å·®
                        const style = window.getComputedStyle(textarea);
                        const lineHeight = parseFloat(style.lineHeight) || (parseFloat(style.fontSize) * 1.6) || 18;

                        // è®¡ç®—é€‰ä¸­æ–‡æœ¬å‰çš„å­—ç¬¦æ•°ä½ç½®å¹¶æµ‹é‡å…¶æ¸²æŸ“é«˜åº¦
                        const contentBefore = (lines.slice(0, targetLine).join('\\n') + (lines[targetLine] ? lines[targetLine].slice(0, 0) : '')) || '';
                        const charStartForMeasure = charStart;
                        const textBeforeCursor = content.substring(0, charStartForMeasure);
                        const measuredTop = measureTextHeight(textBeforeCursor, textarea);

                        // ç›®æ ‡ scrollTopï¼šä»¥é€‰ä¸­èµ·å§‹ä½ç½®ä¸ºä¸­å¿ƒ
                        const targetScrollTop = Math.max(0, measuredTop - textarea.clientHeight / 2);
                        textarea.scrollTop = targetScrollTop;
                        try { console.log('[EDITOR] measuredTop/targetScrollTop', { measuredTop: measuredTop, targetScrollTop: targetScrollTop, lineHeight: lineHeight, charStart: charStartForMeasure }); } catch (e) { }

                        // ä¸´æ—¶é«˜äº®ï¼ˆé€šè¿‡æ·»åŠ ç±»ï¼Œé…åˆ CSS å¯è§æ•ˆæœï¼‰
                        textarea.classList.add('mw-editor-highlight');
                        if (window.__mw_editorHighlightTimeout) clearTimeout(window.__mw_editorHighlightTimeout);
                        window.__mw_editorHighlightTimeout = setTimeout(() => {
                            textarea.classList.remove('mw-editor-highlight');
                        }, 1600);

                    }
                } catch (err) {
                    // å¿½ç•¥å¤„ç†é”™è¯¯
                }
            }, { passive: true });
        });

        // é¡µé¢å¸è½½å‰ä¿å­˜
        window.addEventListener('beforeunload', () => {
            if (window.markdownEditor && window.markdownEditor.hasUnsavedChanges()) {
                window.markdownEditor.saveToStorage(false);
            }
        });
    </script>

    <!-- Mindmap -> Editor æ¶ˆæ¯åè®®ç›‘å¬ï¼šè®¾ç½® Markdown + ä¿å­˜/åŒæ­¥ -->
    <script>
        (function () {
            function setMarkdownToEditor(md) {
                try {
                    if (window.markdownEditor && typeof window.markdownEditor.setContent === 'function') {
                        window.markdownEditor.setContent(String(md || ''));
                        try { window.markdownEditor.saveToStorage(false); } catch (e) { }
                        // ç¡®ä¿å†™å…¥ localStorageï¼Œè®©å…¶å®ƒ iframe èƒ½æ¥æ”¶åˆ° storage äº‹ä»¶å¹¶æ›´æ–°
                        try { localStorage.setItem('mindword_markdown_data', String(md || '')); } catch (e) { }
                        window.markdownEditor.saveToStorage(false);
                        window.syncAll('markdown', true, true);

                        try { setTimeout(function () { try { window.parent.postMessage({ type: 'editor-reload-request', requestId: (window.__mw_ai_active_requestId || null) }, '*'); } catch (e) { /* ignore postMessage errors */ } }, 500); } catch (e) { /* ignore timer errors */ }
                        return true;
                    }
                } catch (e) { }
                return false;
            }
            function saveOrSync(reason) {

                window.markdownEditor.saveToStorage(false);

                window.syncAll('markdown', true, true);

            }

            window.__mw_pending_editor_set = window.__mw_pending_editor_set || null;

            // ç›‘å¬æ¥è‡ªçˆ¶é¡µ/æ€ç»´å¯¼å›¾çš„æ¶ˆæ¯
            window.addEventListener('message', async function (e) {
                try {
                    var msg = e && e.data;
                    if (!msg || typeof msg !== 'object' || !msg.type) return;

                    if (msg.type === 'editor-set-markdown') {
                        // è®¾ç½®å†·å´çª—å£ï¼Œé¿å… storage å›å£°å¼•å‘çš„é‡å¤åŒæ­¥/é€šçŸ¥
                        try {
                            var __until = Date.now() + 1200;
                            window.__mw_editor_cooldown_until = __until;
                            // do not write cooldown to localStorage to avoid blocking other frames
                        } catch (_) { }
                        var ok = setMarkdownToEditor(msg.markdown);
                        if (!ok) {
                            // è‹¥ç¼–è¾‘å™¨å°šæœªåˆå§‹åŒ–ï¼Œç¼“å­˜ä¸€æ¬¡
                            try { window.__mw_pending_editor_set = String(msg.markdown || ''); } catch (_) { }
                        } else {
                            try { window.showSuccess && window.showSuccess('å·²æ¥æ”¶å¹¶åº”ç”¨ Markdown'); } catch (_) { }
                        }
                        return;
                    }

                    if (msg.type === 'editor-save-or-sync') {
                        saveOrSync(msg.reason || '');
                        try { window.showSuccess && window.showSuccess('å·²ä¿å­˜å¹¶åŒæ­¥'); } catch (_) { }
                        return;
                    }
                } catch (err) {
                    // å¿½ç•¥å¤„ç†é”™è¯¯ï¼Œé¿å…å½±å“ç¼–è¾‘å™¨
                }
            }, { passive: true });

            // ç¼–è¾‘å™¨å°±ç»ªåï¼Œå¦‚å­˜åœ¨å¾…è®¾ç½®çš„å†…å®¹åˆ™ç«‹å³åº”ç”¨
            document.addEventListener('DOMContentLoaded', function () {
                try {
                    if (window.__mw_pending_editor_set) {
                        setMarkdownToEditor(window.__mw_pending_editor_set);
                        // è®¾ç½®å†·å´çª—å£ï¼Œé¿å…åˆå§‹åŒ–æ—¶ storage å›å£°
                        try {
                            var __until2 = Date.now() + 1200;
                            window.__mw_editor_cooldown_until = __until2;
                            // do not write cooldown to localStorage to avoid blocking other frames
                        } catch (_) { }
                        window.__mw_pending_editor_set = null;
                    }
                } catch (_) { }
            });
        })();
    </script>

    <!-- å¼•å…¥å¹¶åˆå§‹åŒ– converterï¼Œæä¾› syncAll èƒ½åŠ› -->
    <script type="module">
        import ConverterManager from '../converter/converter.js';
        // åˆ›å»ºå¹¶æš´éœ²è½¬æ¢å™¨å®ä¾‹
        window.converter = new ConverterManager();
        // å¹¿æ’­å°±ç»ªäº‹ä»¶ï¼Œä¾› sync.js / load.js ç­‰ç­‰å¾…
        window.dispatchEvent(new Event('converterReady'));
    </script>
    <script type="module" src="../converter/sync.js"></script>
    <script type="module" src="../converter/load.js"></script>

    <!-- Bootstrap JS for notifications -->
    <script src="/local-deps/jquery.min.js"></script>
    <script src="/local-deps/bootstrap.bundle.min.js"></script>
    <!-- é€šçŸ¥æ¡¥æ¥å™¨ -->
    <script src="../notification-bridge.js"></script>
    <!-- å›¾ç‰‡å­˜å‚¨ç®¡ç† -->
    <script src="../utils/image-storage.js"></script>
    <script>
        (function () {
            // åˆå§‹åŒ–å›¾ç‰‡å­˜å‚¨ç®¡ç†å™¨
            if (window.ImageStorageManager) {
                window.imageStorage = new ImageStorageManager();
                console.log('[editor] ImageStorageManager initialized');
            } else {
                console.error('[editor] ImageStorageManager not found');
            }

            // è®°å½•å½“å‰æ´»åŠ¨æ–‡æ¡£IDï¼Œå°è¯•ä»localStorageæ¢å¤
            window.__mw_activeDocId = window.__mw_activeDocId || localStorage.getItem('mindword_active_doc_id') || null;
            console.log(`[editor] Initialized activeDocId: ${window.__mw_activeDocId}`);

            async function applyEditorContent(payload) {
                try {
                    const md = (payload && payload.md) ? String(payload.md) : '';
                    const images = payload && payload.images ? payload.images : null;

                    // é¦–é€‰ä½¿ç”¨ MarkdownEditor
                    if (window.markdownEditor && typeof window.markdownEditor.setContent === 'function') {
                        // è®¾ç½®æ­£æ–‡
                        window.markdownEditor.setContent(md);

                        // è®¾ç½®å›¾ç‰‡ Mapï¼ˆå…¼å®¹æ•°ç»„æˆ–å¯¹è±¡ï¼‰
                        try {
                            if (Array.isArray(images)) {
                                // è½¬æ¢æ•°ç»„æ ¼å¼ [{name, dataUrl, mime}, ...] ä¸º Map<id, {name, data, type}>
                                const imagesMap = new Map();
                                images.forEach(img => {
                                    // ä¼˜å…ˆä½¿ç”¨å›¾ç‰‡çš„IDï¼Œå¦‚æœæ²¡æœ‰åˆ™ä½¿ç”¨åç§°ï¼Œæœ€åæ‰ç”Ÿæˆæ–°ID
                                    const imageId = img.id || img.name || 'img_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);

                                    // ä¸¥æ ¼éªŒè¯å›¾ç‰‡æ•°æ®ï¼šå¿…é¡»æœ‰æœ‰æ•ˆçš„dataUrl
                                    if (!img.dataUrl || !img.dataUrl.startsWith('data:image/')) {
                                        console.error(`[editor] æ¥æ”¶åˆ°çš„å›¾ç‰‡æ•°æ®æ— æ•ˆ: missing dataUrl or invalid format`, img);
                                        return; // è·³è¿‡æ— æ•ˆçš„å›¾ç‰‡
                                    }

                                    // éªŒè¯å¹¶ä¿®æ­£å›¾ç‰‡ç±»å‹ï¼šæœç»text/htmlç­‰éå›¾ç‰‡ç±»å‹
                                    let imageType = img.mime || 'image/png';
                                    if (!imageType.startsWith('image/')) {
                                        console.warn(`[editor] æ¥æ”¶åˆ°çš„å›¾ç‰‡ç±»å‹æ— æ•ˆ: ${imageType}ï¼Œä»dataUrlæ£€æµ‹çœŸå®ç±»å‹`);
                                        // ä»dataUrlæå–çœŸå®ç±»å‹
                                        const dataUrlMatch = img.dataUrl.match(/^data:(image\/[^;]+);/);
                                        if (dataUrlMatch) {
                                            imageType = dataUrlMatch[1];
                                            console.log(`[editor] ä»dataUrlæ£€æµ‹åˆ°çœŸå®ç±»å‹: ${imageType}`);
                                        } else {
                                            imageType = 'image/png';
                                            console.warn(`[editor] æ— æ³•æ£€æµ‹ç±»å‹ï¼Œè®¾ä¸ºé»˜è®¤å€¼: ${imageType}`);
                                        }
                                    }

                                    imagesMap.set(imageId, {
                                        name: img.name || '',
                                        data: img.dataUrl,  // dataUrl -> data
                                        type: imageType  // å·²éªŒè¯çš„å›¾ç‰‡ç±»å‹
                                    });
                                });
                                window.markdownEditor.images = imagesMap;
                            } else if (images && typeof images === 'object') {
                                window.markdownEditor.images = new Map(Object.entries(images));
                            } else {
                                window.markdownEditor.images = new Map();
                            }
                        } catch (e) { console.warn('[editor] set images map failed', e); }

                        // åŒæ­¥åˆ°å­˜å‚¨ï¼ˆè®©é¢„è§ˆ/å¯¼å›¾ä¹Ÿèƒ½ç«‹å³åˆ‡æ¢ï¼‰
                        try {
                            localStorage.setItem('mindword_markdown_data', md);
                            // ä½¿ç”¨ IndexedDB ä¿å­˜å›¾ç‰‡
                            console.log(`[editor] å‡†å¤‡ä¿å­˜å›¾ç‰‡åˆ°IndexedDBï¼Œå›¾ç‰‡æ•°é‡: ${window.markdownEditor.images ? window.markdownEditor.images.size : 0}`);
                            if (window.markdownEditor.images && window.markdownEditor.images.size > 0) {
                                for (const [id, imgData] of window.markdownEditor.images.entries()) {
                                    console.log(`[editor] å¾…ä¿å­˜å›¾ç‰‡: id=${id}, name=${imgData.name}, type=${imgData.type}, dataé•¿åº¦=${imgData.data ? imgData.data.length : 0}`);
                                }
                            }
                            await window.imageStorage.saveImages(window.markdownEditor.images || new Map());
                            console.log('[editor] å›¾ç‰‡ä¿å­˜å®Œæˆ');
                        } catch (e) { console.warn('[editor] write storage failed', e); }

                        // ä¿å­˜å¹¶è”åŠ¨
                        try { window.markdownEditor.saveToStorage(false); } catch (e) { /* ignore */ }
                        try { if (typeof window.syncAll === 'function') window.syncAll('markdown', true, true); } catch (e) { /* ignore */ }

                    } else if (typeof window.setMarkdown === 'function') {
                        // å›é€€ï¼šæ—§æ¥å£
                        window.setMarkdown(md);
                    } else if (window.editor && typeof window.editor.setMarkdown === 'function') {
                        window.editor.setMarkdown(md);
                    } else if (typeof window.loadIncomingDocument === 'function') {
                        window.loadIncomingDocument(payload);
                    }

                    // å¹¿æ’­äº‹ä»¶ï¼Œä¾¿äºç°æœ‰ä»£ç ç›‘å¬åˆ·æ–°
                    document.dispatchEvent(new CustomEvent('mw:load_document', { detail: payload }));
                } catch (e) { console.warn('[editor] applyEditorContent error', e); }
            }

            window.addEventListener('message', async function (e) {
                const msg = e.data;
                if (!msg || typeof msg !== 'object') return;

                if (msg.type === 'mw_load_document' && msg.payload) {
                    const { id, name, md, images, rev } = msg.payload;
                    window.__mw_activeDocId = id || null;
                    // å­˜å‚¨å½“å‰æ–‡æ¡£IDåˆ°localStorageï¼Œä¾›å…¶ä»–é¡µé¢ä½¿ç”¨
                    if (id) {
                        localStorage.setItem('mindword_active_doc_id', id);
                    } else {
                        localStorage.removeItem('mindword_active_doc_id');
                    }
                    window.__mw_activeDoc = { id, name, md, images, rev };
                    // è¿›å…¥æ¥æ”¶é˜¶æ®µï¼šæŠ‘åˆ¶å›å£°ä¿å­˜
                    window.__mw_receiving = true;
                    // ç›´æ¥åº”ç”¨åˆ°ç¼–è¾‘å™¨å¹¶è”åŠ¨ä¿å­˜/åŒæ­¥ï¼ˆä½†ä¸å›å‘ mw_document_changedï¼‰
                    try {
                        if (window.markdownEditor && typeof window.markdownEditor.setContent === 'function') {
                            window.markdownEditor.setContent(String(md || ''));
                            // åŒæ­¥å›¾ç‰‡ï¼ˆå…¼å®¹æ•°ç»„æˆ–å¯¹è±¡ï¼‰
                            try {
                                if (Array.isArray(images)) {
                                    // è½¬æ¢æ•°ç»„æ ¼å¼ [{name, dataUrl, mime}, ...] ä¸º Map<id, {name, data, type}>
                                    const imagesMap = new Map();
                                    images.forEach(img => {
                                        // ä¼˜å…ˆä½¿ç”¨å›¾ç‰‡çš„IDï¼Œå¦‚æœæ²¡æœ‰åˆ™ä½¿ç”¨åç§°ï¼Œæœ€åæ‰ç”Ÿæˆæ–°ID
                                        const imageId = img.id || img.name || 'img_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                                        // éªŒè¯å¹¶ä¿®æ­£å›¾ç‰‡ç±»å‹ï¼šæœç»text/htmlç­‰éå›¾ç‰‡ç±»å‹
                                        let imageType = img.mime || 'image/png';
                                        if (!imageType.startsWith('image/')) {
                                            console.warn(`[editor] æ¥æ”¶åˆ°çš„å›¾ç‰‡ç±»å‹æ— æ•ˆ: ${imageType}ï¼Œå¼ºåˆ¶è®¾ä¸ºimage/png`);
                                            imageType = 'image/png';
                                        }

                                        imagesMap.set(imageId, {
                                            name: img.name || '',
                                            data: img.dataUrl || '',  // dataUrl -> data
                                            type: imageType  // å·²éªŒè¯çš„å›¾ç‰‡ç±»å‹
                                        });
                                    });
                                    window.markdownEditor.images = imagesMap;
                                } else if (images && typeof images === 'object') {
                                    window.markdownEditor.images = new Map(Object.entries(images));
                                } else {
                                    window.markdownEditor.images = new Map();
                                }
                            } catch (e) { console.warn('[editor] set images map failed', e); }
                            // å†™å…¥å­˜å‚¨è®©å…¶å®ƒé¢æ¿å³æ—¶æ”¶åˆ°
                            try {
                                localStorage.setItem('mindword_markdown_data', String(md || ''));
                                // æ³¨æ„ï¼šsaveToStorage ä¼šä¿å­˜å›¾ç‰‡ï¼Œè¿™é‡Œä¸éœ€è¦é‡å¤ä¿å­˜
                            } catch (e) { console.warn('[editor] write storage failed', e); }
                            // ä¸éœ€è¦è°ƒç”¨ saveToStorageï¼Œå› ä¸ºæ–‡æ¡£å·²ç»ä¿å­˜è¿‡ï¼Œç›´æ¥åŒæ­¥å³å¯
                            try { if (typeof window.syncAll === 'function') window.syncAll('markdown', true, true); } catch (e) { }
                        } else {
                            await applyEditorContent(msg.payload);
                        }
                    } catch (e) { await applyEditorContent(msg.payload); }
                    // é€€å‡ºæ¥æ”¶é˜¶æ®µï¼ˆå¾®å»¶è¿Ÿï¼Œç¡®ä¿æœ¬è½®ä¿å­˜ç»“æŸï¼‰
                    setTimeout(() => { window.__mw_receiving = false; }, 200);
                    // å¹¿æ’­äº‹ä»¶ä»¥å…¼å®¹å…¶ä»–ç›‘å¬
                    document.dispatchEvent(new CustomEvent('mw:load_document', { detail: msg.payload }));
                }

                if (msg.type === 'mw_assign_document_id') {
                    window.__mw_activeDocId = msg.id;
                    // é€šçŸ¥ç°æœ‰é€»è¾‘ç»‘å®šIDï¼ˆå¯é€‰ï¼‰
                    document.dispatchEvent(new CustomEvent('mw:assign_document_id', { detail: { id: msg.id } }));
                }

                if (msg.type === 'mw_relayout') {
                    try {
                        if (typeof window.updateLayout === 'function') window.updateLayout();
                    } catch (_) { }
                }
            }, { passive: true });
        })();
    </script>
</body>

</html>