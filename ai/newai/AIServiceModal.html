<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI服务调用工具</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet">

    <!-- Tailwind 配置 -->
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: '#3B82F6',
                        secondary: '#10B981',
                        neutral: '#1F2937',
                        'neutral-light': '#F3F4F6',
                    },
                    fontFamily: {
                        sans: ['Inter', 'system-ui', 'sans-serif'],
                    },
                }
            }
        }
    </script>

    <style type="text/tailwindcss">
        @layer utilities {
            .modal-backdrop {
                @apply fixed inset-0 z-40 flex items-center justify-center p-4;
                /* 背景透明，避免在 iframe 内遮挡父页面（父页面负责半透明遮罩） */
                background: transparent;
            }
            .modal-container {
                @apply bg-white rounded-lg shadow-2xl w-full max-w-4xl h-auto flex flex-col;
            }
            @media (max-width: 768px) {
                .modal-container {
                    @apply max-w-full mx-2 my-2 h-[90vh] rounded-lg;
                }
            }
            @media (max-width: 640px) {
                .modal-container {
                    @apply mx-1 my-1 h-[85vh] rounded-lg;
                }
            }
            @media (max-width: 480px) {
                .modal-container {
                    @apply mx-0 my-0 h-[80vh] rounded-lg;
                }
            }
            .modal-header {
                @apply px-6 py-4 border-b flex justify-between items-center;
            }
            @media (max-width: 768px) {
                .modal-header {
                    @apply px-4 py-2;
                }
            }
            @media (max-width: 640px) {
                .modal-header {
                    @apply px-3 py-1.5;
                }
            }
            .modal-body {
                @apply px-6 py-4 overflow-hidden flex-grow;
            }
            @media (max-width: 768px) {
                .modal-body {
                    @apply px-4 py-2;
                }
            }
            @media (max-width: 640px) {
                .modal-body {
                    @apply px-3 py-1.5;
                }
            }
            .modal-footer {
                @apply px-6 py-4 border-t flex justify-end gap-3;
            }
            @media (max-width: 768px) {
                .modal-footer {
                    @apply px-4 py-2 flex-wrap gap-2;
                }
            }
            @media (max-width: 640px) {
                .modal-footer {
                    @apply px-3 py-1.5 flex-wrap gap-1;
                }
            }
            .form-group {
                @apply mb-4;
            }
            @media (max-width: 640px) {
                .form-group {
                    @apply mb-3;
                }
            }
            .form-label {
                @apply block text-sm font-medium text-gray-700 mb-1;
            }
            .form-control {
                @apply w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-primary focus:border-primary;
            }
            @media (max-width: 640px) {
                .form-control {
                    @apply px-2 py-1.5 text-sm;
                }
            }
            .btn {
                @apply px-4 py-2 rounded-md font-medium cursor-pointer transition-colors;
            }
            @media (max-width: 640px) {
                .btn {
                    @apply px-3 py-1.5 text-sm;
                }
            }
            @media (max-width: 480px) {
                .btn {
                    @apply px-2.5 py-1 text-xs;
                }
                .form-control {
                    @apply px-2 py-1 text-xs;
                }
                #usagePromptInput, #usageResultContent {
                    @apply h-16;
                }
            }
            .btn-primary {
                @apply bg-primary text-white hover:bg-primary/90;
            }
            .btn-secondary {
                @apply bg-gray-200 text-gray-800 hover:bg-gray-300;
            }
            .btn-outline {
                @apply border border-gray-300 text-gray-700 hover:bg-gray-50;
            }
            .status-indicator {
                @apply inline-block w-2 h-2 rounded-full mr-2;
            }
            .config-section {
                @apply border rounded-lg p-4 mb-6 transition-all duration-300;
            }
            .config-header {
                @apply flex justify-between items-center cursor-pointer mb-3;
            }
            .collapsible-content {
                @apply transition-all duration-300 ease-in-out;
            }
            .model-search-container {
                @apply relative mb-2;
            }
            .model-search-input {
                @apply w-full pl-9 pr-3 py-2 border border-gray-300 rounded-md text-sm focus:outline-none focus:ring-2 focus:ring-primary focus:border-primary;
            }
            .model-search-icon {
                @apply absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400;
            }
            .model-option-highlight {
                @apply bg-yellow-100;
            }
            
            /* 迷你模式样式 */
            .modal-container.mini-mode {
                @apply max-w-sm h-auto;
            }
            .mini-header {
                @apply px-4 py-2 border-b flex justify-between items-center;
            }
            .mini-body {
                @apply px-4 py-3;
            }
            .mini-input-container {
                @apply flex gap-2 items-end;
            }
            .mini-prompt-input {
                @apply flex-1 px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-primary focus:border-primary resize-none overflow-hidden;
                min-height: 40px;
                max-height: 120px;
            }
            .mini-send-btn {
                @apply px-3 py-2 rounded-md font-medium cursor-pointer transition-colors bg-primary text-white hover:bg-primary/90 flex items-center justify-center;
                min-width: 60px;
                height: 40px;
            }
            .mini-send-btn.loading {
                @apply bg-gray-400 cursor-not-allowed;
            }
            
            /* 输出区域文本域样式 - 让它看起来更像内容区域 */
            #usageResultContent {
                @apply bg-transparent border-none outline-none resize-none p-0 m-0;
                font-family: inherit;
                font-size: inherit;
                line-height: inherit;
                color: inherit;
                background-color: transparent;
            }
            
            /* 移动端优化 */
            @media (max-width: 768px) {
                /* 模态框移动端优化 */
                .modal-container {
                    @apply w-full h-screen max-w-full mx-0 my-0 rounded-none;
                }
                
                /* 输入区域移动端优化 */
                #usagePromptInput {
                    @apply h-24 text-sm;
                }
                
                /* 按钮移动端优化 */
                .btn {
                    @apply text-sm px-3 py-2;
                }
                
                /* 网格布局移动端优化 */
                .grid-container {
                    grid-template-columns: 1fr;
                    gap: 1rem;
                }
                
                /* 卡片移动端优化 */
                .template-card {
                    @apply mb-2;
                }
                
                /* 模态框内容移动端优化 */
                .modal-body {
                    @apply px-4 py-3;
                }
                
                /* 配置界面移动端优化 */
                #aiConfigView .grid-cols-12 {
                    @apply grid-cols-1;
                }
                
                #aiConfigView .col-span-3,
                #aiConfigView .col-span-9 {
                    @apply col-span-1 border-r-0;
                }
                
                /* 模板配置界面移动端优化 */
                #templateConfigView .grid-cols-12 {
                    @apply grid-cols-1;
                }
                
                #templateConfigView .col-span-3,
                #templateConfigView .col-span-9 {
                    @apply col-span-1 border-r-0 mb-4;
                }
                
                /* 使用界面移动端优化 */
                #usageView .grid-cols-12 {
                    @apply grid-cols-1;
                }
                
                #usageView .col-span-4,
                #usageView .col-span-8 {
                    @apply col-span-1 border-r-0 mb-4;
                }
                
                /* 输入框移动端优化 */
                .form-control {
                    @apply text-sm;
                }
                
                /* 标签页移动端优化 */
                .tab-button {
                    @apply text-sm px-2 py-1;
                }
                
                /* 搜索框移动端优化 */
                #searchInput {
                    @apply text-sm;
                }
                
                /* 状态栏移动端优化 */
                #usageStatusBar,
                #configStatusBar,
                #templateStatusBar {
                    @apply text-xs top-8 max-w-[90vw];
                }
                
                /* 迷你模式移动端优化 */
                .modal-container.mini-mode {
                    @apply max-w-full h-auto;
                }
                
                .mini-input-container {
                    @apply flex-col gap-1;
                }
                
                .mini-prompt-input {
                    @apply w-full;
                }
                
                .mini-send-btn {
                    @apply w-full;
                }
            }
            
            @media (max-width: 480px) {
                /* 超小屏幕优化 */
                .modal-header {
                    @apply px-3 py-2;
                }
                
                .modal-body {
                    @apply px-3 py-2;
                }
                
                .modal-footer {
                    @apply px-3 py-2;
                }
                
                .btn {
                    @apply text-xs px-2 py-1;
                }
                
                .form-control {
                    @apply text-xs px-2 py-1;
                }
                
                #usagePromptInput {
                    @apply h-20 text-xs;
                }
                
                #usageResultContent {
                    @apply h-16 text-xs;
                }
                
                .template-card {
                    @apply p-3;
                }
                
                .grid-container {
                    gap: 0.5rem;
                    padding: 0.5rem;
                }
                
                /* 模态框全屏 */
                .modal-container {
                    @apply h-screen rounded-none;
                }
            }
            
            /* 移除文本域的默认外观 */
            #usageResultContent {
                -webkit-appearance: none;
                -moz-appearance: none;
                appearance: none;
                /* 确保文本域看起来像普通内容 */
                cursor: text;
            }
            
            #usageResultContent:focus {
                @apply outline-none ring-0;
            }
            
            /* 为输出文本框添加浅边框 */
            #usageResultContent {
                border: 1px solid #e5e7eb !important; /* 浅灰色边框 */
            }
            
            #usageResultContent:focus {
                border-color: #3b82f6 !important; /* 聚焦时蓝色边框 */
            }
            
            .hidden {
                display: none !important;
            }
            
            /* 用户模板搜索下拉框样式 */
            .template-dropdown-item {
                @apply px-3 py-2 cursor-pointer hover:bg-gray-100 transition-colors duration-150;
                border-bottom: 1px solid #f3f4f6;
            }
            .template-dropdown-item:last-child {
                border-bottom: none;
            }
            .template-dropdown-item:hover {
                @apply bg-gray-50;
            }
            .template-dropdown-item.selected {
                @apply bg-primary text-white;
            }
            .template-dropdown-item.custom-option {
                @apply bg-blue-50 border-l-4 border-blue-400;
            }
            .template-dropdown-item.custom-option:hover {
                @apply bg-blue-100;
            }
            .template-dropdown-item.no-results {
                @apply text-gray-500 text-sm italic cursor-default hover:bg-transparent;
            }
            .template-dropdown-item.highlight {
                @apply bg-yellow-100;
            }
            
            /* 迷你模式模板标签样式 */
            .mini-template-tag {
                @apply inline-flex items-center px-3 py-2 text-sm rounded-lg cursor-pointer transition-all duration-200;
                @apply bg-white text-gray-700 hover:bg-gray-50 border border-gray-200 shadow-sm;
                @apply hover:shadow-md hover:border-gray-300;
                max-width: 140px;
                white-space: nowrap;
                overflow: hidden;
                text-overflow: ellipsis;
            }
            .mini-template-tag:hover {
                @apply bg-gray-50 border-gray-300 shadow-md;
                transform: translateY(-1px);
            }
            .mini-template-tag.selected {
                @apply bg-blue-50 text-blue-700 border-blue-200 shadow-md;
                transform: translateY(-1px);
            }
            .mini-template-tag.custom {
                @apply bg-gradient-to-r from-blue-50 to-indigo-50 text-blue-700 border-blue-200;
            }
            .mini-template-tag.custom:hover {
                @apply bg-gradient-to-r from-blue-100 to-indigo-100 border-blue-300;
            }
            .mini-template-tag.custom.selected {
                @apply bg-gradient-to-r from-blue-100 to-blue-200 text-blue-800 border-blue-300;
            }
            
            /* 更多标签样式 */
            .mini-template-more {
                @apply inline-flex items-center px-3 py-2 text-sm rounded-lg cursor-pointer transition-all duration-200;
                @apply bg-gray-100 text-gray-600 hover:bg-gray-200 border border-dashed border-gray-300;
                @apply hover:shadow-md;
            }
            .mini-template-more:hover {
                @apply bg-gray-200 border-gray-400;
                transform: translateY(-1px);
            }
        }
    </style>
</head>

<body class="p-8" style="background: transparent;">
    <!-- 触发弹窗的按钮 -->
    <button id="openAIModalBtn" class="btn btn-primary">
        <i class="fa fa-robot mr-2"></i>打开AI工具
    </button>

    <!-- AI服务弹窗组件 -->
    <div id="aiServiceModal" class="modal-backdrop hidden">
        <div class="modal-container" id="modalContainer">
            <!-- 完整模式头部 -->
            <div class="modal-header" id="fullHeader">
                <h3 id="modalTitle" class="text-xl font-bold text-neutral">AI服务调用工具</h3>
                <div class="flex items-center gap-2">
                    <button id="minimizeButton" class="text-gray-500 hover:text-gray-700 transition-colors"
                        title="切换到迷你模式">
                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20 12H4"></path>
                        </svg>
                    </button>
                    <button id="closeModalBtn" class="text-gray-500 hover:text-gray-700">
                        <i class="fa fa-times text-xl"></i>
                    </button>
                </div>
            </div>

            <!-- 迷你模式头部 -->
            <div class="mini-header hidden" id="miniHeader">
                <h3 id="miniModalTitle" class="text-lg font-bold text-neutral">AI服务</h3>
                <div class="flex items-center gap-2">
                    <button id="expandButton" class="text-gray-500 hover:text-gray-700 transition-colors"
                        title="切换到完整模式">
                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                d="M4 8V4m0 0h4M4 4l5 5m11-1V4m0 0h-4m4 0l-5 5M4 16v4m0 0h4m-4 0l5-5m11 5l-5-5m5 5v-4m0 4h-4">
                            </path>
                        </svg>
                    </button>
                    <button id="closeMiniModalBtn" class="text-gray-500 hover:text-gray-700">
                        <i class="fa fa-times text-lg"></i>
                    </button>
                </div>
            </div>

            <!-- 弹窗主体 -->
            <div class="modal-body">
                <form id="aiServiceForm">
                    <!-- AI使用界面 -->
                    <div id="aiUsageView" class="view-container">
                        <div id="usageConfigStatusBar"
                            class="absolute left-1/2 -translate-x-1/2 w-auto max-w-[760px] top-40 z-20 p-3 rounded-md text-sm hidden">
                            <!-- 配置状态将动态更新 -->
                        </div>
                        <!-- 使用态状态提示条：始终保留，在操作时显示提示/成功/失败 -->
                        <div id="usageStatusIndicator" class="mb-4 p-3 rounded-md text-sm hidden"></div>

                        <!-- 平台/模型/配置：模型占剩余宽度，配置按钮仅占自身宽度 -->
                        <div class="grid gap-4 items-end grid-cols-1 md:grid-cols-3 lg:grid-cols-3"
                            style="grid-template-columns: auto 1fr auto;">
                            <div>
                                <label class="form-label" for="usagePlatformSelect">平台</label>
                                <select id="usagePlatformSelect" class="form-control" required>
                                    <option value="">-- 请选择平台 --</option>
                                    <!-- 平台选项将通过JS动态填充（与配置中的 platformSelect 保持一致） -->
                                </select>
                            </div>

                            <div class="flex flex-col">
                                <label class="form-label" for="usageModelSelect">模型</label>
                                <div class="flex items-center">
                                    <select id="usageModelSelect" class="form-control flex-1" required>
                                        <option value="">-- 请选择模型 --</option>
                                        <!-- 常用模型选项将通过JS动态填充 -->
                                    </select>
                                </div>
                            </div>

                            <div class="flex items-end justify-end">
                                <button type="button" id="quickConfigBtn"
                                    class="btn btn-outline whitespace-nowrap w-auto" title="配置平台">
                                    <i class="fa fa-cog mr-2"></i>配置
                                </button>
                            </div>
                        </div>

                        <!-- 用户提示词模板行 -->
                        <div class="form-group mt-4">
                            <div class="flex gap-3 items-center flex-col sm:flex-row">
                                <div class="flex-1 w-full">
                                    <label class="form-label" for="userTemplateSearchInput">用户提示词模板</label>
                                    <div class="flex flex-wrap items-center gap-2">
                                        <div class="relative flex-1">
                                            <div class="relative">
                                                <input type="text" id="userTemplateSearchInput" class="form-control"
                                                    placeholder="搜索模板..." autocomplete="off">
                                                <div
                                                    class="absolute inset-y-0 right-0 flex items-center pr-3 pointer-events-none">
                                                    <svg class="w-4 h-4 text-gray-400" fill="none" stroke="currentColor"
                                                        viewBox="0 0 24 24">
                                                        <path stroke-linecap="round" stroke-linejoin="round"
                                                            stroke-width="2" d="M19 9l-7 7-7-7"></path>
                                                    </svg>
                                                </div>
                                            </div>
                                            <div id="userTemplateDropdown"
                                                class="absolute top-full left-0 right-0 mt-1 bg-white border border-gray-300 rounded-md shadow-lg max-h-48 overflow-y-auto z-10 hidden">
                                                <!-- 模板选项将动态填充 -->
                                            </div>
                                        </div>
                                        <button type="button" id="userTemplateManageBtn"
                                            class="btn btn-outline inline-flex whitespace-nowrap items-center">
                                            <i class="fa fa-cog mr-1"></i>管理
                                        </button>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- 系统提示词模板行（保持原有功能但界面元素隐藏） -->
                        <div class="form-group mt-4 hidden" id="systemTemplateGroup">
                            <div class="flex gap-3 items-center flex-col sm:flex-row">
                                <div class="flex-1 w-full">
                                    <label class="form-label" for="promptTemplateSelect">系统提示词模板</label>
                                    <div class="flex flex-wrap items-center gap-2">
                                        <select id="promptTemplateSelect" class="form-control flex-1">
                                            <option value="">无模板</option>
                                            <!-- 模板项可由JS填充 -->
                                        </select>
                                        <button type="button" id="promptTemplateConfigBtn"
                                            class="btn btn-outline inline-flex whitespace-nowrap items-center">配置</button>
                                        <button type="button" id="promptTemplateApplyBtn"
                                            class="btn btn-primary inline-flex whitespace-nowrap items-center">应用</button>
                                        <button type="button" id="promptTemplatePreviewBtn"
                                            class="btn btn-secondary inline-flex whitespace-nowrap items-center">预览</button>
                                    </div>
                                </div>

                                <div class="w-full sm:w-1/3">
                                    <label class="form-label" for="promptParamsSelect">参数</label>
                                    <div class="flex gap-2">
                                        <select id="promptParamsSelect" class="form-control flex-1">
                                            <option value="">{{name}} 节点名称</option>
                                            <!-- 更多参数由JS填充 -->
                                        </select>
                                        <button type="button" id="insertParamBtn"
                                            class="btn btn-outline inline-flex whitespace-nowrap items-center">插入</button>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- 输入与输出区域 -->
                        <div class="space-y-4 mt-4">
                            <!-- 用户提示词输入区域 -->
                            <div class="w-full">
                                <label class="form-label" for="userPromptInput">用户提示词</label>
                                <textarea id="userPromptInput" class="form-control h-16 sm:h-24"
                                    placeholder="请输入您的特定要求（可选），如果没有可直接点击发送。"></textarea>
                            </div>

                            <!-- 系统提示词输入区域（保持原有功能但置灰且禁止编辑） -->
                            <div class="w-full">
                                <label class="form-label" for="usagePromptInput">系统提示词</label>
                                <div class="flex justify-end items-center gap-2 text-xs text-gray-600 mt-1 hidden">
                                    <label class="inline-flex items-center cursor-pointer">
                                        <input type="checkbox" id="toggleTemplateViewChk" class="mr-1">

                                    </label>
                                    <span>当前模式：<span id="promptViewModeText">占位符</span></span>
                                </div>
                                <textarea id="usagePromptInput" class="form-control h-28 sm:h-52 md:h-20" disabled
                                    placeholder="系统提示词已锁定，如需修改请联系管理员..." required></textarea>

                                <div class="flex flex-col sm:flex-row justify-end gap-2 sm:gap-3 mt-3">
                                    <button id="usageSubmitBtn" type="button"
                                        class="btn btn-primary w-full sm:w-auto touch-manipulation">
                                        <i class="fa fa-paper-plane mr-2"></i>发送
                                    </button>
                                </div>
                            </div>

                            <!-- 输出区域 -->
                            <div class="w-full">
                                <label class="form-label">输出</label>
                                <textarea id="usageResultContent"
                                    class="whitespace-pre-wrap break-words w-full h-28 sm:h-52 md:h-20 bg-neutral-light p-3 rounded-md overflow-y-auto outline-none resize-none leading-relaxed"
                                    placeholder="AI输出结果将显示在这里..." rows="1"></textarea>
                                <div class="flex flex-col sm:flex-row justify-end gap-2 sm:gap-3 mt-3">
                                    <button id="saveApplyOutputBtn" type="button"
                                        class="btn btn-primary w-full sm:w-auto touch-manipulation">
                                        保存并应用
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- AI配置界面：左侧已配置平台列表 + 右侧单平台配置 -->
                    <div id="aiConfigView" class="view-container hidden">
                        <div id="configStatusBar"
                            class="absolute left-1/2 -translate-x-1/2 w-auto max-w-[760px] top-12 z-20 p-3 rounded-md text-sm hidden">
                            <i class="fa fa-info-circle text-blue-600 mr-2"></i>请选择平台并填写必要信息，完成后点击“保存配置”。
                        </div>

                        <div class="grid grid-cols-12 gap-4 md:grid-cols-12 sm:grid-cols-1">
                            <!-- 左侧：已配置平台列表（窄侧栏） -->
                            <div
                                class="col-span-3 md:col-span-3 sm:col-span-12 sm:border-r-0 md:border-r md:pr-3 sm:mb-4">
                                <div class="mb-2">
                                    <div class="mb-2">
                                        <div class="flex items-center justify-between">
                                            <h4 class="font-medium">已配置平台列表</h4>
                                        </div>
                                        <div class="mt-2 flex items-center gap-2 flex-wrap">
                                            <button id="addPlatformBtn" type="button"
                                                class="btn btn-outline text-[12px] px-1 py-0.5 whitespace-nowrap">添加</button>
                                            <button id="exportConfigsBtn" type="button"
                                                class="btn btn-outline text-[12px] px-1 py-0.5 whitespace-nowrap">导出</button>
                                            <button id="importConfigsBtn" type="button"
                                                class="btn btn-outline text-[12px] px-1 py-0.5 whitespace-nowrap">导入</button>
                                            <input id="importFileInput" type="file" accept="application/json"
                                                class="hidden" />
                                        </div>
                                    </div>
                                </div>
                                <div id="savedPlatformsList"
                                    class="flex flex-col gap-1 max-h-[30vh] sm:max-h-[20vh] md:max-h-[60vh] overflow-y-auto">
                                    <!-- JS 填充已保存平台项 -->
                                </div>
                            </div>

                            <!-- 右侧：单个平台配置（显示被选中的平台） -->
                            <div class="col-span-9 md:col-span-9 sm:col-span-12 h-full overflow-y-auto">
                                <div class="config-section">
                                    <div class="config-header">
                                        <h4 class="font-semibold text-lg">AI配置（单平台）</h4>
                                    </div>

                                    <div id="configContent" class="collapsible-content">


                                        <!-- 平台选择（用于新增/切换） -->
                                        <div class="form-group">
                                            <label class="form-label" for="platformSelect">选择AI平台</label>
                                            <select id="platformSelect" class="form-control" required>
                                                <option value="">-- 请选择平台 --</option>
                                                <!-- 选项将通过JS动态填充 -->
                                            </select>
                                        </div>

                                        <!-- API密钥配置 -->
                                        <div class="form-group">
                                            <div class="flex justify-between items-center">
                                                <label class="form-label" for="apiKeyInput">API 密钥</label>
                                                <a id="apiKeyHelpLink" href="#" target="_blank"
                                                    class="text-xs text-primary hover:underline">
                                                    <i class="fa fa-external-link mr-1"></i>获取API密钥
                                                </a>
                                            </div>
                                            <div class="relative">
                                                <input type="password" id="apiKeyInput" class="form-control pr-10"
                                                    placeholder="输入平台API密钥">
                                                <span id="toggleKeyVisibility"
                                                    class="absolute right-3 top-1/2 transform -translate-y-1/2 text-gray-500 cursor-pointer select-none">
                                                    <i class="fa fa-eye-slash"></i>
                                                </span>
                                            </div>
                                            <div class="mt-2 flex items-center justify-end gap-2">
                                                <button type="button" id="verifyApiKeyBtn"
                                                    class="btn btn-outline text-sm">
                                                    校验密钥
                                                </button>
                                            </div>
                                            <p class="text-xs text-gray-500 mt-1">密钥将按平台保存在浏览器本地存储中</p>
                                        </div>

                                        <!-- 平台特定配置 -->
                                        <div id="platformSpecificConfigs">
                                            <div id="cloudflareConfig" class="form-group hidden">
                                                <label class="form-label" for="cloudflareAccountId">Cloudflare
                                                    账户ID</label>
                                                <input type="text" id="cloudflareAccountId" class="form-control"
                                                    placeholder="输入Cloudflare账户ID">
                                            </div>

                                            <div id="azureConfig" class="form-group hidden">
                                                <label class="form-label" for="azureEndpoint">Azure 终结点</label>
                                                <input type="text" id="azureEndpoint" class="form-control"
                                                    placeholder="输入Azure OpenAI终结点">
                                            </div>
                                        </div>

                                        <!-- 常用模型设置（带搜索功能） -->
                                        <div class="form-group">
                                            <div class="flex justify-between items-center">
                                                <label class="form-label">常用模型设置</label>
                                                <button type="button" id="refreshFavoriteModelsBtn"
                                                    class="text-sm text-primary hover:text-primary/80">
                                                    <i class="fa fa-refresh mr-1"></i>刷新模型
                                                </button>
                                            </div>

                                            <div class="model-search-container" id="modelSearchContainer">
                                                <i class="fa fa-search model-search-icon"></i>
                                                <input type="text" id="modelSearchInput" class="model-search-input"
                                                    placeholder="搜索模型...">
                                            </div>

                                            <div id="favoriteModelsContainer"
                                                class="border rounded-md p-3 bg-gray-50 mt-2">
                                                <div id="favoriteModelsList" class="max-h-48 overflow-y-auto">
                                                    <!-- 常用模型复选框将通过JS动态填充 -->
                                                </div>
                                            </div>

                                            <div id="modelLoadingIndicator" class="hidden mt-2 text-sm text-gray-600">
                                                <i class="fa fa-circle-o-notch fa-spin mr-1"></i>正在获取模型列表...
                                            </div>
                                        </div>

                                        <!-- 高级选项 -->
                                        <div class="form-group mt-6">
                                            <details class="group">
                                                <summary class="text-sm font-medium text-gray-700 cursor-pointer">高级选项
                                                </summary>
                                                <div class="mt-2 grid grid-cols-1 gap-4 sm:grid-cols-2">
                                                    <div>
                                                        <label class="form-label" for="temperatureInput">温度
                                                            (0-1)</label>
                                                        <input type="number" id="temperatureInput" class="form-control"
                                                            min="0" max="1" step="0.1" value="0.7">
                                                    </div>
                                                    <div>
                                                        <label class="form-label" for="maxTokensInput">最大Token数</label>
                                                        <input type="number" id="maxTokensInput" class="form-control"
                                                            min="1" max="4096" value="1000">
                                                    </div>
                                                </div>
                                            </details>
                                        </div>


                                    </div>

                                </div>
                                <!-- 底部操作 -->
                                <div class="flex flex-col sm:flex-row justify-end gap-2 sm:gap-3 mt-4">
                                    <button id="configBackBtn" type="button"
                                        class="btn btn-outline w-full sm:w-auto touch-manipulation">返回</button>
                                    <button id="configSaveBtn" type="button"
                                        class="btn btn-primary w-full sm:w-auto touch-manipulation">
                                        <i class="fa fa-save mr-2"></i>保存配置
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- 模板配置界面：左侧模板列表 + 右侧编辑 -->
                    <div id="templateConfigView" class="view-container hidden">
                        <div id="templateStatusBar"
                            class="absolute left-1/2 -translate-x-1/2 w-auto max-w-[760px] top-12 z-20 p-3 rounded-md text-sm bg-blue-100 text-blue-800">
                            <i
                                class="fa fa-info-circle text-blue-600 mr-2"></i>管理提示词模板：支持新增、编辑、删除、导入、导出。保存后将更新使用界面的模板下拉。
                        </div>
                        <div class="grid grid-cols-1 sm:grid-cols-12 gap-4">
                            <div class="col-span-12 sm:col-span-3 border-r-0 sm:border-r sm:pr-3 mb-4 sm:mb-0">
                                <div class="mb-2">
                                    <div class="flex flex-wrap items-center gap-1 sm:gap-2 touch-manipulation">
                                        <button id="addTemplateBtn" type="button"
                                            class="btn btn-outline text-[12px] px-1 py-0.5 whitespace-nowrap">新增</button>
                                        <button id="exportTemplatesBtn" type="button"
                                            class="btn btn-outline text-[12px] px-1 py-0.5 whitespace-nowrap">导出</button>
                                        <button id="importTemplatesBtn" type="button"
                                            class="btn btn-outline text-[12px] px-1 py-0.5 whitespace-nowrap">导入</button>
                                        <input id="importTemplatesFileInput" type="file" accept="application/json"
                                            class="hidden" />
                                    </div>
                                </div>
                                <div id="templateList"
                                    class="flex flex-col gap-1 max-h-[40vh] sm:max-h-[60vh] overflow-y-auto"></div>
                            </div>
                            <div class="col-span-12 sm:col-span-9 h-full overflow-y-auto">
                                <div class="config-section">
                                    <div class="config-header">
                                        <h4 class="font-semibold text-lg">模板编辑</h4>
                                    </div>
                                    <div class="collapsible-content max-h-[65vh] overflow-y-auto">
                                        <div class="grid grid-cols-1 gap-4 sm:grid-cols-2">
                                            <div>
                                                <label class="form-label" for="tplNameInput">名称</label>
                                                <input id="tplNameInput" type="text" class="form-control"
                                                    placeholder="模板名称">
                                            </div>
                                            <div>
                                                <label class="form-label" for="tplTypeInput">类型</label>
                                                <input id="tplTypeInput" type="text" class="form-control"
                                                    placeholder="如：通用/扩展/总结...">
                                            </div>
                                            <div>
                                                <label class="form-label" for="tplCallerInput">调用方</label>
                                                <input id="tplCallerInput" type="text" class="form-control"
                                                    placeholder="如：AI应用/外部调用...">
                                            </div>
                                            <div>
                                                <label class="form-label" for="tplDescInput">描述</label>
                                                <input id="tplDescInput" type="text" class="form-control"
                                                    placeholder="该模板的用途说明">
                                            </div>
                                        </div>
                                        <div class="mt-3">
                                            <label class="form-label">参数（名称 与 描述）</label>
                                            <div id="tplParamsContainer" class="space-y-2"></div>
                                            <button id="addTplParamBtn" type="button"
                                                class="btn btn-outline text-[12px] px-2 py-1 mt-2 touch-manipulation">添加参数</button>
                                        </div>
                                        <div class="mt-3">
                                            <label class="form-label" for="tplContentInput">模板内容</label>
                                            <textarea id="tplContentInput" class="form-control h-48"
                                                placeholder="模板正文，支持占位符"></textarea>
                                        </div>
                                        <!-- 底部固定按钮已移动至 modal-footer 的 templateViewFooter -->
                                        <div class="flex flex-col sm:flex-row justify-end gap-2 sm:gap-3 mt-4">
                                            <button id="tplBackBtn" type="button"
                                                class="btn btn-outline w-full sm:w-auto touch-manipulation">返回</button>
                                            <button id="tplSaveBtn" type="button"
                                                class="btn btn-primary w-full sm:w-auto touch-manipulation"><i
                                                    class="fa fa-save mr-2"></i>保存模板</button>
                                        </div>

                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- 迷你模式界面 -->
                    <div id="aiMiniView" class="view-container hidden">
                        <div class="px-2 py-2">
                            <!-- 模板标签区域（平铺显示在输入框上方） -->
                            <div id="miniTemplateTags" class="mb-2 flex flex-wrap gap-2">
                                <!-- 模板标签将动态填充 -->
                            </div>

                            <!-- 输入区域 -->
                            <div class="flex items-center gap-2 mb-2">
                                <!-- 输入框（复用完整模式的用户提示词输入框） -->
                                <textarea id="miniUserPromptInput" class="form-control flex-1 h-14 text-sm resize-none"
                                    placeholder="如无额外要求，可直接点击发送按钮开始生成。"></textarea>

                                <!-- 发送按钮 -->
                                <button type="button" id="miniSendBtn" class="btn btn-primary btn-sm h-14 px-3"
                                    title="发送">
                                    <i class="fa fa-paper-plane"></i>
                                </button>
                            </div>

                            <!-- 管理按钮（隐藏） -->
                            <button type="button" id="miniUserTemplateManageBtn"
                                class="btn btn-outline btn-sm h-8 px-2 text-xs whitespace-nowrap hidden">
                                <i class="fa fa-cog mr-1"></i>管理
                            </button>
                        </div>

                        <!-- 状态栏 -->
                        <div class="px-2 pb-2">
                            <span id="miniStatus" class="text-xs text-gray-500">就绪</span>
                        </div>
                    </div>

            </div>
        </div>

        <script>
            // AI服务类
            class AIPlatformService {
                constructor() {
                    // 平台配置将在初始化时从JSON文件加载
                    this.platforms = {};

                    // 存储配置信息
                    this.config = {
                        selectedPlatform: null,
                        selectedModel: null,
                        apiKey: null,
                        azureEndpoint: null,
                        cloudflareAccountId: null
                    };
                }

                // 异步初始化方法，从JSON文件加载平台配置
                async initialize() {
                    try {
                        const response = await fetch('./platform-configs.json');
                        if (!response.ok) {
                            throw new Error(`加载平台配置失败: ${response.statusText}`);
                        }

                        const configData = await response.json();
                        this.platforms = configData.platforms;

                        // 初始化模型数组和获取状态
                        Object.keys(this.platforms).forEach(platform => {
                            if (!this.platforms[platform].models) {
                                this.platforms[platform].models = [];
                            }
                            if (!this.platforms[platform].modelsFetched) {
                                this.platforms[platform].modelsFetched = false;
                            }
                        });

                        console.log('平台配置加载成功:', Object.keys(this.platforms));
                        return true;
                    } catch (error) {
                        console.error('加载平台配置失败:', error);
                        // 如果加载失败，使用默认空配置
                        this.platforms = {};
                        return false;
                    }
                }

                getPlatforms() {
                    return { ...this.platforms };
                }

                getModels(platform) {
                    if (!this.platforms[platform]) {
                        throw new Error(`不支持的AI平台: ${platform}`);
                    }
                    if ((platform === 'anthropic' || platform === 'modelscope') && this.platforms[platform].models.length === 0) {
                        return [...(this.platforms[platform].predefinedModels || [])];
                    }
                    return [...this.platforms[platform].models];
                }

                async fetchModels(platform, apiKey = null, options = {}) {
                    if (!this.platforms[platform]) {
                        throw new Error(`不支持的AI平台: ${platform}`);
                    }

                    const platformInfo = this.platforms[platform];

                    if (platform === 'anthropic') {
                        platformInfo.models = [...platformInfo.predefinedModels];
                        platformInfo.modelsFetched = true;
                        return platformInfo.models;
                    }

                    if (platform === 'modelscope') {
                        platformInfo.models = [...platformInfo.predefinedModels];
                        platformInfo.modelsFetched = true;
                        return platformInfo.models;
                    }

                    if (platform === 'bigmodel') {
                        platformInfo.models = [...platformInfo.predefinedModels];
                        platformInfo.modelsFetched = true;
                        return platformInfo.models;
                    }

                    if (platform === 'azure') {
                        console.warn('Azure平台不支持动态获取模型，请手动输入模型名称');
                        return [];
                    }

                    if (!platformInfo.modelsUrl) {
                        throw new Error(`平台 ${platform} 不支持动态获取模型`);
                    }

                    let url = platformInfo.modelsUrl;
                    if (platform === 'google' && apiKey) {
                        url = url.replace('API_KEY_PLACEHOLDER', apiKey);
                    }
                    if (platform === 'cloudflare' && options.cloudflareAccountId) {
                        url = url.replace('ACCOUNT_ID_PLACEHOLDER', options.cloudflareAccountId);
                    }

                    const headers = {
                        "Content-Type": "application/json"
                    };

                    if (apiKey) {
                        switch (platform) {
                            case 'openai':
                            case 'openrouter':
                            case 'silibase':
                                headers["Authorization"] = `Bearer ${apiKey}`;
                                break;
                            case 'cloudflare':
                                headers["Authorization"] = `Bearer ${apiKey}`;
                                break;
                        }
                    }

                    try {
                        const response = await fetch(url, {
                            method: "GET",
                            headers: headers
                        });

                        if (!response.ok) {
                            throw new Error(`获取模型列表失败: ${response.statusText}`);
                        }

                        const data = await response.json();
                        let models = [];

                        switch (platform) {
                            case 'openai':
                                models = data.data.map(model => model.id);
                                break;
                            case 'google':
                                models = data.models.map(model => model.name);
                                break;
                            case 'openrouter':
                                models = data.data.map(model => model.id);
                                break;
                            case 'cloudflare':
                                // Cloudflare 返回的模型字段通常为 id（如 "@cf/meta/llama-3-8b-instruct"），兼容 name/id
                                {
                                    const arr = Array.isArray(data?.result) ? data.result : (Array.isArray(data?.models) ? data.models : []);
                                    models = arr.map(m => m?.id || m?.name || m).filter(Boolean);
                                }
                                break;
                            case 'silibase':
                                // 兼容不同返回结构：优先 data.data，其次 data.models
                                if (Array.isArray(data?.data)) {
                                    models = data.data.map(m => m.id || m.name || m.model || m);
                                } else if (Array.isArray(data?.models)) {
                                    models = data.models.map(m => m.id || m.name || m.model || m);
                                } else {
                                    models = [];
                                }
                                break;
                        }

                        platformInfo.models = models;
                        platformInfo.modelsFetched = true;

                        return models;
                    } catch (error) {
                        console.error(`获取${platform}模型列表失败:`, error);
                        throw error;
                    }
                }

                configure(options) {
                    const { platform, model, apiKey, azureEndpoint, cloudflareAccountId } = options;

                    if (!this.platforms[platform]) {
                        throw new Error(`不支持的AI平台: ${platform}`);
                    }

                    if (platform === 'azure' && !azureEndpoint) {
                        throw new Error('Azure平台需要提供终结点(azureEndpoint)');
                    }

                    if (platform === 'cloudflare' && !cloudflareAccountId) {
                        throw new Error('Cloudflare平台需要提供账户ID(cloudflareAccountId)');
                    }

                    this.config = {
                        selectedPlatform: platform,
                        selectedModel: model,
                        apiKey: apiKey,
                        azureEndpoint: azureEndpoint || null,
                        cloudflareAccountId: cloudflareAccountId || null
                    };
                }

                isConfigured() {
                    // 原有逻辑：需要 platform/model/apiKey
                    // 增强：若 apiKey 缺失但平台在配置中提供了 proxyUrl（例如通过后端代理/Cloudflare Worker），
                    // 则视作已配置以允许代理转发路径（前端仍不保存或暴露任何密钥）。
                    if (!this.config.selectedPlatform || !this.config.selectedModel) {
                        return false;
                    }

                    // 特殊平台检查（azure/cloudflare 仍需其特定字段）
                    if (this.config.selectedPlatform === 'azure' && !this.config.azureEndpoint) {
                        return false;
                    }

                    if (this.config.selectedPlatform === 'cloudflare' && !this.config.cloudflareAccountId) {
                        return false;
                    }

                    // 如果已有 apiKey 则为已配置
                    if (this.config.apiKey && String(this.config.apiKey).trim() !== '') {
                        return true;
                    }

                    // 否则：检查是否存在代理配置（proxyUrl）供前端使用（比如 bigmodel.proxyUrl）
                    try {
                        const platformCfg = (this.platforms && this.platforms[this.config.selectedPlatform]) || null;
                        if (platformCfg && platformCfg.proxyUrl) {
                            return true;
                        }
                    } catch (e) { /* ignore */ }

                    return false;
                }

                async generate(options) {
                    if (!this.isConfigured()) {
                        throw new Error('AI服务尚未配置，请先调用configure方法');
                    }

                    const { prompt, temperature = 0.7, maxTokens = 1000 } = options;

                    switch (this.config.selectedPlatform) {
                        case 'openai':
                            return this._callOpenAI(prompt, temperature, maxTokens);
                        case 'anthropic':
                            return this._callAnthropic(prompt, temperature, maxTokens);
                        case 'google':
                            return this._callGoogle(prompt, temperature, maxTokens);
                        case 'azure':
                            return this._callAzure(prompt, temperature, maxTokens);
                        case 'openrouter':
                            return this._callOpenRouter(prompt, temperature, maxTokens);
                        case 'cloudflare':
                            return this._callCloudflare(prompt, temperature, maxTokens);
                        case 'silibase':
                            return this._callSilibase(prompt, temperature, maxTokens);
                        case 'modelscope':
                            return this._callModelScope(prompt, temperature, maxTokens);
                        case 'bigmodel':
                            return this._callZhipu(prompt, temperature, maxTokens);
                        default:
                            throw new Error(`不支持的AI平台: ${this.config.selectedPlatform}`);
                    }
                }


                async _callOpenAI(prompt, temperature, maxTokens) {
                    const url = `${this.platforms.openai.baseUrl}/chat/completions`;

                    const messages = Array.isArray(prompt)
                        ? prompt
                        : [{ role: "user", content: prompt }];

                    try {
                        const response = await fetch(url, {
                            method: "POST",
                            headers: {
                                "Content-Type": "application/json",
                                "Authorization": `Bearer ${this.config.apiKey}`
                            },
                            body: JSON.stringify({
                                model: this.config.selectedModel,
                                messages: messages,
                                temperature: temperature,
                                max_tokens: maxTokens
                            })
                        });

                        if (!response.ok) {
                            const error = await response.json();
                            throw new Error(`OpenAI API 错误: ${error.error?.message || '未知错误'}`);
                        }

                        const data = await response.json();
                        return data.choices[0].message.content;
                    } catch (error) {
                        console.error("OpenAI调用失败:", error);
                        throw error;
                    }
                }

                async _callAnthropic(prompt, temperature, maxTokens) {
                    const url = `${this.platforms.anthropic.baseUrl}/messages`;

                    const messages = Array.isArray(prompt)
                        ? prompt
                        : [{ role: "user", content: prompt }];

                    try {
                        const response = await fetch(url, {
                            method: "POST",
                            headers: {
                                "Content-Type": "application/json",
                                "x-api-key": this.config.apiKey,
                                "anthropic-version": "2023-06-01",
                                "User-Agent": ("AI Service Tool").replace(/[^\x00-\xFF]/g, '') // 移除非ASCII字符
                            },
                            body: JSON.stringify({
                                model: this.config.selectedModel,
                                messages: messages,
                                temperature: temperature,
                                max_tokens: maxTokens
                            })
                        });

                        if (!response.ok) {
                            const error = await response.json();
                            throw new Error(`Anthropic API 错误: ${error.error?.message || '未知错误'}`);
                        }

                        const data = await response.json();
                        return data.content[0].text;
                    } catch (error) {
                        console.error("Anthropic调用失败:", error);
                        throw error;
                    }
                }

                async _callGoogle(prompt, temperature, maxTokens) {
                    // 兼容模型名是否带有 "models/" 前缀，避免重复拼接
                    const modelPath = this.config.selectedModel?.startsWith('models/')
                        ? this.config.selectedModel
                        : `models/${this.config.selectedModel}`;
                    const url = `${this.platforms.google.baseUrl}/${modelPath}:generateContent?key=${this.config.apiKey}`;

                    const contents = Array.isArray(prompt)
                        ? prompt.map(msg => ({
                            role: msg.role === 'assistant' ? 'model' : 'user',
                            parts: [{ text: msg.content }]
                        }))
                        : [{
                            role: 'user',
                            parts: [{ text: prompt }]
                        }];

                    try {
                        const response = await fetch(url, {
                            method: "POST",
                            headers: {
                                "Content-Type": "application/json"
                            },
                            body: JSON.stringify({
                                contents: contents,
                                generationConfig: {
                                    temperature: temperature,
                                    maxOutputTokens: maxTokens
                                }
                            })
                        });

                        if (!response.ok) {
                            const error = await response.json();
                            throw new Error(`Google Gemini API 错误: ${error.error?.message || '未知错误'}`);
                        }

                        const data = await response.json();
                        return data.candidates[0].content.parts[0].text;
                    } catch (error) {
                        console.error("Google Gemini调用失败:", error);
                        throw error;
                    }
                }

                async _callAzure(prompt, temperature, maxTokens) {
                    const url = `${this.config.azureEndpoint}/openai/deployments/${this.config.selectedModel}/chat/completions?api-version=2023-10-01-preview`;

                    const messages = Array.isArray(prompt)
                        ? prompt
                        : [{ role: "user", content: prompt }];

                    try {
                        const response = await fetch(url, {
                            method: "POST",
                            headers: {
                                "Content-Type": "application/json",
                                "api-key": this.config.apiKey
                            },
                            body: JSON.stringify({
                                messages: messages,
                                temperature: temperature,
                                max_tokens: maxTokens
                            })
                        });

                        if (!response.ok) {
                            const error = await response.json();
                            throw new Error(`Azure OpenAI API 错误: ${error.error?.message || '未知错误'}`);
                        }

                        const data = await response.json();
                        return data.choices[0].message.content;
                    } catch (error) {
                        console.error("Azure OpenAI调用失败:", error);
                        throw error;
                    }
                }

                async _callOpenRouter(prompt, temperature, maxTokens) {
                    const url = `${this.platforms.openrouter.baseUrl}/chat/completions`;

                    const messages = Array.isArray(prompt)
                        ? prompt
                        : [{ role: "user", content: prompt }];

                    // 处理可能包含非ASCII字符的referer和title
                    const safeReferer = window.location.href.replace(/[^\x00-\xFF]/g, '');
                    const safeTitle = (document.title || "AI Application").replace(/[^\x00-\xFF]/g, '');

                    try {
                        const response = await fetch(url, {
                            method: "POST",
                            headers: {
                                "Content-Type": "application/json",
                                "Authorization": `Bearer ${this.config.apiKey}`,
                                "HTTP-Referer": safeReferer,
                                "X-Title": safeTitle
                            },
                            body: JSON.stringify({
                                model: this.config.selectedModel,
                                messages: messages,
                                temperature: temperature,
                                max_tokens: maxTokens
                            })
                        });

                        if (!response.ok) {
                            const error = await response.json();
                            throw new Error(`OpenRouter API 错误: ${error.error?.message || '未知错误'}`);
                        }

                        const data = await response.json();
                        return data.choices[0].message.content;
                    } catch (error) {
                        console.error("OpenRouter调用失败:", error);
                        throw error;
                    }
                }

                async _callCloudflare(prompt, temperature, maxTokens) {
                    const url = `https://api.cloudflare.com/client/v4/accounts/${this.config.cloudflareAccountId}/ai/run/${this.config.selectedModel}`;

                    // 按官方用法：若是消息数组，使用顶层 messages；若是字符串，使用顶层 prompt
                    let payload;
                    if (Array.isArray(prompt)) {
                        payload = {
                            messages: prompt,
                            temperature: temperature,
                            max_tokens: maxTokens
                        };
                    } else {
                        payload = {
                            prompt: String(prompt ?? ''),
                            temperature: temperature,
                            max_tokens: maxTokens
                        };
                    }

                    try {
                        const response = await fetch(url, {
                            method: "POST",
                            headers: {
                                "Content-Type": "application/json",
                                "Authorization": `Bearer ${this.config.apiKey}`
                            },
                            body: JSON.stringify(payload)
                        });

                        if (!response.ok) {
                            const error = await response.json();
                            throw new Error(`Cloudflare API 错误: ${error.errors?.[0]?.message || '未知错误'}`);
                        }

                        const data = await response.json();
                        if (data.result?.response) return data.result.response;
                        if (data.result?.choices?.[0]?.message?.content) return data.result.choices[0].message.content;
                        return JSON.stringify(data.result);
                    } catch (error) {
                        console.error("Cloudflare调用失败:", error);
                        throw error;
                    }
                }

                // 轻量连接校验（不依赖模型拉取）
                async verifyConnection() {
                    try {
                        // Cloudflare：只要提供了 Token 与 Account ID，即认为可用（真正错误在发送时返回）
                        if (this.config?.selectedPlatform === 'cloudflare') {
                            return !!(this.config?.apiKey && this.config?.cloudflareAccountId);
                        }
                        // 其他平台：简单返回 true，由实际调用阶段给出详细错误
                        return true;
                    } catch (_) {
                        return false;
                    }
                }

                async _callSilibase(prompt, temperature, maxTokens) {
                    const url = `${this.platforms.silibase.baseUrl}/chat/completions`;

                    const messages = Array.isArray(prompt)
                        ? prompt
                        : [{ role: "user", content: prompt }];

                    try {
                        const response = await fetch(url, {
                            method: "POST",
                            headers: {
                                "Content-Type": "application/json",
                                "Authorization": `Bearer ${this.config.apiKey}`
                            },
                            body: JSON.stringify({
                                model: this.config.selectedModel,
                                messages: messages,
                                temperature: temperature,
                                max_tokens: maxTokens
                            })
                        });

                        if (!response.ok) {
                            const error = await response.json();
                            throw new Error(`硅基流动 API 错误: ${error.error?.message || '未知错误'}`);
                        }

                        const data = await response.json();
                        return data.choices[0].message.content;
                    } catch (error) {
                        console.error("硅基流动调用失败:", error);
                        throw error;
                    }
                }

                async _callModelScope(prompt, temperature, maxTokens) {
                    const url = `${this.platforms.modelscope.baseUrl}/chat/completions`;

                    const messages = Array.isArray(prompt)
                        ? prompt
                        : [{ role: "user", content: prompt }];

                    try {
                        const response = await fetch(url, {
                            method: "POST",
                            headers: {
                                "Content-Type": "application/json",
                                "Authorization": `Bearer ${this.config.apiKey}`
                            },
                            body: JSON.stringify({
                                model: this.config.selectedModel,
                                messages: messages,
                                temperature: temperature,
                                max_tokens: maxTokens
                            })
                        });

                        if (!response.ok) {
                            const error = await response.json();
                            throw new Error(`魔搭社区 API 错误: ${error.error?.message || '未知错误'}`);
                        }

                        const responseText = await response.text();

                        // 处理可能的多个JSON对象拼接的情况
                        let data;
                        try {
                            data = JSON.parse(responseText);
                        } catch (parseError) {
                            // 如果直接解析失败，尝试分割多个JSON对象
                            const jsonStrings = responseText.trim().split(/}\s*{/);
                            if (jsonStrings.length > 1) {
                                // 有多个JSON对象，尝试解析第一个完整的
                                const firstJson = jsonStrings[0] + '}';
                                try {
                                    data = JSON.parse(firstJson);
                                    console.warn('ModelScope返回多个JSON对象，使用第一个:', responseText);
                                } catch (e) {
                                    // 如果第一个也解析失败，尝试解析最后一个
                                    const lastJson = '{' + jsonStrings[jsonStrings.length - 1];
                                    data = JSON.parse(lastJson);
                                    console.warn('ModelScope返回格式异常，使用最后一个JSON对象:', responseText);
                                }
                            } else {
                                throw parseError;
                            }
                        }

                        // 检查是否有错误信息
                        if (data.errors) {
                            throw new Error(`魔搭社区模型错误: ${data.errors.message || '未知错误'}`);
                        }

                        // 检查响应结构
                        if (!data.choices || !data.choices[0] || !data.choices[0].message) {
                            throw new Error('魔搭社区 API 响应格式错误: 缺少必要字段');
                        }

                        return data.choices[0].message.content;
                    } catch (error) {
                        console.error("魔搭社区调用失败:", error);

                        // 如果是模型特定的内容错误，提供更友好的错误信息
                        if (error.message.includes('inappropriate content')) {
                            throw new Error(`模型 "${this.config.selectedModel}" 返回了不当内容，请尝试其他模型或调整输入内容`);
                        }

                        throw error;
                    }
                }

                async _callZhipu(prompt, temperature, maxTokens) {
                    // 支持两种调用模式：
                    // 1) 用户提供 apiKey：按原有逻辑直接请求平台
                    // 2) 用户未提供 apiKey，但平台配置中提供了 proxyUrl：将请求转发到 proxyUrl（由 Cloudflare Worker 等在服务端持有内置 Key 并完成真实调用）
                    const messages = Array.isArray(prompt)
                        ? prompt
                        : [{ role: "user", content: prompt }];

                    const payload = {
                        model: this.config.selectedModel,
                        messages: messages,
                        temperature: temperature,
                        max_tokens: maxTokens
                    };

                    // 优先：若用户提供了 apiKey，则直接调用第三方
                    if (this.config.apiKey && String(this.config.apiKey).trim() !== '') {
                        const url = `${this.platforms.bigmodel.baseUrl}/chat/completions`;
                        try {
                            const response = await fetch(url, {
                                method: "POST",
                                headers: {
                                    "Content-Type": "application/json",
                                    "Authorization": `Bearer ${this.config.apiKey}`
                                },
                                body: JSON.stringify(payload)
                            });

                            if (!response.ok) {
                                const error = await response.json();
                                throw new Error(`智谱AI API 错误: ${error.error?.message || '未知错误'}`);
                            }

                            const data = await response.json();
                            return data.choices[0].message.content;
                        } catch (error) {
                            console.error("智谱AI调用失败（直接）:", error);
                            throw error;
                        }
                    }

                    // 回退：尝试使用平台配置中的 proxyUrl 转发（前端不含/暴露任何内置key）
                    const proxyUrl = this.platforms.bigmodel && this.platforms.bigmodel.proxyUrl;
                    if (!proxyUrl) {
                        throw new Error('未配置 API Key，且未提供 proxyUrl 以进行安全转发。请在设置中填写 API Key 或配置代理。');
                    }

                    try {
                        // 向 proxy 发起请求，proxy 在服务端持有实际 Key 并完成调用
                        // 请求格式为 { provider: 'bigmodel', path: '/chat/completions', method: 'POST', payload: {...} }
                        const proxyRequest = {
                            provider: 'bigmodel',
                            method: 'POST',
                            path: '/chat/completions',
                            payload: payload
                        };

                        const resp = await fetch(proxyUrl, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                                // 注意：不在前端添加任何 Authorization 头
                            },
                            body: JSON.stringify(proxyRequest)
                        });

                        if (!resp.ok) {
                            let txt = await resp.text().catch(() => '');
                            let errMsg = `代理请求失败: ${resp.status} ${resp.statusText}` + (txt ? (' - ' + txt) : '');
                            throw new Error(errMsg);
                        }

                        const data = await resp.json();

                        // 期望代理直接返回第三方的响应结构或标准化结构 { success: true, data: {...} } 或直接转发原始响应
                        // 尝试兼容原有处理：若代理返回 { choices: [...] } 兼容直接读取；否则若代理包裹在 data 字段则读取 data.choices
                        let result;
                        if (Array.isArray(data?.choices)) {
                            result = data.choices[0]?.message?.content;
                        } else if (Array.isArray(data?.data?.choices)) {
                            result = data.data.choices[0]?.message?.content;
                        } else if (typeof data?.result === 'string') {
                            result = data.result;
                        } else {
                            // 兜底：将整个代理返回序列化为字符串
                            result = JSON.stringify(data);
                        }

                        return result;
                    } catch (error) {
                        console.error("智谱AI调用失败（代理）:", error);
                        throw error;
                    }
                }
            }

            // 创建AI服务实例
            const aiService = new AIPlatformService();

            // 初始化AI服务
            aiService.initialize().then(success => {
                if (success) {
                    console.log('AI服务初始化成功');
                    // 初始化完成后执行后续操作
                    initPlatformSelect();
                    loadAllConfigsFromStorage();
                    populateUsagePlatforms();
                    populateSavedPlatformsList(); // 填充左侧已保存平台列表
                } else {
                    console.error('AI服务初始化失败，请检查platform-configs.json文件');
                    showStatus('AI服务初始化失败，请检查配置文件', 'error');
                }
            }).catch(error => {
                console.error('AI服务初始化错误:', error);
                showStatus('AI服务初始化错误: ' + error.message, 'error');
            });

            // 统一事件派发与状态接口
            function emitEvent(name, detail = {}) {
                try {
                    window.dispatchEvent(new CustomEvent('AIServiceModal:' + name, { detail }));
                } catch (_) { /* noop */ }
            }
            let isDirty = false;
            function setDirty(v) {
                if (isDirty !== v) {
                    isDirty = v;
                    emitEvent('onDirtyChange', { dirty: v });
                }
            }
            window.getAIServiceModalState = function () {
                return {
                    currentView,
                    configured: typeof checkIfConfigured === 'function' ? checkIfConfigured() : false,
                    isDirty
                };
            };
            window.setAIServiceModalView = function (view) {
                if (view === 'config') switchToConfigView();
                else if (view === 'template') switchToTemplateConfigView();
                else switchToUsageView();
            };

            // DOM元素引用
            const modal = document.getElementById('aiServiceModal');
            const openModalBtn = document.getElementById('openAIModalBtn');
            const closeModalBtn = document.getElementById('closeModalBtn');

            // 作为组件时默认不显示“打开AI工具”按钮；需要时由外部设置 window.AIServiceModalShowTrigger = true
            if (openModalBtn && !window.AIServiceModalShowTrigger) {
                openModalBtn.classList.add('hidden');
            }

            // 视图容器
            const aiUsageView = document.getElementById('aiUsageView');
            const aiConfigView = document.getElementById('aiConfigView');

            // AI使用界面元素
            const usageConfigStatusBar = document.getElementById('usageConfigStatusBar');
            const usageModelSelect = document.getElementById('usageModelSelect');
            const usagePromptInput = document.getElementById('usagePromptInput');
            const openConfigViewBtn = document.getElementById('openConfigViewBtn');
            const usageStatusIndicator = document.getElementById('usageStatusIndicator');
            const usageResultContent = document.getElementById('usageResultContent');
            const usageCancelBtn = document.getElementById('usageCancelBtn');
            const usageSubmitBtn = document.getElementById('usageSubmitBtn');

            // AI配置界面元素
            const configStatusBar = document.getElementById('configStatusBar');
            const platformSelect = document.getElementById('platformSelect');
            const apiKeyInput = document.getElementById('apiKeyInput');
            const toggleKeyVisibility = document.getElementById('toggleKeyVisibility');
            const modelSearchContainer = document.getElementById('modelSearchContainer');
            const modelSearchInput = document.getElementById('modelSearchInput');
            const refreshFavoriteModelsBtn = document.getElementById('refreshFavoriteModelsBtn');
            const modelLoadingIndicator = document.getElementById('modelLoadingIndicator');
            const platformSpecificConfigs = document.getElementById('platformSpecificConfigs');
            const cloudflareConfig = document.getElementById('cloudflareConfig');
            const azureConfig = document.getElementById('azureConfig');
            const cloudflareAccountId = document.getElementById('cloudflareAccountId');
            const azureEndpoint = document.getElementById('azureEndpoint');
            const configHeader = document.getElementById('configHeader');
            const configContent = document.getElementById('configContent');
            const toggleConfigBtn = document.getElementById('toggleConfigBtn');
            const configIcon = document.getElementById('configIcon');
            const apiKeyHelpLink = document.getElementById('apiKeyHelpLink');
            const configCancelBtn = document.getElementById('configCancelBtn');
            const configSaveBtn = document.getElementById('configSaveBtn');

            // 高级选项元素
            const temperatureInput = document.getElementById('temperatureInput');
            const maxTokensInput = document.getElementById('maxTokensInput');

            // 常用模型相关元素
            const favoriteModelsContainer = document.getElementById('favoriteModelsContainer');
            const favoriteModelsList = document.getElementById('favoriteModelsList');

            // 保存所有平台的配置数据
            let allPlatformConfigs = {};

            // 保存常用模型数据
            let favoriteModels = {};

            // 当前视图状态
            let currentView = 'usage'; // 'usage' 或 'config'

            // 初始化平台选择下拉框
            function initPlatformSelect() {
                // 确保平台选择元素存在
                if (!platformSelect) return;

                const platforms = aiService.getPlatforms();
                platformSelect.innerHTML = '<option value="">-- 请选择平台 --</option>'; // 清空并添加默认选项
                Object.entries(platforms).forEach(([key, platform]) => {
                    const option = document.createElement('option');
                    option.value = key;
                    option.textContent = platform.name;
                    platformSelect.appendChild(option);
                });
            }

            // 保存当前平台的配置到存储
            function saveCurrentPlatformConfig() {
                const selectedPlatform = platformSelect.value;
                if (!selectedPlatform) return;

                // 创建当前平台的配置对象，确保包含平台名称
                const platformConfig = {
                    apiKey: apiKeyInput.value,
                    cloudflareAccountId: cloudflareAccountId.value,
                    azureEndpoint: azureEndpoint.value,
                    temperature: temperatureInput.value,
                    maxTokens: maxTokensInput.value,
                    // 保存常用模型设置
                    favoriteModels: favoriteModels[selectedPlatform] || [],
                    // 确保每次都包含平台名称，避免"一遍多一遍少"的问题
                    platformName: allPlatformConfigs[selectedPlatform]?.platformName || (aiService.getPlatforms()[selectedPlatform]?.name) || selectedPlatform
                };

                // 更新配置集合
                allPlatformConfigs[selectedPlatform] = platformConfig;

                // 保存到本地存储（确保配置完整）
                localStorage.setItem('allAIPlatformConfigs', JSON.stringify(allPlatformConfigs));

                // 添加调试信息
                console.log('保存配置:', selectedPlatform, platformConfig);
            }

            // 保存配置（仅保存当前配置，不自动切换视图）
            function saveConfigAndReturn() {
                // 保存当前配置到 storage 并刷新侧栏，但不切换回使用界面
                saveCurrentPlatformConfig();
                showStatus('配置已保存', 'success');
            }

            // 取消配置并返回使用界面
            function cancelConfigAndReturn() {
                // 重新加载配置以撤销未保存的更改
                loadCurrentPlatformConfig();

                // 切换回使用界面
                switchToUsageView();
            }

            // 从本地存储加载所有平台的配置
            function loadAllConfigsFromStorage() {
                const savedConfigs = localStorage.getItem('allAIPlatformConfigs');
                console.log('从本地存储加载配置:', savedConfigs);
                if (savedConfigs) {
                    try {
                        allPlatformConfigs = JSON.parse(savedConfigs);
                        // 加载常用模型设置
                        for (const [platform, config] of Object.entries(allPlatformConfigs)) {
                            if (config.favoriteModels) {
                                favoriteModels[platform] = config.favoriteModels;
                            }
                        }
                        console.log('加载的配置:', allPlatformConfigs);
                    } catch (e) {
                        console.error('加载平台配置失败:', e);
                        allPlatformConfigs = {};
                    }
                } else {
                    // 不自动创建了，反正会调
                    // 新用户没有任何配置 —— 出于安全，不在前端写入或暴露任何内置 API Key。
                    // // 之前版本在此处写入了一个内置密钥（已被移除）。
                    // // 处理策略：
                    // //  1) 不自动将任何密钥写入 allPlatformConfigs/localStorage（避免泄露）。
                    // //  2) 如果需要提供“免配置”体验，请在后端通过受保护的服务端代理或在运行时由受信任的后端注入密钥（推荐），
                    // //     前端仅接收是否可用的布尔标志或短期一次性 token（不在代码/LocalStorage 中保存长期密钥）。
                    // //  3) 仍保留默认模型名称提示，但不包含任何可调用 API 的凭据。
                    // //  4) 仅在英文环境下自动创建默认配置，避免中文环境下自动创建
                    // const currentLang = window.i18nManager.getCurrentLanguage();
                    // console.log('新用户无配置，当前语言:', currentLang);

                    // if (currentLang === 'en') {
                    //     console.log('英文环境，创建安全的默认占位配置');
                    //     allPlatformConfigs = {
                    //         // 仅预填充平台元信息（不含 apiKey）
                    //         'bigmodel': {
                    //             apiKey: '', // 用户必须手动输入或由后端安全注入
                    //             cloudflareAccountId: '',
                    //             azureEndpoint: '',
                    //             temperature: 0.7,
                    //             maxTokens: 1000,
                    //             favoriteModels: ['GLM-4-Flash'], // 仅作为 UI 建议的默认模型名
                    //             platformName: '智谱AI', // 确保默认配置也包含平台名称
                    //             autoCreated: true // 标记为自动创建的配置
                    //         }
                    //     };

                    //     // 将"空"配置保存到本地（不包含任何密钥）
                    //     // 注意：现在默认配置已包含platformName，确保数据完整性
                    //     try {
                    //         localStorage.setItem('allAIPlatformConfigs', JSON.stringify(allPlatformConfigs));
                    //         // 仅保存默认模型名用于 UI 回显，不保存任何凭据
                    //         localStorage.setItem('selectedModel', 'GLM-4-Flash');
                    //     } catch (e) {
                    //         console.warn('保存默认配置到 localStorage 失败（已忽略敏感数据写入）', e);
                    //     }

                    //     console.log('已创建安全的默认平台占位配置（不包含密钥），请在设置中填写 API 密钥或使用后端注入');
                    //     console.log('默认配置已包含platformName，确保数据完整性');
                    // } else {
                    //     console.log('非英文环境，不自动创建默认配置');
                    //     allPlatformConfigs = {}; // 确保 allPlatformConfigs 是对象
                    // }
                }

                // 自动选择已配置的平台
                autoSelectConfiguredPlatform();

                // 如果是新用户且创建了默认配置，显示欢迎提示
                // defaultConfigCreated变量已被移除，不再显示默认配置欢迎提示
                // if (defaultConfigCreated) {
                //     setTimeout(() => {
                //         showStatus('欢迎使用！已为您内置智谱AI平台配置，使用免费的GLM-4-Flash模型', 'success');
                //     }, 1000);
                // }

                // 刷新左侧已保存平台列表
                populateSavedPlatformsList();
            }

            // 自动选择已配置的平台
            function autoSelectConfiguredPlatform() {
                console.log('自动选择平台: 检查所有平台配置', allPlatformConfigs);

                // 遍历所有已保存的配置，找到第一个完整配置的平台
                for (const [platform, config] of Object.entries(allPlatformConfigs)) {
                    console.log(`检查平台 ${platform}:`, config);

                    // 检查必要配置是否存在
                    const hasApiKey = config.apiKey && config.apiKey.trim() !== '';
                    const hasCloudflareAccount = platform !== 'cloudflare' || (config.cloudflareAccountId && config.cloudflareAccountId.trim() !== '');
                    const hasAzureEndpoint = platform !== 'azure' || (config.azureEndpoint && config.azureEndpoint.trim() !== '');

                    console.log(`平台 ${platform} 配置检查: apiKey=${hasApiKey}, cloudflare=${hasCloudflareAccount}, azure=${hasAzureEndpoint}`);

                    if (hasApiKey && hasCloudflareAccount && hasAzureEndpoint) {
                        console.log(`选择平台 ${platform}`);

                        // 设置平台选择
                        if (platformSelect) platformSelect.value = platform;

                        // 直接加载该平台的配置
                        loadCurrentPlatformConfig();

                        // 更新使用界面
                        updateUsageModelSelect();
                        updateUsageConfigStatus();

                        return;
                    }
                }

                console.log('没有找到完整配置的平台');
            }

            // 加载当前选中平台的配置
            function loadCurrentPlatformConfig() {
                const selectedPlatform = platformSelect.value;
                console.log('加载平台配置:', selectedPlatform);
                if (!selectedPlatform) return;

                const platformConfig = allPlatformConfigs[selectedPlatform] || {};
                console.log('平台配置内容:', platformConfig);

                // 填充表单字段
                apiKeyInput.value = platformConfig.apiKey || '';
                cloudflareAccountId.value = platformConfig.cloudflareAccountId || '';
                azureEndpoint.value = platformConfig.azureEndpoint || '';
                temperatureInput.value = platformConfig.temperature || 0.7;
                maxTokensInput.value = platformConfig.maxTokens || 1000;

                // 加载常用模型设置
                if (platformConfig.favoriteModels) {
                    favoriteModels[selectedPlatform] = platformConfig.favoriteModels;
                    console.log('加载常用模型:', platformConfig.favoriteModels);
                }

                // 更新API密钥申请链接
                const platforms = aiService.getPlatforms();
                if (platforms[selectedPlatform]?.apiKeyUrl) {
                    apiKeyHelpLink.href = platforms[selectedPlatform].apiKeyUrl;
                    apiKeyHelpLink.classList.remove('hidden');
                } else {
                    apiKeyHelpLink.classList.add('hidden');
                }

                // 更新常用模型列表
                updateFavoriteModelsList();

                updateConfigStatus();
            }

            // 更新常用模型列表显示
            function updateFavoriteModelsList() {
                const selectedPlatform = platformSelect.value;
                if (!selectedPlatform) return;

                // 清空列表
                favoriteModelsList.innerHTML = '';

                // 获取当前平台的所有模型
                const allModels = aiService.getModels(selectedPlatform);

                // 如果没有模型，显示提示信息
                if (allModels.length === 0) {
                    favoriteModelsList.innerHTML = '<p class="text-sm text-gray-500">暂无可用模型，请先获取模型列表</p>';
                    return;
                }

                // 获取当前平台的常用模型设置
                const platformFavoriteModels = favoriteModels[selectedPlatform] || [];

                // 为每个模型创建复选框
                allModels.forEach(model => {
                    const div = document.createElement('div');
                    div.className = 'flex items-center mb-1';

                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.id = `favorite-${model}`;
                    checkbox.value = model;
                    checkbox.className = 'mr-2';
                    checkbox.checked = platformFavoriteModels.includes(model);

                    const label = document.createElement('label');
                    label.htmlFor = `favorite-${model}`;
                    label.className = 'text-sm';
                    label.textContent = model;

                    // 添加事件监听器
                    checkbox.addEventListener('change', function () {
                        toggleFavoriteModel(selectedPlatform, model, this.checked);
                    });

                    div.appendChild(checkbox);
                    div.appendChild(label);
                    favoriteModelsList.appendChild(div);
                });
            }

            // 切换常用模型状态
            function toggleFavoriteModel(platform, model, isFavorite) {
                console.log('切换常用模型状态:', platform, model, isFavorite);
                if (!favoriteModels[platform]) {
                    favoriteModels[platform] = [];
                }

                if (isFavorite) {
                    // 添加到常用模型
                    if (!favoriteModels[platform].includes(model)) {
                        favoriteModels[platform].push(model);
                    }
                } else {
                    // 从常用模型中移除
                    favoriteModels[platform] = favoriteModels[platform].filter(m => m !== model);
                }

                console.log('更新后的常用模型:', favoriteModels[platform]);

                // 已禁用：发送请求时不自动保存平台配置（避免在发送时意外覆盖已保存的 apiKey）
                // saveCurrentPlatformConfig();


                // 若在使用界面，刷新模型下拉
                if (typeof updateUsageModelSelect === 'function') {
                    if (window.currentView === 'usage' || currentView === 'usage') {
                        updateUsageModelSelect();
                    }
                }
            }

            // 刷新常用模型列表
            async function refreshFavoriteModels() {
                const selectedPlatform = platformSelect.value;
                const apiKey = apiKeyInput.value;

                if (!selectedPlatform || !apiKey) {
                    showStatus('请先选择平台并输入API密钥', 'error');
                    return;
                }

                try {
                    modelLoadingIndicator.classList.remove('hidden');
                    showStatus('正在获取模型列表...', 'info');

                    // 准备平台特定选项
                    const options = {};
                    if (selectedPlatform === 'cloudflare') {
                        options.cloudflareAccountId = cloudflareAccountId.value;
                    }

                    // 获取模型列表
                    await aiService.fetchModels(selectedPlatform, apiKey, options);

                    // 更新常用模型列表
                    updateFavoriteModelsList();

                    showStatus('模型列表刷新成功', 'success');
                } catch (error) {
                    showStatus(`获取模型列表失败: ${error.message}`, 'error');
                } finally {
                    modelLoadingIndicator.classList.add('hidden');
                }
            }

            // 更新快速切换模型按钮状态
            function updateQuickModelSwitchButton() {
                // 确保元素存在再操作
                const quickModelSwitchBtn = document.getElementById('quickModelSwitchBtn');
                if (!quickModelSwitchBtn) return;

                const selectedPlatform = platformSelect.value;
                if (!selectedPlatform) {
                    quickModelSwitchBtn.classList.add('hidden');
                    return;
                }

                const platformFavoriteModels = favoriteModels[selectedPlatform] || [];
                if (platformFavoriteModels.length > 0) {
                    quickModelSwitchBtn.classList.remove('hidden');
                } else {
                    quickModelSwitchBtn.classList.add('hidden');
                }
            }


            // 处理平台选择变化
            function onPlatformChange() {
                // 切换平台时：不要立即保存或创建配置（编辑时不影响数据）
                const selectedPlatform = platformSelect.value;

                // 显示平台特定配置
                cloudflareConfig.classList.add('hidden');
                azureConfig.classList.add('hidden');

                if (selectedPlatform === 'cloudflare') {
                    cloudflareConfig.classList.remove('hidden');
                } else if (selectedPlatform === 'azure') {
                    azureConfig.classList.remove('hidden');
                }

                // 加载新选中平台的配置到右侧表单（仅在存在已保存配置时填充）
                loadCurrentPlatformConfig();

                // 若用户已输入 API key，则可尝试刷新模型（仅用于 UI 显示，不写入配置）
                if (selectedPlatform && apiKeyInput.value) {
                    refreshFavoriteModels();
                }

                // 延迟更新配置可见性，确保配置加载完成
                setTimeout(() => {
                    updateConfigStatus();
                    updateConfigVisibility();
                }, 300);
            }

            // 获取并更新模型列表
            async function fetchAndUpdateModels() {
                const selectedPlatform = platformSelect.value;
                const apiKey = apiKeyInput.value;

                if (!selectedPlatform || !apiKey) {
                    showStatus('请先选择平台并输入API密钥', 'error');
                    return;
                }

                try {
                    modelLoadingIndicator.classList.remove('hidden');
                    showStatus('正在获取模型列表...', 'info');

                    // 准备平台特定选项
                    const options = {};
                    if (selectedPlatform === 'cloudflare') {
                        options.cloudflareAccountId = cloudflareAccountId.value;
                    }

                    // 获取模型列表
                    const models = await aiService.fetchModels(selectedPlatform, apiKey, options);

                    // 更新常用模型列表
                    updateFavoriteModelsList();

                    showStatus(`成功获取 ${models.length} 个模型`, 'success');
                } catch (error) {
                    showStatus(`获取模型失败: ${error.message}`, 'error');
                } finally {
                    modelLoadingIndicator.classList.add('hidden');
                    updateConfigStatus();
                }
            }

            // 模型搜索功能
            function searchModels() {
                const searchTerm = modelSearchInput.value.toLowerCase().trim();
                const checkboxes = favoriteModelsList.querySelectorAll('input[type="checkbox"]');

                if (!searchTerm) {
                    // 清空搜索时显示所有选项
                    checkboxes.forEach(checkbox => {
                        const parentDiv = checkbox.parentElement;
                        parentDiv.style.display = '';
                    });
                    return;
                }

                // 过滤匹配的模型
                checkboxes.forEach(checkbox => {
                    const label = checkbox.parentElement.querySelector('label');
                    const text = label.textContent.toLowerCase();
                    const matches = text.includes(searchTerm);

                    const parentDiv = checkbox.parentElement;
                    parentDiv.style.display = matches ? '' : 'none';
                });
            }

            // 显示状态信息
            function showStatus(message, type = 'info') {
                const statusIndicator = configStatusBar; // 使用配置状态栏作为状态指示器
                statusIndicator.textContent = message;
                statusIndicator.classList.remove('hidden', 'bg-blue-100', 'text-blue-800',
                    'bg-green-100', 'text-green-800',
                    'bg-yellow-100', 'text-yellow-800',
                    'bg-red-100', 'text-red-800');

                switch (type) {
                    case 'info':
                        statusIndicator.classList.add('bg-blue-100', 'text-blue-800');
                        break;
                    case 'success':
                        statusIndicator.classList.add('bg-green-100', 'text-green-800');
                        break;
                    case 'warning':
                        statusIndicator.classList.add('bg-yellow-100', 'text-yellow-800');
                        break;
                    case 'error':
                        statusIndicator.classList.add('bg-red-100', 'text-red-800');
                        break;
                }
                // 非常驻：除 info 外，3秒后自动恢复默认引导
                if (type !== 'info') {
                    if (window._cfgStatusTimer) clearTimeout(window._cfgStatusTimer);
                    window._cfgStatusTimer = setTimeout(() => {
                        hideStatus();
                    }, 3000);
                }
            }

            // 隐藏状态信息
            function hideStatus() {
                // 固定显示：恢复为默认引导文案与蓝色信息样式，而不是隐藏
                const statusIndicator = configStatusBar;
                statusIndicator.classList.remove('hidden', 'bg-green-100', 'text-green-800', 'bg-yellow-100', 'text-yellow-800', 'bg-red-100', 'text-red-800');
                statusIndicator.classList.add('bg-blue-100', 'text-blue-800');
                statusIndicator.innerHTML = '<i class="fa fa-info-circle text-blue-600 mr-2"></i>请选择平台并填写必要信息，完成后点击“保存配置”。';
            }

            // 更新配置状态条
            function updateConfigStatus() {
                // 固定显示：根据已保存配置状态切换提示内容与颜色，不再隐藏
                const savedCfg = allPlatformConfigs[platformSelect.value] || null;
                const savedConfigured = !!(savedCfg && savedCfg.apiKey && savedCfg.apiKey.trim() !== '' &&
                    (platformSelect.value !== 'cloudflare' || (savedCfg.cloudflareAccountId && savedCfg.cloudflareAccountId.trim() !== '')) &&
                    (platformSelect.value !== 'azure' || (savedCfg.azureEndpoint && savedCfg.azureEndpoint.trim() !== '')));

                configStatusBar.classList.remove('hidden', 'bg-blue-100', 'text-blue-800', 'bg-green-100', 'text-green-800', 'bg-yellow-100', 'text-yellow-800', 'bg-red-100', 'text-red-800');

                if (savedConfigured) {
                    const platforms = aiService.getPlatforms();
                    const name = platforms[platformSelect.value]?.name || platformSelect.value || '未选择';
                    configStatusBar.innerHTML = '<i class="fa fa-check-circle text-green-600 mr-2"></i>已配置：' + name;
                    configStatusBar.classList.add('bg-green-100', 'text-green-800');
                } else if (platformSelect.value) {
                    configStatusBar.innerHTML = '<i class="fa fa-exclamation-triangle text-yellow-600 mr-2"></i>当前平台未完成配置，请完善后保存';
                    configStatusBar.classList.add('bg-yellow-100', 'text-yellow-800');
                } else {
                    // 默认引导
                    configStatusBar.innerHTML = '<i class="fa fa-info-circle text-blue-600 mr-2"></i>请选择平台并填写必要信息，完成后点击“保存配置”。';
                    configStatusBar.classList.add('bg-blue-100', 'text-blue-800');
                }
            }

            // 检查是否已配置
            function checkIfConfigured() {
                // 检查是否选择了平台
                if (!platformSelect.value) return false;

                // 检查是否输入了API密钥
                if (!apiKeyInput.value) return false;

                // 平台特定检查
                if (platformSelect.value === 'cloudflare' && !cloudflareAccountId.value) {
                    return false;
                }

                if (platformSelect.value === 'azure' && !azureEndpoint.value) {
                    return false;
                }

                return true;
            }

            // 更新配置区域可见性
            function updateConfigVisibility() {
                // 始终展开配置区域，不再折叠
                if (configContent) {
                    configContent.classList.remove('hidden', 'h-0', 'opacity-0', 'overflow-hidden');
                }
                updateConfigStatus();
            }





            // 切换API密钥可见性
            function toggleKeyVisibilityHandler() {
                const type = apiKeyInput.getAttribute('type') === 'password' ? 'text' : 'password';
                apiKeyInput.setAttribute('type', type);
                toggleKeyVisibility.innerHTML = type === 'password' ?
                    '<i class="fa fa-eye-slash"></i>' :
                    '<i class="fa fa-eye"></i>';
            }

            // 构建占位符映射（优先使用 modal.dataset.presetParams，其次使用选中模板的 params）
            function buildPlaceholdersMap() {
                const placeholders = {};
                let presetMap = null;
                try {
                    if (modal && modal.dataset && modal.dataset.presetParams) {
                        presetMap = JSON.parse(modal.dataset.presetParams);
                    }
                } catch (e) { presetMap = null; }

                // 从选中模板的 params 列表构建初始 keys
                const sel = promptTemplateSelect?.options[promptTemplateSelect.selectedIndex];
                const params = sel?.dataset?.params ? JSON.parse(sel.dataset.params) : [];

                const chosenKey = (promptParamsSelect?.value || '').trim();

                if (Array.isArray(params) && params.length > 0) {
                    params.forEach(p => {
                        const key = typeof p === 'string' ? p : (p?.name || '');
                        if (!key) return;
                        if (presetMap && Object.prototype.hasOwnProperty.call(presetMap, key)) {
                            const v = presetMap[key];
                            placeholders[key] = (v && typeof v === 'object') ? (v.value ?? '') : String(v ?? '');
                        } else {
                            placeholders[key] = (key === chosenKey && chosenKey) ? chosenKey : '';
                        }
                    });
                } else if (presetMap) {
                    // 当没有模板 params 时，使用 presetMap 中的所有键作为占位符
                    Object.entries(presetMap).forEach(([k, v]) => {
                        placeholders[k] = (v && typeof v === 'object') ? (v.value ?? '') : String(v ?? '');
                    });
                } else {
                    // 兜底：从当前缓存的模板或 textarea 中提取占位符名
                    try {
                        const templateSource = (usagePromptInput && usagePromptInput.dataset && usagePromptInput.dataset.template) ? usagePromptInput.dataset.template : (usagePromptInput ? usagePromptInput.value : '');
                        const re = /\{\{\s*([a-zA-Z0-9_]+)\s*\}\}/g;
                        let m;
                        const found = new Set();
                        while ((m = re.exec(String(templateSource || ''))) !== null) {
                            if (m[1]) found.add(m[1]);
                        }
                        Array.from(found).forEach(k => {
                            placeholders[k] = (k === chosenKey && chosenKey) ? chosenKey : '';
                        });
                    } catch (e) { /* ignore */ }
                }
                // 合并 presetMap 中未在 params 声明的键，确保替换完整
                if (presetMap && typeof presetMap === 'object') {
                    Object.entries(presetMap).forEach(([k, v]) => {
                        if (!Object.prototype.hasOwnProperty.call(placeholders, k)) {
                            placeholders[k] = (v && typeof v === 'object') ? (v.value ?? '') : String(v ?? '');
                        }
                    });
                }

                // 获取用户输入的特定要求
                const userPromptInput = document.getElementById('userPromptInput');
                if (userPromptInput) {
                    placeholders.userRequirement = userPromptInput.value || '';
                }

                console.log('[aiModal] Debug - buildPlaceholdersMap placeholders:', placeholders);
                return placeholders;
            }

            // 发送AI请求
            async function sendAIRequest() {
                let selectedPlatform = platformSelect.value;
                let selectedModel = usageModelSelect.value;
                let apiKey = apiKeyInput.value;
                // 如果用户未配置任何平台/模型/密钥，则自动使用 bigmodel 的代理地址（临时使用，不写回 localStorage）
                try {
                    const hasAnySavedConfig = Object.keys(allPlatformConfigs || {}).length > 0 &&
                        Object.values(allPlatformConfigs || {}).some(c => c && c.apiKey && String(c.apiKey).trim() !== '');
                    const hasSelection = selectedPlatform && selectedModel && apiKey && String(apiKey).trim() !== '';
                    if (!hasAnySavedConfig && !hasSelection) {
                        // 若平台配置中存在 bigmodel 并配置了 proxyUrl，则临时使用它
                        const platforms = aiService.getPlatforms();
                        if (platforms && platforms.bigmodel && platforms.bigmodel.proxyUrl) {
                            console.debug('[aiModal] no user config detected — using bigmodel proxy fallback');
                            selectedPlatform = 'bigmodel';
                            // 优先使用 usageModelSelect 的值（若用户选择了模型），否则使用平台预定义模型或首个常见模型
                            if (!selectedModel || String(selectedModel).trim() === '') {
                                const defs = platforms.bigmodel.predefinedModels || [];
                                selectedModel = defs.length > 0 ? defs[0] : 'GLM-4-Flash';
                            }
                            // 留空 apiKey，_callZhipu 中会检测并走 proxyUrl
                            apiKey = '';
                            // 注意：不把这些临时值写回本地存储或 UI
                        }
                    }
                } catch (e) {
                    console.warn('[aiModal] auto fallback to proxy failed', e);
                }

                // 组装提示词

                let commonPrompt = `
你是一个思维导图系统内部的编写助手，请根据【用户需求】结合【上下文信息】，严格按照【格式要求】完成【核心任务】，注意不要重复当前选中节点。

【格式要求（重要！）】：
1. 输出格式是 Markdown，禁止输出例如"**"等行内格式，请使用清晰的层级结构输出节点。一个节点对应的是一个标题或者列表。标题类型节点： # 表示一级节点, ## 表示二级节,### 表示三级节点……以此类推。如果没有#，但有- 或+ 或* ，表示为列表节点，列表节点前面不缩进时为上一个标题节点的直属子级，之后每缩进2个空格表示下降一个层级。
2. 如果某行不是节点（没有 #- 或+ 或*），那它就会自动成为最近标题的补充说明，补充说明允许为空（注意：请不要出现补充说明的字样）。
3. 输出内容用 [OUTPUT] ... [/OUTPUT] 包裹，方便解析。注意只在 [OUTPUT] 标签内生成内容，标签外不要输出任何多余的文字、对话或解释，只输出干净的结构。
4、如果你的任务是生成子级/同级节点或者初始树，请务必保证有结构清晰的节点和对应节点的简要备注；如果你的任务是扩写备注/补充说明，请避免生成任何节点或markdown格式，生成普通文本段落即可。`;

                // 1、根据操作类型拼接格式提示词
                let formatPrompt = '';
                const actionType = modal.dataset.actionType;

                // 根据不同的操作类型插入相应的格式提示词
                switch (actionType) {
                    case 'generate_initial_tree':
                        formatPrompt = commonPrompt + `【核心任务】
生成初始树：根据用户需求生成一个思路清晰的思维导图（一颗完整的初始树）需要包含一个一级标题作为根节点，并且生成若干孙子节点及其补充说明，二级标题尽量完整分类，节点之间尽量保持系统性、逻辑互斥。`;
                        break;
                    case 'create_child':
                        formatPrompt = commonPrompt + `【核心任务】
生成子节点：为当前节点生成若干新的子节点、孙子节点及其补充说明。注意：禁止输出单一中心主题，不要包含当前节点、父节点，并且避免与兄弟节点重复，节点之间尽量保持系统性、逻辑互斥。`;
                        break;
                    case 'create_sibling':
                        formatPrompt = commonPrompt + `【核心任务】
生成同级节点：为当前节点生成若干新的同级节点及其孙子节点和对应的补充说明。注意：禁止输出单一中心主题，不要包含当前节点、父节点，并且避免与已存在的兄弟节点重复，节点之间尽量保持系统性、逻辑互斥。`;
                        break;
                    case 'expand_notes':
                        formatPrompt = `你是一个文章撰写助手，请根据用户的需求完成当前节点的备注（即正文段落）的撰写任务。请基于当前节点主题和上下文，完成编写对应的章节段落。重要规则：- 不要生成无关的文字、对话或解释，只输出干净的段落（100字到500字之间，注意不能包含任何markdown语法）。- 输出时，用 [OUTPUT] ...[/OUTPUT] 包裹，方便解析，标签外不要输出任何东西。`;
                        break;
                    default:
                        formatPrompt = '你是一个思维导图系统内部的编写助手，请根据【用户需求】结合【上下文信息】进行符合逻辑和友善的回答。';
                }


                // 2、获取系统上下文提示词（来自usagePromptInput替换占位符之后的）
                const systemPrompt = usagePromptInput ? usagePromptInput.dataset.resolved.trim() : '';

                // 3、获取用户提示词并解析
                const userPromptInput = document.getElementById('userPromptInput');
                let userPrompt = userPromptInput ? userPromptInput.value.trim() : '';
                // 对用户提示词应用模板解析。每次都重新解析：使用完整的占位符映射来解析所有参数
                const placeholders = buildPlaceholdersMap();
                const user_result = resolveTemplatePlaceholders(userPrompt, placeholders, '{{name}}', { missingPolicy: 'keep' });
                userPrompt = user_result.resolvedText;

                // 直接用字符串拼接系统提示词和用户提示词，保持文字连贯
                let prompt = formatPrompt + '\n\n【上下文信息】\n：' + systemPrompt + '\n\n【用户要求】\n：' + userPrompt;


                console.log('[aiModal] 最终提示词:', prompt);
                console.log('[aiModal] Debug - usagePromptInput.dataset.resolved:', usagePromptInput?.dataset?.resolved);
                console.log('[aiModal] Debug - usagePromptInput.value:', usagePromptInput?.value);
                const temperature = parseFloat(temperatureInput.value);
                const maxTokens = parseInt(maxTokensInput.value);

                // 不进行隐式保存：仅当用户点击“保存配置”按钮时才写入本地存储
                // saveCurrentPlatformConfig();

                try {
                    // 配置AI服务
                    aiService.configure({
                        platform: selectedPlatform,
                        model: selectedModel,
                        apiKey: apiKey,
                        azureEndpoint: azureEndpoint.value,
                        cloudflareAccountId: cloudflareAccountId.value
                    });

                    // 显示加载状态
                    usageSubmitBtn.disabled = false;
                    usageSubmitBtn.innerHTML = '<i class="fa fa-spinner fa-spin mr-2"></i>处理中...';
                    showUsageStatus('正在向AI发送请求...', 'info');
                    usageResultContent.classList.add('hidden');

                    // 调用AI生成内容
                    const result = await aiService.generate({
                        prompt: prompt,
                        temperature: temperature,
                        maxTokens: maxTokens
                    });

                    // 显示结果
                    showUsageStatus('请求成功完成', 'success');
                    usageResultContent.value = result;

                    // 保存成功调用的平台和模型（只在真正调用成功后保存）
                    if (usagePlatformSelect && usagePlatformSelect.value) {
                        localStorage.setItem('lastUsedPlatform', usagePlatformSelect.value);
                    }
                    if (usageModelSelect && usageModelSelect.value && usagePlatformSelect && usagePlatformSelect.value) {
                        localStorage.setItem(`lastUsedModel_${usagePlatformSelect.value}`, usageModelSelect.value);
                    }
                    // 确保输出容器可见且可交互，避免被样式或属性禁用
                    if (usageResultContent) {
                        usageResultContent.classList.remove('hidden');
                        try { usageResultContent.style.pointerEvents = 'auto'; } catch (_) { /* noop */ }
                        try { usageResultContent.removeAttribute('aria-hidden'); } catch (_) { /* noop */ }
                        try { usageResultContent.classList.remove('opacity-50'); } catch (_) { /* noop */ }
                    }
                    // 确保保存/应用按钮可用
                    try { if (saveApplyOutputBtn) saveApplyOutputBtn.disabled = false; } catch (_) { /* noop */ }

                    // 派发提交事件（供内部监听）
                    emitEvent('onSubmit', {
                        platformConfig: {
                            provider: selectedPlatform,
                            apiKey,
                            azureEndpoint: azureEndpoint.value,
                            cloudflareAccountId: cloudflareAccountId.value
                        },
                        modelConfig: {
                            model: selectedModel,
                            temperature,
                            max_tokens: maxTokens
                        },
                        resolvedText: prompt,
                        usedPlaceholders: [],
                        missingPlaceholders: [],
                        result
                    });
                    // 注意：为避免父页面收到自动成功消息后关闭弹窗，
                    // 这里不再自动发送 AI_MODAL_RESULT status:'success' 给父窗口。
                    // 如果需要由父页面得到结果并关闭弹窗，应由保存/应用按钮或外部调用方显式触发。
                    // 例外：迷你模式下自动发送结果并关闭弹窗
                    if (isMiniMode) {
                        try {

                            window.parent?.postMessage({

                                type: 'AI_MODAL_RESULT',
                                actionType: modal.dataset.actionType || '',
                                requestId: modal.dataset.requestId || null,
                                status: 'ok',
                                output: result
                            }, '*');
                            // 延迟关闭弹窗，确保消息发送完成
                            setTimeout(() => closeModal(), 100);
                        } catch (_) { /* noop */ }
                    }

                    // 滚动到结果区域
                    usageResultContent.scrollIntoView({ behavior: 'smooth', block: 'start' });
                } catch (error) {
                    // 失败时也将错误写入输出区域，并显示
                    const msg = (error && error.message) ? error.message : String(error);
                    showUsageStatus(`请求失败: ${msg}`, 'error');
                    usageResultContent.value = `错误：${msg}`;
                    // 确保输出容器可见且可交互，避免被样式或属性禁用
                    if (usageResultContent) {
                        usageResultContent.classList.remove('hidden');
                        try { usageResultContent.style.pointerEvents = 'auto'; } catch (_) { /* noop */ }
                        try { usageResultContent.removeAttribute('aria-hidden'); } catch (_) { /* noop */ }
                        try { usageResultContent.classList.remove('opacity-50'); } catch (_) { /* noop */ }
                    }
                    // 确保保存/应用按钮可用（即便出错，用户可能仍想复制或查看原始错误）
                    try { if (saveApplyOutputBtn) saveApplyOutputBtn.disabled = false; } catch (_) { /* noop */ }

                    // 派发错误事件
                    emitEvent('onError', { code: 'SEND_FAILED', message: msg });

                    // 回传失败给父窗口
                    try {

                        // 不要让父页面在收到错误后自动关闭弹窗：增加 keepOpen 字段以便父页面判断
                        window.parent?.postMessage({
                            type: 'AI_MODAL_RESULT',
                            actionType: modal.dataset.actionType || '',
                            requestId: modal.dataset.requestId || null,
                            status: 'error',
                            detail: { message: msg },
                            keepOpen: true
                        }, '*');
                    } catch (_) { /* noop */ }
                } finally {

                    usageSubmitBtn.innerHTML = '<i class="fa fa-paper-plane mr-2"></i>发送请求';
                }
            }

            // 显示使用界面状态信息
            function showUsageStatus(message, type = 'info') {
                const bar = document.getElementById('usageStatusIndicator');
                if (!bar) return;
                bar.textContent = message;
                bar.classList.remove('hidden', 'bg-blue-100', 'text-blue-800',
                    'bg-green-100', 'text-green-800',
                    'bg-yellow-100', 'text-yellow-800',
                    'bg-red-100', 'text-red-800');

                switch (type) {
                    case 'info':
                        bar.classList.add('bg-blue-100', 'text-blue-800');
                        break;
                    case 'success':
                        bar.classList.add('bg-green-100', 'text-green-800');
                        break;
                    case 'warning':
                        bar.classList.add('bg-yellow-100', 'text-yellow-800');
                        break;
                    case 'error':
                        bar.classList.add('bg-red-100', 'text-red-800');
                        break;
                }
                // 非常驻：显示后3秒自动隐藏
                bar.classList.remove('hidden');
                if (window._usageStatusTimer) clearTimeout(window._usageStatusTimer);
                window._usageStatusTimer = setTimeout(() => {
                    bar.classList.add('hidden');
                    bar.textContent = '';
                }, 3000);
            }

            // 打开弹窗
            function openModal() {
                // 每次打开前从 localStorage 重新加载最新的配置，避免需要手动刷新页面才能看到变更
                try {
                    loadAllConfigsFromStorage();
                    populateSavedPlatformsList();
                    populateUsagePlatforms();
                    // 确保平台选项已填充并同步到使用界面
                    initPlatformSelect && initPlatformSelect();
                    // 刷新使用界面的模型与配置状态
                    updateUsageModelSelect && updateUsageModelSelect();
                    updateUsageConfigStatus && updateUsageConfigStatus();
                } catch (e) {
                    console.warn('[aiModal] refresh configs on open failed', e);
                }

                modal.classList.remove('hidden');

                // 读取预设提示词（信任调用方已传入真实换行）
                const presetPrompt = modal.dataset.presetPrompt;
                if (typeof presetPrompt === 'string') {
                    usagePromptInput.value = presetPrompt;
                    delete modal.dataset.presetPrompt;
                }

                // 读取初始视图：usage/config/template/mini
                const initialView = modal.dataset.initialView || 'mini';

                // 在打开时尽早缓存 template（若 dataset.template 为空且 textarea 有可用内容）
                try {
                    if (usagePromptInput) {
                        if (!(usagePromptInput.dataset && usagePromptInput.dataset.template)) {
                            const candidate = (usagePromptInput.value && String(usagePromptInput.value).trim()) || '';
                            // 仅当候选文本看起来像模板（包含 {{}}）时才缓存为模板；否则优先使用下拉模板
                            if (candidate && candidate.includes('{{')) {
                                usagePromptInput.dataset.template = candidate;
                                console.debug('[aiModal][dbg] cached template early on open:', String(candidate).slice(0, 200));
                            } else {
                                // 尝试从 promptTemplateSelect 取回内容（兜底）
                                const sel = promptTemplateSelect?.options[promptTemplateSelect.selectedIndex];
                                const tplContent = sel?.dataset?.content || sel?.value || '';
                                if (tplContent && String(tplContent).trim() !== '') {
                                    usagePromptInput.dataset.template = tplContent;
                                    console.debug('[aiModal][dbg] cached template from promptTemplateSelect on open');
                                } else {
                                    console.debug('[aiModal][dbg] no valid template to cache on open (candidate is resolved text)');
                                }
                            }
                        }
                    }
                } catch (e) {
                    console.warn('[aiModal] cache template on open early failed', e);
                }

                // 默认首次打开时使用“模板视图”（便于用户编辑模板占位符）
                try {
                    const toggleChkEl = document.getElementById('toggleTemplateViewChk');
                    const modeTextEl = document.getElementById('promptViewModeText');
                    if (toggleChkEl) {
                        // 默认选中：打开时显示为“占位符/模板模式”
                        toggleChkEl.checked = true;
                    }
                    // 明确修正展示文本与输入框状态（确保不会被其它初始化覆盖）
                    try {
                        if (modeTextEl) modeTextEl.textContent = '占位符';
                        if (usagePromptInput) {
                            usagePromptInput.readOnly = false;
                            usagePromptInput.classList.remove('bg-gray-100');
                        }
                    } catch (_) { /* noop */ }
                    // 触发一次 applyView，确保界面与切换状态同步
                    if (typeof applyView === 'function') {
                        applyView();
                    }
                    syncTemplateAndResolved();
                } catch (e) { /* ignore */ }
                if (initialView === 'config') {
                    switchToConfigView();
                } else if (initialView === 'template') {
                    switchToTemplateConfigView();
                } else if (initialView === 'mini') {
                    // 默认以迷你模式启动
                    switchToUsageView(); // 先切换到使用视图
                    toggleMiniMode();    // 然后切换到迷你模式

                    // 设置迷你输入框的提示文字
                    const miniPrompt = modal.dataset.miniPrompt;
                    if (typeof miniPrompt === 'string' && miniPrompt.trim()) {
                        const miniInput = document.getElementById('miniInput');
                        if (miniInput) {
                            miniInput.placeholder = miniPrompt.trim();
                        }
                        delete modal.dataset.miniPrompt;
                    }
                } else {
                    switchToUsageView();
                }

                // // 初始化textarea自动调整功能
                // initTextareaAutoResize();

                // 恢复上次使用的 平台 与 模型（若存在）
                try {
                    (function restoreLastSelection() {
                        try {
                            const lastPlatform = localStorage.getItem('lastUsedPlatform');
                            if (lastPlatform && usagePlatformSelect) {
                                // 若选项还未包含该值，则等待短暂时间再尝试（通常 populateUsagePlatforms 会在初始化时填充）
                                const applyPlatform = () => {
                                    if (!usagePlatformSelect.querySelector(`option[value="${lastPlatform}"]`)) return false;
                                    usagePlatformSelect.value = lastPlatform;
                                    // 同步到主平台选择并触发 change 以加载模型
                                    if (platformSelect) {
                                        platformSelect.value = lastPlatform;
                                        const ev = new Event('change', { bubbles: true });
                                        platformSelect.dispatchEvent(ev);
                                    }
                                    // 触发 usagePlatformSelect 的 change 以保持行为一致
                                    const ev2 = new Event('change', { bubbles: true });
                                    usagePlatformSelect.dispatchEvent(ev2);
                                    return true;
                                };

                                if (!applyPlatform()) {
                                    // 若尚未填充选项，等待并重试几次
                                    let tries = 0;
                                    const tid = setInterval(() => {
                                        tries++;
                                        if (applyPlatform() || tries >= 6) {
                                            clearInterval(tid);
                                            // 尝试恢复模型（若存在）
                                            tryRestoreModel();
                                        }
                                    }, 250);
                                } else {
                                    // 平台已应用，尝试恢复模型
                                    tryRestoreModel();
                                }
                            } else {
                                // 未记录平台或无 usagePlatformSelect，仍尝试恢复模型基于当前平台
                                tryRestoreModel();
                            }

                            function tryRestoreModel() {
                                try {
                                    const curPlatform = usagePlatformSelect ? usagePlatformSelect.value : (platformSelect ? platformSelect.value : null);
                                    if (!curPlatform) return;
                                    const lastModelKey = `lastUsedModel_${curPlatform}`;
                                    const lastModel = localStorage.getItem(lastModelKey);
                                    if (!lastModel) return;
                                    // 若 usageModelSelect 已填充并包含该模型则直接设置
                                    const applyModel = () => {
                                        if (!usageModelSelect) return false;
                                        if (!usageModelSelect.querySelector(`option[value="${lastModel}"]`)) return false;
                                        usageModelSelect.value = lastModel;
                                        const ev = new Event('change', { bubbles: true });
                                        usageModelSelect.dispatchEvent(ev);
                                        return true;
                                    };
                                    if (!applyModel()) {
                                        // 等待模型填充完成后重试
                                        let mtries = 0;
                                        const mid = setInterval(() => {
                                            mtries++;
                                            if (applyModel() || mtries >= 8) clearInterval(mid);
                                        }, 250);
                                    }
                                } catch (e) { /* noop */ }
                            }
                        } catch (e) { /* noop */ }
                    })();
                } catch (e) { /* noop */ }
            }

            // // 自动调整textarea高度以适应内容
            // function autoResizeTextarea(textarea) {
            //     if (!textarea) return;
            //     // 重置高度，然后计算实际需要的滚动高度
            //     textarea.style.height = 'auto';
            //     const scrollHeight = textarea.scrollHeight;
            //     // 设置新高度，但不超过容器的最大高度
            //     const maxHeight = textarea.parentElement.clientHeight - 24; // 减去padding
            //     const newHeight = Math.min(scrollHeight, maxHeight);
            //     textarea.style.height = newHeight + 'px';
            // }

            // // 初始化textarea自动调整功能
            // function initTextareaAutoResize() {
            //     const textarea = document.getElementById('usageResultContent');
            //     if (!textarea) return;

            //     // 监听输入事件
            //     textarea.addEventListener('input', function() {
            //         autoResizeTextarea(this);
            //     });

            //     // 监听值变化（当通过JavaScript设置值时）
            //     const originalSetter = Object.getOwnPropertyDescriptor(HTMLTextAreaElement.prototype, 'value').set;
            //     const originalGetter = Object.getOwnPropertyDescriptor(HTMLTextAreaElement.prototype, 'value').get;
            //     Object.defineProperty(textarea, 'value', {
            //         set: function(newValue) {
            //             originalSetter.call(this, newValue);
            //             autoResizeTextarea(this);
            //         },
            //         get: function() {
            //             return originalGetter.call(this);
            //         }
            //     });

            //     // 初始调整
            //     setTimeout(() => autoResizeTextarea(textarea), 100);
            // }

            // 关闭弹窗
            function closeModal() {
                // // 关闭时不进行隐式保存副作用 — 仅在用户确认为保存时调用保存逻辑
                // console.log('[aiModal] closeModal called, requestId=', modal?.dataset?.requestId);
                // // 派发关闭事件
                // emitEvent('onClose', { reason: 'user' });
                // 隐藏弹窗
                modal.classList.add('hidden');
                // 重置迷你模式状态，确保下次打开时从初始状态开始
                isMiniMode = false;
                modal.classList.remove('mini-mode');
                // 在关闭时恢复到“占位符模式”，并把输入框回写为真正模板，避免下次打开误把实际值缓存为模板

                const chk = document.getElementById('toggleTemplateViewChk');
                const modeTextEl = document.getElementById('promptViewModeText');
                if (chk) chk.checked = true;
                if (usagePromptInput && usagePromptInput.dataset && usagePromptInput.dataset.template) {
                    usagePromptInput.value = String(usagePromptInput.dataset.template).replace(/\r\n/g, "\n");
                    try { usagePromptInput.readOnly = false; usagePromptInput.classList.remove('bg-gray-100'); } catch (_) { /* noop */ }
                }
                if (modeTextEl) modeTextEl.textContent = '占位符';

                // 通知父窗口此次为用户取消/关闭（以便父页隐藏顶层 aiFrame 并恢复焦点）
                // 若是通过“保存并应用”触发的关闭（已设置 suppress 标记），则不要发送 cancel
                try {
                    const suppress = (modal?.dataset?.suppressCancelOnClose === '1') || !!window._suppressAICancel;
                    // 清理标记，避免影响后续打开
                    try { if (modal?.dataset) delete modal.dataset.suppressCancelOnClose; } catch (_) { /* noop */ }
                    try { window._suppressAICancel = false; } catch (_) { /* noop */ }

                    if (!suppress) {
                        const rid = modal?.dataset?.requestId || null;
                        window.parent?.postMessage({
                            type: 'AI_MODAL_RESULT',
                            requestId: rid,
                            status: 'cancel',
                            detail: { message: 'user_closed' }
                        }, '*');
                    } else {
                        // 已保存并应用的正常关闭：不发送 cancel
                        try { console.debug('[aiModal] closeModal suppressed cancel due to save/apply'); } catch (_) { /* noop */ }
                    }
                } catch (err) {
                    console.warn('[aiModal] postMessage close failed', err);
                }
            }

            // 切换到AI使用界面
            function switchToUsageView() {
                aiUsageView.classList.remove('hidden');
                aiConfigView.classList.add('hidden');
                // 同时隐藏模板配置视图，避免串屏
                const tplView = document.getElementById('templateConfigView');
                if (tplView) tplView.classList.add('hidden');
                // 隐藏迷你模式视图，避免在使用界面显示迷你模式表单
                const miniView = document.getElementById('aiMiniView');
                if (miniView) miniView.classList.add('hidden');
                // 设置弹窗高度（使用界面较低）
                const modalContainer = document.querySelector('.modal-container');
                if (modalContainer) modalContainer.style.height = 'auto'; //45vh也行
                // 弹窗主体不滚动
                const modalBodyEl = document.querySelector('.modal-body');
                if (modalBodyEl) modalBodyEl.style.overflowY = 'hidden';

                currentView = 'usage';

                // 更新使用界面的模型选择
                updateUsageModelSelect();

                // 更新配置状态
                updateUsageConfigStatus();
            }

            // 切换到AI配置界面
            function switchToConfigView() {
                aiUsageView.classList.add('hidden');
                aiConfigView.classList.remove('hidden');
                // 同时隐藏模板配置视图，避免串屏
                const tplView = document.getElementById('templateConfigView');
                if (tplView) tplView.classList.add('hidden');
                // 隐藏迷你模式视图，避免在配置界面显示迷你模式表单
                const miniView = document.getElementById('aiMiniView');
                if (miniView) miniView.classList.add('hidden');
                // 设置弹窗高度（配置界面更高）
                const modalContainer = document.querySelector('.modal-container');
                // if (modalContainer) modalContainer.style.height = '67vh';
                // 弹窗主体内部滚动，底部按钮固定可见
                const modalBodyEl = document.querySelector('.modal-body');
                if (modalBodyEl) modalBodyEl.style.overflowY = 'none';

                currentView = 'config';

                // 更新配置状态
                updateConfigStatus();
                // 初次进入：高亮并回显第一个已保存平台
                (function () {
                    const container = document.getElementById('savedPlatformsList');
                    if (!container) return;
                    const first = Array.from(container.children).find(c => c.dataset && c.dataset.platformKey);
                    if (first) {
                        Array.from(container.children).forEach(c => c.classList.remove('bg-primary/10'));
                        first.classList.add('bg-primary/10');
                        loadPlatformToConfig(first.dataset.platformKey);
                    }
                })();
            }

            // 更新使用界面的模型选择（优先使用 usagePlatformSelect 的选中值）
            function updateUsageModelSelect() {
                // 清空选择框
                if (!usageModelSelect) return;
                usageModelSelect.innerHTML = '';

                // 优先使用使用界面平台下拉的值，其次回退到配置面板的 platformSelect
                const selectedPlatform = (usagePlatformSelect && usagePlatformSelect.value) ? usagePlatformSelect.value : (platformSelect ? platformSelect.value : '');
                // 尝试从本地已保存配置中读取 apiKey 回退到输入框的值
                const savedCfg = (allPlatformConfigs && selectedPlatform) ? (allPlatformConfigs[selectedPlatform] || null) : null;
                const apiKeyFromSaved = savedCfg && savedCfg.apiKey ? savedCfg.apiKey : '';
                const apiKey = apiKeyFromSaved || (apiKeyInput ? apiKeyInput.value : '');

                if (!selectedPlatform) {
                    usageModelSelect.innerHTML = '<option value="">-- 请先选择平台 --</option>';
                    updateUsageSubmitButtonState();
                    return;
                }

                // 获取当前平台的常用模型（基于使用界面的 favoriteModels）
                const platformFavoriteModels = favoriteModels[selectedPlatform] || [];

                const fillOptions = (models) => {
                    usageModelSelect.innerHTML = '';
                    if (Array.isArray(models) && models.length > 0) {
                        models.forEach(model => {
                            const option = document.createElement('option');
                            option.value = model;
                            option.textContent = model;
                            usageModelSelect.appendChild(option);
                        });
                        // 记忆上次模型选择（按实际使用的平台）
                        const lastModelKey = `lastUsedModel_${selectedPlatform}`;
                        const lastModel = localStorage.getItem(lastModelKey);
                        if (lastModel && models.includes(lastModel)) {
                            usageModelSelect.value = lastModel;
                        } else {
                            usageModelSelect.value = models[0];
                        }
                    } else {
                        usageModelSelect.innerHTML = '<option value="">-- 暂无可用模型 --</option>';
                    }
                    updateUsageSubmitButtonState();
                };

                if (platformFavoriteModels.length > 0) {
                    // 优先使用常用模型（用户已保存的偏好）
                    fillOptions(platformFavoriteModels);
                } else {
                    // 无常用模型则显示全部模型；若尚未加载则尝试拉取（优先使用 saved apiKey，再使用输入框的 apiKey）
                    let models = [];
                    try {
                        models = aiService.getModels(selectedPlatform) || [];
                    } catch (e) {
                        models = [];
                    }

                    if (!Array.isArray(models) || models.length === 0) {
                        // 需要拉取模型列表
                        const options = {};
                        if (selectedPlatform === 'cloudflare') {
                            // 优先使用已保存的 account id，否则使用输入框的值
                            options.cloudflareAccountId = (savedCfg && savedCfg.cloudflareAccountId) ? savedCfg.cloudflareAccountId : (cloudflareAccountId ? cloudflareAccountId.value : '');
                        }
                        if (apiKey) {
                            aiService.fetchModels(selectedPlatform, apiKey, options)
                                .then(ms => fillOptions(ms))
                                .catch(() => fillOptions([]));
                        } else {
                            // 无可用 apiKey 时尝试直接使用 aiService.getModels 的结果（可能为空）
                            fillOptions(models);
                        }
                    } else {
                        fillOptions(models);
                    }
                }
            }

            // 更新使用界面配置状态
            function updateUsageConfigStatus() {
                // 与配置页一致：仅根据“已保存的配置”判断是否已配置，避免“输入即已配置”
                const savedCfg = allPlatformConfigs[platformSelect.value] || null;
                const savedConfigured = !!(savedCfg && savedCfg.apiKey && savedCfg.apiKey.trim() !== '' &&
                    (platformSelect.value !== 'cloudflare' || (savedCfg.cloudflareAccountId && savedCfg.cloudflareAccountId.trim() !== '')) &&
                    (platformSelect.value !== 'azure' || (savedCfg.azureEndpoint && savedCfg.azureEndpoint.trim() !== '')));

                usageConfigStatusBar.classList.remove('hidden', 'bg-green-100', 'text-green-800', 'bg-yellow-100', 'text-yellow-800');

                if (savedConfigured) {
                    const platforms = aiService.getPlatforms();
                    const platformName = platforms[platformSelect.value]?.name || platformSelect.value;
                    usageConfigStatusBar.innerHTML = `<i class="fa fa-check-circle text-green-600 mr-2"></i>已配置: ${platformName}`;
                    usageConfigStatusBar.classList.add('bg-green-100', 'text-green-800');
                } else {
                    usageConfigStatusBar.innerHTML = '<i class="fa fa-exclamation-triangle text-yellow-600 mr-2"></i>请先配置AI平台';
                    usageConfigStatusBar.classList.add('bg-yellow-100', 'text-yellow-800');
                }
                // 非常驻：显示3秒后自动隐藏
                usageConfigStatusBar.classList.remove('hidden');
                if (window._usageCfgBarTimer) clearTimeout(window._usageCfgBarTimer);
                window._usageCfgBarTimer = setTimeout(() => {
                    usageConfigStatusBar.classList.add('hidden');
                }, 3000);
            }

            // 更新使用界面发送按钮状态
            function updateUsageSubmitButtonState() {
                // 改为：不再禁用发送按钮，始终允许用户点击。若发送失败，sendAIRequest 会向用户展示具体错误信息。
                try {
                    if (usageSubmitBtn) usageSubmitBtn.disabled = false;
                } catch (e) {
                    console.warn('[aiModal] failed to enable usageSubmitBtn', e);
                }
            }

            // 事件监听器
            if (openModalBtn) openModalBtn.addEventListener('click', openModal);
            if (closeModalBtn) {
                closeModalBtn.addEventListener('click', closeModal);
                // 添加触摸事件支持，确保移动端响应
                closeModalBtn.addEventListener('touchstart', function (e) {
                    e.stopPropagation(); // 防止事件冒泡到拖拽层
                }, { passive: true });
                closeModalBtn.addEventListener('touchend', function (e) {
                    e.preventDefault(); // 防止鼠标事件重复触发
                    closeModal();
                }, { passive: false });
            }
            if (usageCancelBtn) usageCancelBtn.addEventListener('click', (e) => { e.preventDefault(); closeModal(); });
            if (configCancelBtn) configCancelBtn.addEventListener('click', (e) => { e.preventDefault(); cancelConfigAndReturn(); });
            if (configBackBtn) configBackBtn.addEventListener('click', (e) => { e.preventDefault(); switchToUsageView(); });
            if (usageSubmitBtn) usageSubmitBtn.addEventListener('click', (e) => { e.preventDefault(); sendAIRequest(); });
            if (configSaveBtn) configSaveBtn.addEventListener('click', (e) => { e.preventDefault(); saveConfigAndReturn(); showStatus('配置已保存', 'success'); populateSavedPlatformsList(); populateUsagePlatforms(); updateUsageModelSelect(); });

            // 保存并应用：将输出通过 postMessage 发给父窗口并关闭 modal
            const saveApplyOutputBtn = document.getElementById('saveApplyOutputBtn');
            if (saveApplyOutputBtn) {
                saveApplyOutputBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    try {
                        // 简化处理：contenteditable div应该作为纯文本编辑器使用
                        let output = '';
                        if (usageResultContent) {
                            // 使用textarea的value获取内容，完美保留换行符
                            output = usageResultContent.value || '';
                        }



                        const message = {
                            type: 'AI_MODAL_RESULT',
                            actionType: modal.dataset.actionType || '',
                            requestId: modal.dataset.requestId || null,
                            status: 'ok',
                            output
                        };
                        console.log('🔵 AIServiceModal 发送消息:', JSON.stringify(message, null, 2));
                        window.parent?.postMessage(message, '*');
                    } catch (err) {
                        console.warn('[aiModal] saveApply postMessage failed', err);
                    }
                    // 标记此次关闭为“save/apply”触发，避免 closeModal 向父窗口再次发送 cancel
                    try {
                        if (modal && modal.dataset) {
                            modal.dataset.suppressCancelOnClose = '1';
                        } else {
                            window._suppressAICancel = true;
                        }
                    } catch (_) { /* noop */ }
                    // 关闭 modal
                    try { closeModal(); } catch (_) { /* noop */ }
                });
            }
            if (openConfigViewBtn) openConfigViewBtn.addEventListener('click', (e) => { e.preventDefault(); switchToConfigView(); });
            if (platformSelect) platformSelect.addEventListener('change', onPlatformChange);
            if (refreshFavoriteModelsBtn) refreshFavoriteModelsBtn.addEventListener('click', refreshFavoriteModels);
            if (toggleKeyVisibility) toggleKeyVisibility.addEventListener('click', toggleKeyVisibilityHandler);
            if (toggleConfigBtn) toggleConfigBtn.addEventListener('click', toggleConfig);
            if (configHeader) configHeader.addEventListener('click', toggleConfig);

            // verifyApiKey 按钮：根据当前 platform 与 apiKey 做校验，校验成功则刷新模型列表
            const verifyApiKeyBtn = document.getElementById('verifyApiKeyBtn');
            if (verifyApiKeyBtn) {
                verifyApiKeyBtn.addEventListener('click', async () => {
                    const selectedPlatform = platformSelect.value;
                    const apiKey = apiKeyInput.value;
                    if (!selectedPlatform) {
                        showStatus('请先选择平台以验证密钥', 'error');
                        return;
                    }
                    if (!apiKey) {
                        showStatus('请先输入 API 密钥', 'error');
                        return;
                    }

                    showStatus('正在校验密钥...', 'info');
                    try {
                        // 平台特定验证：优先尝试 fetchModels（如支持）；若不支持则使用 verifyConnection
                        const platformsInfo = aiService.getPlatforms();
                        const info = platformsInfo[selectedPlatform] || {};
                        let ok = false;

                        // 若平台有 modelsUrl 或预定义模型，则尝试 fetchModels
                        const canFetchModels = !!(info.modelsUrl) || Array.isArray(info.predefinedModels);
                        if (canFetchModels) {
                            try {
                                await aiService.fetchModels(selectedPlatform, apiKey, {
                                    cloudflareAccountId: cloudflareAccountId.value
                                });
                                ok = true;
                            } catch (e) {
                                ok = false;
                            }
                        } else {
                            // 回退到 verifyConnection（需要先临时配置 aiService）
                            try {
                                aiService.configure({
                                    platform: selectedPlatform,
                                    model: '',
                                    apiKey: apiKey,
                                    azureEndpoint: azureEndpoint.value,
                                    cloudflareAccountId: cloudflareAccountId.value
                                });
                                ok = await aiService.verifyConnection();
                            } catch (e) {
                                console.log(e);
                                ok = false;
                            }
                        }

                        if (ok) {
                            showStatus('密钥校验成功，正在刷新模型列表...', 'success');
                            try {
                                await aiService.fetchModels(selectedPlatform, apiKey, {
                                    cloudflareAccountId: cloudflareAccountId.value
                                });
                            } catch (e) {
                                // ignore
                            }
                            // 若当前平台未配置常用模型，则显示所有模型（不强行覆盖已保存的）
                            if (!Array.isArray(favoriteModels[selectedPlatform]) || favoriteModels[selectedPlatform].length === 0) {
                                favoriteModels[selectedPlatform] = [];
                            }
                            updateFavoriteModelsList();
                            showStatus('模型列表已刷新', 'success');
                        } else {
                            showStatus('密钥校验失败，请检查平台与密钥是否正确', 'error');
                        }
                    } catch (err) {
                        showStatus('校验过程中出错: ' + (err.message || err), 'error');
                    }
                });
            }

            // 输入变化时更新状态
            if (apiKeyInput) apiKeyInput.addEventListener('input', () => {
                updateConfigStatus();
            });
            try {
                if (usagePromptInput) {
                    usagePromptInput.addEventListener('input', () => {
                        try {
                            // 统一同步到 template/resolved（避免重复逻辑）
                            syncTemplateAndResolved();
                        } catch (e) { /* ignore */ }
                        updateUsageSubmitButtonState();
                    });
                }
            } catch (e) { /* ignore */ }
            if (usageModelSelect) usageModelSelect.addEventListener('change', () => {
                updateUsageSubmitButtonState();
            });
            if (cloudflareAccountId) cloudflareAccountId.addEventListener('input', () => {
                updateConfigStatus();
            });
            if (azureEndpoint) azureEndpoint.addEventListener('input', () => {
                updateConfigStatus();
            });
            // 改为仅标记脏状态，避免非显式保存写回配置/密钥
            if (temperatureInput) temperatureInput.addEventListener('change', () => setDirty(true));
            if (maxTokensInput) maxTokensInput.addEventListener('change', () => setDirty(true));

            // 模型搜索
            if (modelSearchInput) modelSearchInput.addEventListener('input', searchModels);

            // 导出/导入
            const exportConfigsBtn = document.getElementById('exportConfigsBtn');
            const importConfigsBtn = document.getElementById('importConfigsBtn');
            const importFileInput = document.getElementById('importFileInput');

            if (exportConfigsBtn) {
                exportConfigsBtn.addEventListener('click', () => {
                    // 过滤掉自动创建的配置
                    const configsToExport = {};
                    Object.keys(allPlatformConfigs || {}).forEach(key => {
                        const config = allPlatformConfigs[key];
                        // 只导出手动创建的配置（没有autoCreated标记的）
                        if (config && !config.autoCreated) {
                            configsToExport[key] = config;
                        }
                    });

                    const data = JSON.stringify(configsToExport, null, 2);
                    const blob = new Blob([data], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `ai-platform-configs-${new Date().toISOString().slice(0, 19).replace(/[:T]/g, '-')}.json`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    showStatus('配置已导出', 'success');
                });
            }

            if (importConfigsBtn && importFileInput) {
                importConfigsBtn.addEventListener('click', () => importFileInput.click());
                importFileInput.addEventListener('change', (e) => {
                    const file = e.target.files && e.target.files[0];
                    if (!file) return;
                    const reader = new FileReader();
                    reader.onload = () => {
                        try {
                            const json = JSON.parse(reader.result);
                            if (typeof json === 'object' && json) {
                                allPlatformConfigs = json;
                                // 导入配置时确保数据完整 - 现在导入的配置也会包含platformName
                                // 强制确保所有导入的配置都有platformName
                                Object.keys(allPlatformConfigs).forEach(key => {
                                    if (allPlatformConfigs[key] && !allPlatformConfigs[key].platformName) {
                                        allPlatformConfigs[key].platformName = (aiService.getPlatforms()[key]?.name) || key;
                                    }
                                });
                                localStorage.setItem('allAIPlatformConfigs', JSON.stringify(allPlatformConfigs));
                                populateSavedPlatformsList();
                                populateUsagePlatforms();
                                showStatus('配置已导入', 'success');
                            } else {
                                showStatus('导入失败：文件格式不正确', 'error');
                            }
                        } catch (err) {
                            showStatus('导入失败：' + (err.message || err), 'error');
                        } finally {
                            importFileInput.value = '';
                        }
                    };
                    reader.readAsText(file, 'utf-8');
                });
            }

            // // 点击弹窗背景或弹窗容器外部区域关闭弹窗（若点击目标不在 .modal-container 内则关闭）
            // if (modal) modal.addEventListener('click', (e) => {
            //     try {
            //         // 若事件目标或其祖先在 .modal-container 内，则视为内部点击，忽略关闭
            //         if (e && e.target && e.target.closest && e.target.closest('.modal-container')) {
            //             return;
            //         }
            //     } catch (_) { /* ignore */ }
            //     // 否则关闭弹窗（等同于用户点击遮罩/外部区域）
            //     closeModal();
            // });

            // ----- 可拖拽支持（拖动弹窗头部移动 modal） -----
            (function enableModalDrag() {
                try {
                    const container = document.querySelector('.modal-container');
                    const headerEl = container ? container.querySelector('.modal-header') : null;
                    if (!container || !headerEl) return;

                    // 允许头部显示拖动光标
                    headerEl.style.cursor = 'move';
                    // 禁用容器的 CSS 过渡以避免拖动时不必要动画
                    container.style.transition = 'none';

                    let dragging = false;
                    let startX = 0, startY = 0;
                    let baseX = 0, baseY = 0;

                    function getEventPos(e) {
                        if (e.touches && e.touches[0]) {
                            return { x: e.touches[0].clientX, y: e.touches[0].clientY };
                        }
                        return { x: e.clientX, y: e.clientY };
                    }

                    function parseCurrentTranslate() {
                        const t = container.style.transform || '';
                        const m = t.match(/translate\(([-\d.]+)px,\s*([-\d.]+)px\)/);
                        if (m) {
                            return { x: parseFloat(m[1]) || 0, y: parseFloat(m[2]) || 0 };
                        }
                        return { x: 0, y: 0 };
                    }

                    function onStart(e) {
                        // 仅左键或触摸启动
                        if (e.type === 'mousedown' && e.button !== 0) return;

                        // 检查是否点击在按钮上，如果是则不允许拖拽
                        const target = e.target;
                        if (target && (target.tagName === 'BUTTON' || target.closest('button'))) {
                            return; // 不启动拖拽，让按钮正常响应点击
                        }

                        const pos = getEventPos(e);
                        dragging = true;
                        startX = pos.x;
                        startY = pos.y;
                        const cur = parseCurrentTranslate();
                        baseX = cur.x;
                        baseY = cur.y;
                        // 阻止选择与滚动
                        document.body.style.userSelect = 'none';
                        document.body.style.touchAction = 'none';
                        e.preventDefault && e.preventDefault();
                    }

                    function onMove(e) {
                        if (!dragging) return;
                        const pos = getEventPos(e);
                        const dx = pos.x - startX;
                        const dy = pos.y - startY;
                        const tx = baseX + dx;
                        const ty = baseY + dy;
                        container.style.transform = `translate(${tx}px, ${ty}px)`;
                        e.preventDefault && e.preventDefault();
                    }

                    function onEnd() {
                        if (!dragging) return;
                        // 更新基准位置
                        const cur = parseCurrentTranslate();
                        baseX = cur.x;
                        baseY = cur.y;
                        dragging = false;
                        document.body.style.userSelect = '';
                        document.body.style.touchAction = '';
                    }

                    headerEl.addEventListener('mousedown', onStart, { passive: false });
                    document.addEventListener('mousemove', onMove, { passive: false });
                    document.addEventListener('mouseup', onEnd, { passive: true });

                    headerEl.addEventListener('touchstart', onStart, { passive: false });
                    document.addEventListener('touchmove', onMove, { passive: false });
                    document.addEventListener('touchend', onEnd, { passive: true });

                    // 当 modal 打开时，重置居中（如果希望每次打开都居中）
                    const origOpen = window.openAIServiceModal;
                    if (typeof origOpen === 'function') {
                        window.openAIServiceModal = function (opts) {
                            try {
                                const c = document.querySelector('.modal-container');
                                if (c) c.style.transform = '';
                            } catch (_) { /* ignore */ }
                            return origOpen.apply(this, arguments);
                        };
                    }
                } catch (err) {
                    console.warn('[aiModal] enableModalDrag failed', err);
                }
            })();

            // 按ESC键关闭弹窗
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape' && modal && !modal.classList.contains('hidden')) {
                    closeModal();
                }
            });

            // 额外 DOM 元素（新增控件）
            const usagePlatformSelect = document.getElementById('usagePlatformSelect');
            const promptTemplateSelect = document.getElementById('promptTemplateSelect');
            const promptTemplateConfigBtn = document.getElementById('promptTemplateConfigBtn');
            const promptTemplateApplyBtn = document.getElementById('promptTemplateApplyBtn');
            const promptParamsSelect = document.getElementById('promptParamsSelect');
            const insertParamBtn = document.getElementById('insertParamBtn');
            const quickConfigBtn = document.getElementById('quickConfigBtn');


            // 预览按钮：解析占位符并在右侧输出区域展示预览
            (function attachTemplatePreviewHandler() {
                const previewBtn = document.getElementById('promptTemplatePreviewBtn');
                if (!previewBtn) return;
                previewBtn.addEventListener('click', () => {
                    try {
                        const sel = promptTemplateSelect?.options[promptTemplateSelect.selectedIndex];
                        const tpl = sel?.dataset?.content || sel?.value || '';
                        if (!tpl) {
                            showUsageStatus('请选择一个模板以预览', 'warning');
                            return;
                        }
                        // 获取参数定义
                        const params = sel?.dataset?.params ? JSON.parse(sel.dataset.params) : [];
                        const placeholders = {};
                        const chosenKey = (promptParamsSelect?.value || '').trim();

                        if (Array.isArray(params)) {
                            params.forEach(p => {
                                const key = typeof p === 'string' ? p : (p?.name || '');
                                if (!key) return;
                                // 将当前选择的参数名用其自身作为示例值，其它占位符使用空串（并在缺失策略下保留原样）
                                placeholders[key] = (key === chosenKey && chosenKey) ? chosenKey : '';
                            });
                        }

                        const { resolvedText } = resolveTemplatePlaceholders(
                            tpl,
                            placeholders,
                            '{{name}}',
                            { missingPolicy: 'keep' } // 未提供值的占位符保留原样，便于用户确认
                        );

                        // 预览直接写回输入框（稳定换行处理：CRLF/CR 统一为 LF）
                        usagePromptInput.value = String(resolvedText || '').split(/\r?\n/).join("\n");
                        // 同步显示模式为“实际值”
                        const modeText = document.getElementById('promptViewModeText');
                        const toggleChk = document.getElementById('toggleTemplateViewChk');
                        if (modeText) modeText.textContent = '实际值';
                        try { usagePromptInput.readOnly = true; usagePromptInput.classList.add('bg-gray-100'); } catch (_) { /* noop */ }
                        updateUsageSubmitButtonState();
                        showUsageStatus('已生成预览（输入框）', 'info');
                        updateUsageSubmitButtonState();
                    } catch (e) {
                        const msg = e?.message || String(e);
                        console.error('[aiModal] preview error:', msg);
                        // 向父窗口回传预览错误，包含 requestId，便于父页恢复 UI
                        try {
                            const rid = modal?.dataset?.requestId || null;
                            // 预览错误也不要触发父页面立即关闭：加上 keepOpen 标识
                            window.parent?.postMessage({
                                type: 'AI_MODAL_RESULT',

                                requestId: rid,
                                status: 'error',
                                detail: { message: msg, phase: 'preview' },
                                keepOpen: true
                            }, '*');
                        } catch (err) {
                            console.warn('[aiModal] postMessage preview error failed', err);
                        }
                        showUsageStatus('预览失败：' + msg, 'error');
                        usageResultContent.textContent = '预览失败：' + msg;
                        usageResultContent.classList.remove('hidden');
                    }
                });
            })();

            // 输入框视图切换：模板/实际值
            (function attachPromptViewToggle() {
                const toggleChk = document.getElementById('toggleTemplateViewChk');
                const modeText = document.getElementById('promptViewModeText');

                function computeResolvedFromSelection() {
                    const sel = promptTemplateSelect?.options[promptTemplateSelect.selectedIndex];
                    const tpl = sel?.dataset?.content || sel?.value || '';
                    // 如果没有模板来源，尝试从 textarea 的缓存模板取值（防止模板被意外清空）
                    if (!tpl) {
                        try {
                            if (usagePromptInput && usagePromptInput.dataset && usagePromptInput.dataset.template) {
                                // 返回缓存的模板作为 tpl 来源，以便后续替换使用
                                // 注意：此处不修改 textarea.value，仅作为解析来源
                                // 继续执行后面的解析流程
                            } else {
                                return usagePromptInput?.value || '';
                            }
                        } catch (e) { /* ignore */ }
                    }
                    const params = sel?.dataset?.params ? JSON.parse(sel.dataset.params) : [];
                    const placeholders = {};
                    // 优先使用父页面传入的 presetParams（存在时使用其 value），否则使用选中参数名作为示例值
                    let presetMap = null;
                    try {
                        if (modal && modal.dataset && modal.dataset.presetParams) {
                            presetMap = JSON.parse(modal.dataset.presetParams);
                        }
                    } catch (e) { presetMap = null; }
                    const chosenKey = (promptParamsSelect?.value || '').trim();

                    // 如果模板下拉未提供 params，则从模板文本本身提取占位符列表作为兜底
                    let keysFromTpl = [];
                    try {
                        // 使用 tpl 作为扫描源（tpl 来源于选中模板内容或 option.value），
                        // 避免引用尚未声明的 templateSource 变量导致异常或返回空结果。
                        if ((!params || (Array.isArray(params) && params.length === 0)) && tpl) {
                            const txtForScan = String(tpl || '');
                            const re = /\{\{\s*([a-zA-Z0-9_]+)\s*\}\}/g;
                            const found = new Set();
                            let m;
                            while ((m = re.exec(txtForScan)) !== null) {
                                if (m[1]) found.add(m[1]);
                            }
                            keysFromTpl = Array.from(found);
                        }
                    } catch (e) { keysFromTpl = []; }

                    if (Array.isArray(params) && params.length > 0) {
                        params.forEach(p => {
                            const key = typeof p === 'string' ? p : (p?.name || '');
                            if (!key) return;
                            if (presetMap && Object.prototype.hasOwnProperty.call(presetMap, key)) {
                                const v = presetMap[key];
                                // 支持对象和值两种形式：{desc, value} 或 直接值
                                placeholders[key] = (v && typeof v === 'object') ? (v.value ?? '') : String(v ?? '');
                            } else {
                                // 回退：如果是用户在参数下拉选择了某个 key，则把该 key 作为示例值；否则留空以保留占位符
                                placeholders[key] = (key === chosenKey && chosenKey) ? chosenKey : '';
                            }
                        });
                    } else if (Array.isArray(keysFromTpl) && keysFromTpl.length > 0) {
                        // 兜底：根据模板中出现的占位符，从 presetMap 填充值或使用回退策略
                        keysFromTpl.forEach(key => {
                            if (presetMap && Object.prototype.hasOwnProperty.call(presetMap, key)) {
                                const v = presetMap[key];
                                placeholders[key] = (v && typeof v === 'object') ? (v.value ?? '') : String(v ?? '');
                            } else {
                                placeholders[key] = (key === chosenKey && chosenKey) ? chosenKey : '';
                            }
                        });
                    } else if (presetMap) {
                        // 当模板没有 params 定义但父页面传入了参数映射时，使用映射填充
                        Object.entries(presetMap).forEach(([k, v]) => {
                            placeholders[k] = (v && typeof v === 'object') ? (v.value ?? '') : String(v ?? '');
                        });
                    }
                    // 如果 tpl 为空但 textarea 有缓存模板，则使用缓存模板作为模板来源
                    let templateSource = tpl;
                    try {
                        if ((!templateSource || templateSource.trim() === '') && usagePromptInput && usagePromptInput.dataset && usagePromptInput.dataset.template) {
                            templateSource = usagePromptInput.dataset.template;
                        }
                    } catch (e) { /* ignore */ }

                    // 调试日志：打印模板来源、presetMap 与占位符映射，便于定位替换失败原因
                    try {
                        console.debug('[aiModal][dbg] computeResolvedFromSelection:', {
                            templateSourcePreview: String(templateSource || '').slice(0, 200),
                            presetParamsRaw: modal?.dataset?.presetParams || null,
                            placeholdersPreview: Object.keys(placeholders).length ? Object.fromEntries(Object.entries(placeholders).slice(0, 10)) : placeholders
                        });
                    } catch (dbgErr) { /* noop */ }

                    const { resolvedText } = resolveTemplatePlaceholders(
                        templateSource,
                        placeholders,
                        '{{name}}',
                        { missingPolicy: 'keep' }
                    );

                    // 调试日志：resolvedText 与缺失占位符信息
                    try {
                        const preview = String(resolvedText || '').slice(0, 300);
                        console.debug('[aiModal][dbg] resolvedText preview:', preview);
                    } catch (dbgErr) { /* noop */ }

                    // 若解析出空结果，则回退为缓存的模板（避免清空 textarea）
                    if (!resolvedText || String(resolvedText).trim() === '') {
                        return usagePromptInput?.dataset?.template || usagePromptInput?.value || '';
                    }
                    return String(resolvedText || '');
                }

                function computeTemplateFromSelection() {
                    const sel = promptTemplateSelect?.options[promptTemplateSelect.selectedIndex];
                    // 优先返回选中模板的内容；若不存在选中模板，则尝试返回缓存的 template（usagePromptInput.dataset.template）
                    const tpl = (sel?.dataset?.content || sel?.value || '') || '';
                    if (tpl && String(tpl).trim() !== '') return tpl;
                    try {
                        if (usagePromptInput && usagePromptInput.dataset && usagePromptInput.dataset.template) {
                            return usagePromptInput.dataset.template || '';
                        }
                    } catch (e) { /* ignore */ }
                    return '';
                }



                // 在文本中替换占位符，仅替换匹配的 {{key}} 部分，保留其他文本不变
                function replacePlaceholdersInText(text, placeholders) {
                    if (!text) return '';
                    return String(text).replace(/\{\{\s*([a-zA-Z0-9_]+)\s*\}\}/g, function (_, key) {
                        if (Object.prototype.hasOwnProperty.call(placeholders, key)) {
                            return placeholders[key];
                        }
                        return _;
                    });
                }


                // 统一同步：在模板（占位符）视图编辑时同时更新 dataset.template 与 dataset.resolved（实时解析），
                // 在实际值视图编辑时仅更新 dataset.resolved，不覆盖 dataset.template。
                function syncTemplateAndResolved() {
                    try {
                        if (!usagePromptInput) return;
                        if (!usagePromptInput.dataset) usagePromptInput.dataset = {};

                        const isTemplateMode = !!document.getElementById('toggleTemplateViewChk')?.checked;

                        if (isTemplateMode) {
                            // 仅在“占位符模式”下更新模板缓存：以当前 textarea 的值为权威数据源，避免使用落后的 dataset.template
                            const baseSource = String(usagePromptInput.value || '');
                            usagePromptInput.dataset.template = baseSource;

                            const placeholders = buildPlaceholdersMap();
                            console.log('[aiModal] Debug - syncTemplateAndResolved placeholders:', placeholders);
                            const res = resolveTemplatePlaceholders(baseSource, placeholders, '{{name}}', { missingPolicy: 'keep' });
                            usagePromptInput.dataset.resolved = (res && res.resolvedText) ? String(res.resolvedText) : '';
                        }
                    } catch (e) { /* ignore */ }
                }

                // 将函数暴露到全局，保证外部调用（例如 openModal）可成功执行
                try { window.syncTemplateAndResolved = syncTemplateAndResolved; } catch (e) { /* ignore */ }

                function applyView() {
                    const isTemplate = !!(toggleChk && toggleChk.checked);

                    // 首次进入如果没有缓存 template，则优先缓存当前 textarea 内容或选中模板
                    try {
                        if (usagePromptInput && !(usagePromptInput.dataset && usagePromptInput.dataset.template)) {
                            const curCandidate = computeTemplateFromSelection() || usagePromptInput.value || '';
                            if (curCandidate && String(curCandidate).trim() !== '') {
                                usagePromptInput.dataset.template = curCandidate;
                                console.debug('[aiModal] cached template on open/init:', String(curCandidate).slice(0, 200));
                            }
                        }
                    } catch (e) { console.warn('[aiModal] cache template on init failed', e); }

                    if (isTemplate) {
                        // 恢复模板视图：总是从缓存的 template 中恢复（若不存在则从选中模板）
                        const tpl = (usagePromptInput.dataset && usagePromptInput.dataset.template) ? usagePromptInput.dataset.template : computeTemplateFromSelection() || '';
                        // 在恢复模板视图时，先保存当前 textarea 到 dataset.resolved（如果看起来像解析后的实际值）
                        try {
                            if (usagePromptInput && usagePromptInput.value && String(usagePromptInput.value || '').trim() !== '') {
                                const looksLikeResolved = !String(usagePromptInput.dataset?.template || '').trim() || String(usagePromptInput.value || '').includes('{{') === false;
                                // 如果当前文本不是模板（没有 {{ }}），我们把它缓存为 resolved
                                if (looksLikeResolved) {
                                    usagePromptInput.dataset.resolved = usagePromptInput.value;
                                }
                            }
                        } catch (e) { /* ignore */ }

                        usagePromptInput.value = String(tpl).replace(/\r\n/g, "\n");
                        if (modeText) modeText.textContent = '占位符';
                        try { usagePromptInput.readOnly = false; } catch (_) { /* noop */ }
                        try { usagePromptInput.classList.remove('bg-gray-100'); } catch (_) { /* noop */ }

                    } else {
                        // 实际值视图：始终基于当前模板与参数重新解析，避免使用过期的 cachedResolved
                        const placeholders = buildPlaceholdersMap();
                        console.log('[aiModal] Debug - applyView placeholders:', placeholders);
                        const currentText = usagePromptInput ? (usagePromptInput.value || '') : '';
                        const cachedTpl = (usagePromptInput && usagePromptInput.dataset && usagePromptInput.dataset.template) ? usagePromptInput.dataset.template : '';
                        const base = (cachedTpl && String(cachedTpl).trim() !== '') ? cachedTpl : currentText;

                        try {
                            if (!base || String(base).trim() === '') {
                                console.warn('[aiModal][dbg] applyView skip replace: empty base', { basePreview: base });
                            } else {
                                const replaced = replacePlaceholdersInText(base, placeholders);
                                console.log('[aiModal] Debug - applyView replaced:', replaced);
                                usagePromptInput.value = String(replaced).replace(/\r\n/g, "\n");
                                // 覆盖缓存解析结果，确保与当前模板一致
                                if (usagePromptInput && usagePromptInput.dataset) {
                                    usagePromptInput.dataset.resolved = usagePromptInput.value;
                                }
                            }
                        } catch (e) {
                            console.error('[aiModal] applyView resolve failed', e);
                        }
                        if (modeText) modeText.textContent = '实际值';
                        try { usagePromptInput.readOnly = true; } catch (_) { /* noop */ }
                    }
                    updateUsageSubmitButtonState();
                }
                // 开关切换
                if (toggleChk) toggleChk.addEventListener('change', applyView);
                // 模板或参数选择变化时，自动刷新输入框展示
                if (promptTemplateSelect) promptTemplateSelect.addEventListener('change', applyView);
                if (promptParamsSelect) promptParamsSelect.addEventListener('change', applyView);

                // 当用户在 textarea 编辑时，根据当前视图保存到对应的 dataset（template 或 resolved），避免切换丢失
                try {
                    if (usagePromptInput) {
                        usagePromptInput.addEventListener('input', () => {
                            try {
                                if (usagePromptInput) {
                                    usagePromptInput.addEventListener('input', () => {
                                        try {
                                            // 统一同步到 template/resolved（避免重复逻辑）
                                            syncTemplateAndResolved();
                                        } catch (e) { /* ignore */ }

                                    });
                                }
                            } catch (e) { /* ignore */ }
                            updateUsageSubmitButtonState();
                        });
                    }
                } catch (e) { /* ignore */ }

                // 初始化一次（仅在 modal 可见时应用视图）
                if (modal && !modal.classList.contains('hidden')) {
                    applyView();
                }
            })();

            // 扩展 initPlatformSelect：同时填充使用界面的平台下拉，但避免覆盖已由 populateUsagePlatforms 填充的已保存平台列表
            const _origInitPlatformSelect = initPlatformSelect;
            initPlatformSelect = function () {
                _origInitPlatformSelect();
                // 仅在 usagePlatformSelect 尚未被 populateUsagePlatforms 填充时，才从 platformSelect 复制选项，避免覆盖已保存平台列表
                if (usagePlatformSelect && platformSelect) {
                    // 如果 usagePlatformSelect 只有默认项或为空，则同步所有平台选项；否则保持由 populateUsagePlatforms 控制的已保存平台列表
                    try {
                        if (!usagePlatformSelect.options || usagePlatformSelect.options.length <= 1) {
                            usagePlatformSelect.innerHTML = platformSelect.innerHTML;
                            // 若 platformSelect 有选中值，同步到 usagePlatformSelect
                            usagePlatformSelect.value = platformSelect.value || '';
                        } else {
                            // 保持现有的已保存平台列表（由 populateUsagePlatforms 提供）
                            console.debug('[aiModal] keep usagePlatformSelect populated by saved configs');
                        }
                    } catch (e) {
                        // 容错：若检查失败则退回到安全的复制行为
                        try {
                            usagePlatformSelect.innerHTML = platformSelect.innerHTML;
                            usagePlatformSelect.value = platformSelect.value || '';
                        } catch (_) { /* noop */ }
                    }
                }
            };

            // usagePlatformSelect 改变时，同步到 platformSelect 并触发平台变更逻辑
            if (usagePlatformSelect) {
                usagePlatformSelect.addEventListener('change', () => {
                    if (platformSelect) {
                        platformSelect.value = usagePlatformSelect.value;
                        // 触发已有的处理流程
                        onPlatformChange();
                        // 更新使用界面模型下拉
                        updateUsageModelSelect();
                    }
                });
            }

            // quickConfigBtn：打开配置视图并聚焦到对应平台
            if (quickConfigBtn) {
                quickConfigBtn.addEventListener('click', () => {
                    if (usagePlatformSelect && platformSelect) {
                        platformSelect.value = usagePlatformSelect.value || platformSelect.value;
                        loadCurrentPlatformConfig();
                    }
                    switchToConfigView();
                });
            }

            // promptTemplateConfigBtn：进入模板配置视图
            if (promptTemplateConfigBtn) {
                promptTemplateConfigBtn.addEventListener('click', () => {
                    switchToTemplateConfigView();
                });
            }

            // promptTemplateApplyBtn：将选中模板插入输入区域（追加）
            // if (promptTemplateApplyBtn && promptTemplateSelect && usagePromptInput) {
            //     promptTemplateApplyBtn.addEventListener('click', () => {
            //         const opt = promptTemplateSelect.options[promptTemplateSelect.selectedIndex];
            //         // 优先使用 option dataset.content，否则使用 option.value 或文本
            //         const tpl = (opt && (opt.dataset?.content || opt.value || opt.text)) || '';
            //         if (!tpl) return;
            //         // 如果输入框已有内容，添加分隔换行
            //         const cur = usagePromptInput.value || '';
            //         usagePromptInput.value = cur ? (cur + "\n\n" + tpl) : tpl;
            //         usagePromptInput.focus();
            //         updateUsageSubmitButtonState();
            //         // 追加：应用模板时清空输入并切到占位符模式，然后写入模板并同步
            //         try {
            //             const toggleChk = document.getElementById('toggleTemplateViewChk');
            //             const modeText = document.getElementById('promptViewModeText');
            //             // 清空并切换模式
            //             usagePromptInput.value = '';
            //             if (toggleChk) toggleChk.checked = true;
            //             if (modeText) modeText.textContent = '占位符';
            //             try { usagePromptInput.readOnly = false; usagePromptInput.classList.remove('bg-gray-100'); } catch (_) { /* noop */ }
            //             // 写入模板并缓存
            //             if (!usagePromptInput.dataset) usagePromptInput.dataset = {};
            //             usagePromptInput.dataset.template = tpl;
            //             // 清空过期的实际值缓存，防止切换到“实际值”视图时显示旧内容
            //             usagePromptInput.dataset.resolved = '';
            //             usagePromptInput.value = String(tpl).replace(/\r\n/g, "\n");
            //             // 同步视图
            //             try { syncTemplateAndResolved(); } catch (_) { /* ignore */ }
            //             try { if (typeof applyView === 'function') applyView(); } catch (_) { /* noop */ }
            //             try { showUsageStatus('已应用模板并切换到占位符模式', 'success'); } catch (_) { /* noop */ }
            //         } catch (_) { /* noop */ }
            //     });
            // }

            // insertParamBtn：在光标位置插入参数占位符（{{paramName}}）
            if (insertParamBtn && usagePromptInput) {
                insertParamBtn.addEventListener('click', () => {
                    const name = promptParamsSelect.value || (promptParamsSelect.options[promptParamsSelect.selectedIndex]?.value) || '';
                    if (!name) return;
                    const placeholder = `{{${name}}}`; // 双花括号包裹参数名
                    const textarea = usagePromptInput;
                    const start = textarea.selectionStart || 0;
                    const end = textarea.selectionEnd || 0;
                    const before = textarea.value.substring(0, start);
                    const after = textarea.value.substring(end);
                    textarea.value = before + placeholder + after;
                    // 将光标移到插入后面
                    const pos = start + placeholder.length;
                    textarea.selectionStart = textarea.selectionEnd = pos;
                    textarea.focus();
                    updateUsageSubmitButtonState();

                    // 更新缓存

                    syncTemplateAndResolved();



                });
            }

            // 当用户在配置界面保存/切换平台后，确保 usagePlatformSelect 与 usageModelSelect 更新
            const _origLoadCurrentPlatformConfig = loadCurrentPlatformConfig;
            loadCurrentPlatformConfig = function () {
                _origLoadCurrentPlatformConfig();
                // 将 platformSelect 的值同步到 usagePlatformSelect
                if (usagePlatformSelect && platformSelect) {
                    usagePlatformSelect.value = platformSelect.value || '';
                }
                // 更新使用界面模型选择
                updateUsageModelSelect();
            };

            function populateUsagePlatforms() {
                if (!usagePlatformSelect) return;
                usagePlatformSelect.innerHTML = '<option value="">-- 请选择平台 --</option>';
                const platforms = aiService.getPlatforms();
                const configuredKeys = [];
                Object.entries(allPlatformConfigs || {}).forEach(([key, cfg]) => {
                    const savedConfigured = !!(cfg && cfg.apiKey && cfg.apiKey.trim() !== '' &&
                        (key !== 'cloudflare' || (cfg.cloudflareAccountId && cfg.cloudflareAccountId.trim() !== '')) &&
                        (key !== 'azure' || (cfg.azureEndpoint && cfg.azureEndpoint.trim() !== '')));
                    if (savedConfigured) {
                        const opt = document.createElement('option');
                        opt.value = key;
                        opt.textContent = platforms[key]?.name || key;
                        usagePlatformSelect.appendChild(opt);
                        configuredKeys.push(key);
                    }
                });
                // 如果当前 platformSelect 有值且已配置，同步它
                if (platformSelect && usagePlatformSelect.querySelector(`option[value="${platformSelect.value}"]`)) {
                    usagePlatformSelect.value = platformSelect.value;
                }
            }

            // 初始化函数现在由aiService.initialize()成功后调用，避免重复初始化
            // initPlatformSelect();
            // loadAllConfigsFromStorage();
            // populateUsagePlatforms();

            // 强制初始化提示词视图默认状态：确保无论如何打开组件都会默认处于“占位符”模式并缓存 template
            (function initPromptViewDefaults() {
                try {
                    const chk = document.getElementById('toggleTemplateViewChk');
                    const modeText = document.getElementById('promptViewModeText');
                    // 默认置为占位符视图
                    if (chk) chk.checked = true;
                    if (modeText) modeText.textContent = '占位符';

                    // 若 textarea 没有缓存 template，则从选中模板或当前值缓存一个模板，避免切换时丢失
                    if (usagePromptInput) {
                        if (!usagePromptInput.dataset) usagePromptInput.dataset = {};
                        if (!usagePromptInput.dataset.template || String(usagePromptInput.dataset.template).trim() === '') {
                            const sel = promptTemplateSelect?.options[promptTemplateSelect.selectedIndex];
                            const tpl = sel?.dataset?.content || sel?.value || (usagePromptInput.value || '');
                            usagePromptInput.dataset.template = String(tpl || '');
                        }
                    }

                    // 若 modal 当前可见，立刻应用视图以同步显示（安全兜底）
                    if (modal && !modal.classList.contains('hidden') && typeof applyView === 'function') {
                        try { applyView(); } catch (_) { /* noop */ }
                    }
                } catch (e) { console.warn('initPromptViewDefaults failed', e); }
            })();

            // 统一脏状态监听（配置、模板与使用输入）
            (function attachDirtyListeners() {
                const ids = [
                    'apiKeyInput', 'cloudflareAccountId', 'azureEndpoint',
                    'temperatureInput', 'maxTokensInput',
                    'tplNameInput', 'tplTypeInput', 'tplCallerInput', 'tplDescInput', 'tplContentInput',
                    'usagePromptInput'
                ];
                ids.forEach(id => {
                    const el = document.getElementById(id);
                    if (el) el.addEventListener('input', () => setDirty(true));
                });
            })();

            // 填充左侧已保存平台列表（仅显示已保存的平台）
            if (typeof populateSavedPlatformsList === 'function') {
                populateSavedPlatformsList();
            }

            // 模板数据管理（本地优先，文件为初始导入）
            const TPL_STORE_KEY = 'promptTemplates';
            let promptTemplates = [];

            function loadTemplatesFromStorage() {
                try {
                    const s = localStorage.getItem(TPL_STORE_KEY);
                    if (!s) return null;
                    const arr = JSON.parse(s);
                    if (Array.isArray(arr)) return arr;
                } catch (_) { }
                return null;
            }

            function saveTemplatesToStorage(arr) {
                promptTemplates = Array.isArray(arr) ? arr : [];
                localStorage.setItem(TPL_STORE_KEY, JSON.stringify(promptTemplates));
            }

            async function ensureTemplatesLoaded() {
                // 1) 优先本地存储
                const fromLocal = loadTemplatesFromStorage();
                if (fromLocal && Array.isArray(fromLocal)) {
                    promptTemplates = fromLocal;
                    return;
                }

                // 2) 再读同目录 JSON
                let loaded = false;
                try {
                    const res = await fetch('./prompt-templates.json', { cache: 'no-cache' });
                    if (!res.ok) throw new Error('加载提示词模板失败: ' + res.status);
                    const fileTpls = await res.json();
                    // 直接使用文件中的 content（模板由团队维护，内容应包含真实换行），不做多重转义解码
                    promptTemplates = (Array.isArray(fileTpls) ? fileTpls : []).map(t => {
                        const contentRaw = t.content || '';
                        const contentDecoded = String(contentRaw); // 直接使用，不做额外反转义
                        return {
                            name: t.name || '',
                            description: t.description || '',
                            type: t.type || '',
                            caller: t.caller || '',
                            params: Array.isArray(t.params) ? t.params : [],
                            content: contentDecoded
                        };
                    });
                    saveTemplatesToStorage(promptTemplates);
                    loaded = true;
                } catch (e) {
                    console.warn('加载初始模板失败（可能是直接 file:// 打开导致 fetch 受限）:', e);
                }

                // 3) 兜底：提供一个“默认模板”
                if (!loaded || !Array.isArray(promptTemplates) || promptTemplates.length === 0) {
                    promptTemplates = [{
                        name: '默认模板',
                        description: '基础提示词模板（兜底）',
                        type: '默认',
                        caller: 'AI应用',
                        params: ['name'],
                        content: '你是一个MindWord产品中的AI助手，请根据用户的需求，提供相应的帮助。当前节点：{{name}}'
                    }];
                    saveTemplatesToStorage(promptTemplates);
                }
            }

            function populateTemplateSelect() {
                const tplSelect = document.getElementById('promptTemplateSelect');
                const paramsSelect = document.getElementById('promptParamsSelect');
                if (!tplSelect) return;
                tplSelect.innerHTML = '';
                const defaultOpt = document.createElement('option');
                defaultOpt.value = '';
                defaultOpt.textContent = '默认模板';
                tplSelect.appendChild(defaultOpt);

                promptTemplates.forEach((t, idx) => {
                    const opt = document.createElement('option');
                    opt.value = String(idx);
                    opt.textContent = t.name || (`模板 ${idx + 1}`);
                    opt.dataset.content = t.content || '';
                    opt.dataset.params = JSON.stringify(t.params || []);
                    opt.title = t.description || '';
                    tplSelect.appendChild(opt);
                });

                tplSelect.addEventListener('change', () => {
                    const sel = tplSelect.options[tplSelect.selectedIndex];
                    const params = sel?.dataset?.params ? JSON.parse(sel.dataset.params) : [];
                    if (paramsSelect) {
                        paramsSelect.innerHTML = '';
                        params.forEach(p => {
                            const pOpt = document.createElement('option');
                            if (typeof p === 'string') {
                                pOpt.value = p;
                                pOpt.textContent = p;
                                pOpt.title = '';
                            } else {
                                pOpt.value = p.name || '';
                                pOpt.textContent = p.name || p.value || '';
                                pOpt.title = p.description || '';
                            }
                            paramsSelect.appendChild(pOpt);
                        });
                    }
                });

                tplSelect.dispatchEvent(new Event('change'));
            }

            // 初始化“应用”界面的模板下拉与“应用”按钮
            (function initTemplatesUI() {
                const applyBtn = document.getElementById('promptTemplateApplyBtn');
                ensureTemplatesLoaded().then(() => {
                    populateTemplateSelect();
                });

                if (applyBtn) {

                    applyBtn.addEventListener('click', () => { // 绑定点击事件，应用选中的模板

                        try {
                            const toggleChk = document.getElementById('toggleTemplateViewChk');
                            const modeText = document.getElementById('promptViewModeText');
                            // 清空并切换模式
                            usagePromptInput.value = '';
                            if (toggleChk) toggleChk.checked = true;
                            if (modeText) modeText.textContent = '占位符';
                            try { usagePromptInput.readOnly = false; usagePromptInput.classList.remove('bg-gray-100'); } catch (_) { /* noop */ }
                            // 写入模板并缓存
                            if (!usagePromptInput.dataset) usagePromptInput.dataset = {};
                            usagePromptInput.dataset.template = tpl;
                            // 清空过期的实际值缓存，防止切换到“实际值”视图时显示旧内容
                            usagePromptInput.dataset.resolved = '';
                            usagePromptInput.value = String(tpl).replace(/\r\n/g, "\n");
                            // 同步视图
                            try { syncTemplateAndResolved(); } catch (_) { /* ignore */ }
                            try { if (typeof applyView === 'function') applyView(); } catch (_) { /* noop */ }
                            try { showUsageStatus('已应用模板并切换到占位符模式', 'success'); } catch (_) { /* noop */ }
                        } catch (_) { /* noop */ }

                        const tplSelect = document.getElementById('promptTemplateSelect'); // 获取模板选择下拉框
                        const sel = tplSelect?.options[tplSelect.selectedIndex]; // 获取当前选中的选项
                        const tpl = sel.dataset.content; // 读取data-content
                        if (!tpl) return; // 若模板内容为空则直接返回
                        usagePromptInput.value = tpl; // 把模板内容应用到输入框


                        usagePromptInput.focus(); // 聚焦输入框
                        updateUsageSubmitButtonState(); // 更新提交按钮的可用状态

                        syncTemplateAndResolved();

                    });
                }

                // 移除使用界面底部按钮（避免重复发送按钮）
                const usageFooter = document.getElementById('usageViewFooter');
                if (usageFooter) usageFooter.remove();
            })();

            // 模板配置界面逻辑
            const templateStatusBar = document.getElementById('templateStatusBar');
            const templateList = document.getElementById('templateList');
            const addTemplateBtn = document.getElementById('addTemplateBtn');
            const exportTemplatesBtn = document.getElementById('exportTemplatesBtn');
            const importTemplatesBtn = document.getElementById('importTemplatesBtn');
            const importTemplatesFileInput = document.getElementById('importTemplatesFileInput');
            const tplNameInput = document.getElementById('tplNameInput');
            const tplTypeInput = document.getElementById('tplTypeInput');
            const tplCallerInput = document.getElementById('tplCallerInput');
            const tplDescInput = document.getElementById('tplDescInput');
            const tplParamsContainer = document.getElementById('tplParamsContainer');
            const addTplParamBtn = document.getElementById('addTplParamBtn');
            const tplContentInput = document.getElementById('tplContentInput');
            const tplSaveBtn = document.getElementById('tplSaveBtn');
            const tplBackBtn = document.getElementById('tplBackBtn');
            if (tplBackBtn) {
                tplBackBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    switchToUsageView();
                });
            }

            let editingTplIndex = -1;

            function showTplStatus(msg, type = 'info') {
                if (!templateStatusBar) return;
                templateStatusBar.textContent = msg;
                templateStatusBar.className = 'mb-4 p-3 rounded-md text-sm';
                const map = {
                    info: ['bg-blue-100', 'text-blue-800'],
                    success: ['bg-green-100', 'text-green-800'],
                    warning: ['bg-yellow-100', 'text-yellow-800'],
                    error: ['bg-red-100', 'text-red-800'],
                };
                templateStatusBar.classList.add(...(map[type] || map.info));
            }

            function renderTplParams(params) {
                tplParamsContainer.innerHTML = '';
                (params || []).forEach((p, i) => addParamRow(typeof p === 'string' ? { name: p, description: '' } : p));
            }

            function addParamRow(p = { name: '', description: '' }) {
                const row = document.createElement('div');
                row.className = 'flex items-start gap-2';
                const name = document.createElement('input');
                name.className = 'form-control w-28';
                name.placeholder = '参数名';
                name.value = p.name || '';
                const desc = document.createElement('textarea');
                desc.className = 'form-control min-h-[40px] max-h-[72px] resize-none overflow-y-auto';
                desc.placeholder = '参数描述';
                desc.value = p.description || '';
                // 自适应高度，最多三行
                const autoResize = () => {
                    desc.style.height = 'auto';
                    const maxH = 72; // px，约三行
                    const needed = desc.scrollHeight;
                    desc.style.height = Math.min(needed, maxH) + 'px';
                };
                desc.addEventListener('input', autoResize);
                setTimeout(autoResize, 0);
                const del = document.createElement('button');
                del.className = 'btn btn-outline text-[12px] px-2 py-1 whitespace-nowrap';
                del.textContent = '删除';
                del.addEventListener('click', () => row.remove());
                row.appendChild(name);
                row.appendChild(desc);
                row.appendChild(del);
                tplParamsContainer.appendChild(row);
            }

            function collectParams() {
                const rows = Array.from(tplParamsContainer.children);
                return rows.map(r => {
                    const nameInput = r.querySelector('input');
                    const descArea = r.querySelector('textarea');
                    return {
                        name: nameInput?.value?.trim() || '',
                        description: descArea?.value?.trim() || ''
                    };
                }).filter(p => p.name);
            }

            function clearTplForm() {
                editingTplIndex = -1;
                tplNameInput.value = '';
                tplTypeInput.value = '';
                tplCallerInput.value = '';
                tplDescInput.value = '';
                tplContentInput.value = '';
                tplParamsContainer.innerHTML = '';
            }

            function fillTplForm(t) {
                tplNameInput.value = t.name || '';
                tplTypeInput.value = t.type || '';
                tplCallerInput.value = t.caller || '';
                tplDescInput.value = t.description || '';
                tplContentInput.value = t.content || '';
                renderTplParams(t.params || []);
            }

            function renderTemplateList() {
                if (!templateList) return;
                templateList.innerHTML = '';
                if (!Array.isArray(promptTemplates) || promptTemplates.length === 0) {
                    const p = document.createElement('p');
                    p.className = 'text-sm text-gray-500';
                    p.textContent = '暂无模板';
                    templateList.appendChild(p);
                    return;
                }
                promptTemplates.forEach((t, idx) => {
                    const row = document.createElement('div');
                    row.className = 'px-2 py-1 rounded-md hover:bg-gray-100 flex justify-between items-center';
                    const left = document.createElement('div');
                    left.className = 'flex-1 min-w-0';
                    const span = document.createElement('span');
                    span.className = 'text-sm truncate cursor-pointer';
                    span.textContent = t.name || `模板 ${idx + 1}`;
                    left.appendChild(span);
                    const right = document.createElement('div');
                    const delBtn = document.createElement('button');
                    delBtn.className = 'btn btn-outline text-[11px] px-2 py-0.5';
                    delBtn.textContent = '删除';

                    // 点击整条 row 进行选中与回显，确保高亮区域与点击区域一致
                    row.addEventListener('click', () => {
                        Array.from(templateList.children).forEach(c => c.classList.remove('bg-primary/10'));
                        row.classList.add('bg-primary/10');
                        editingTplIndex = idx;
                        fillTplForm(promptTemplates[idx]);
                    });

                    delBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        promptTemplates.splice(idx, 1);
                        saveTemplatesToStorage(promptTemplates);
                        renderTemplateList();
                        populateTemplateSelect();
                        showTplStatus('已删除模板', 'success');
                        if (editingTplIndex === idx) clearTplForm();
                    });

                    // 默认高亮当前编辑项
                    if (idx === editingTplIndex) {
                        row.classList.add('bg-primary/10');
                    }

                    right.appendChild(delBtn);
                    row.appendChild(left);
                    row.appendChild(right);
                    templateList.appendChild(row);
                });
            }

            function switchToTemplateConfigView() {
                aiUsageView.classList.add('hidden');
                aiConfigView.classList.add('hidden');
                const v = document.getElementById('templateConfigView');
                if (v) v.classList.remove('hidden');
                // 设置弹窗高度（模板配置界面更高）
                const modalContainer = document.querySelector('.modal-container');
                if (modalContainer) modalContainer.style.height = 'auto';
                // 弹窗主体内部滚动，底部按钮固定可见
                const modalBodyEl = document.querySelector('.modal-body');
                if (modalBodyEl) modalBodyEl.style.overflowY = 'auto';

                currentView = 'template';
                ensureTemplatesLoaded().then(() => {
                    renderTemplateList();
                    // 默认选中第一个并右侧回显
                    if (Array.isArray(promptTemplates) && promptTemplates.length > 0) {
                        editingTplIndex = 0;
                        fillTplForm(promptTemplates[0]);
                    } else {
                        clearTplForm();
                    }
                });
            }

            if (addTplParamBtn) addTplParamBtn.addEventListener('click', () => addParamRow());

            if (tplSaveBtn) tplSaveBtn.addEventListener('click', (e) => {
                e.preventDefault();
                const obj = {
                    name: tplNameInput.value.trim(),
                    type: tplTypeInput.value.trim(),
                    caller: tplCallerInput.value.trim(),
                    description: tplDescInput.value.trim(),
                    params: collectParams(),
                    content: tplContentInput.value
                };
                if (!obj.name) {
                    showTplStatus('请填写模板名称', 'error');
                    return;
                }
                // 校验名称不能重复（除当前编辑项外）
                const existsIndex = (promptTemplates || []).findIndex((t, i) => (t.name || '') === obj.name && i !== editingTplIndex);
                if (existsIndex !== -1) {
                    showTplStatus('名称重复，请更换', 'error');
                    return;
                }
                if (editingTplIndex >= 0 && editingTplIndex < promptTemplates.length) {
                    promptTemplates[editingTplIndex] = obj;
                } else {
                    promptTemplates.push(obj);
                    editingTplIndex = promptTemplates.length - 1;
                }
                saveTemplatesToStorage(promptTemplates);
                renderTemplateList();
                populateTemplateSelect();
                showTplStatus('模板已保存', 'success');
                // 清除脏状态并派发保存事件
                setDirty(false);
                emitEvent('save', { scope: 'templates', data: obj });
            });

            // 底部固定按钮事件绑定
            const tplBackBtnFooter = document.getElementById('tplBackBtnFooter');
            const tplSaveBtnFooter = document.getElementById('tplSaveBtnFooter');
            if (tplBackBtnFooter) tplBackBtnFooter.addEventListener('click', (e) => { e.preventDefault(); switchToUsageView(); });
            if (tplSaveBtnFooter) tplSaveBtnFooter.addEventListener('click', (e) => { e.preventDefault(); tplSaveBtn?.click(); });

            if (addTemplateBtn) addTemplateBtn.addEventListener('click', () => {
                clearTplForm();
                showTplStatus('已创建新模板草稿，请填写后保存', 'info');
            });

            if (exportTemplatesBtn) exportTemplatesBtn.addEventListener('click', () => {
                const data = JSON.stringify(promptTemplates || [], null, 2);
                const blob = new Blob([data], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `prompt-templates-${new Date().toISOString().slice(0, 19).replace(/[:T]/g, '-')}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                showTplStatus('模板已导出', 'success');
            });

            if (importTemplatesBtn && importTemplatesFileInput) {
                importTemplatesBtn.addEventListener('click', () => importTemplatesFileInput.click());
                importTemplatesFileInput.addEventListener('change', (e) => {
                    const file = e.target.files && e.target.files[0];
                    if (!file) return;
                    const reader = new FileReader();
                    reader.onload = () => {
                        try {
                            const json = JSON.parse(reader.result);
                            if (Array.isArray(json)) {
                                // 规范化字段
                                promptTemplates = json.map(t => ({
                                    name: t.name || '',
                                    description: t.description || '',
                                    type: t.type || '',
                                    caller: t.caller || '',
                                    params: Array.isArray(t.params) ? t.params : [],
                                    content: t.content || ''
                                }));
                                saveTemplatesToStorage(promptTemplates);
                                renderTemplateList();
                                populateTemplateSelect();
                                showTplStatus('模板已导入', 'success');
                            } else {
                                showTplStatus('导入失败：文件格式不正确（应为数组）', 'error');
                            }
                        } catch (err) {
                            showTplStatus('导入失败：' + (err.message || err), 'error');
                        } finally {
                            importTemplatesFileInput.value = '';
                        }
                    };
                    reader.readAsText(file, 'utf-8');
                });
            }

            // 新：填充并管理左侧已保存平台列表
            function loadAllConfigsLocal() {
                return allPlatformConfigs || {};
            }

            function populateSavedPlatformsList() {
                const container = document.getElementById('savedPlatformsList');
                if (!container) return;
                container.innerHTML = '';

                const configs = loadAllConfigsLocal();
                const keys = Object.keys(configs || {});
                if (keys.length === 0) {
                    const p = document.createElement('p');
                    p.className = 'text-sm text-gray-500';
                    p.textContent = '尚未保存任何平台';
                    container.appendChild(p);
                    return;
                }

                keys.forEach(key => {
                    const row = document.createElement('div');
                    row.className = 'px-2 py-1 rounded-md hover:bg-gray-100 flex flex-col sm:flex-row sm:justify-between sm:items-center space-y-1 sm:space-y-0';
                    row.dataset.platformKey = key;

                    const left = document.createElement('div');
                    left.className = 'flex-1 min-w-0 cursor-pointer';
                    const displayName = (configs[key] && configs[key].platformName) || (aiService.getPlatforms()[key]?.name) || key;
                    const span = document.createElement('span');
                    span.textContent = displayName;
                    span.className = 'text-sm truncate';
                    left.appendChild(span);

                    const delBtn = document.createElement('button');
                    delBtn.className = 'btn btn-outline text-[11px] px-1 py-0.5 sm:ml-2 self-start sm:self-auto';
                    delBtn.title = '删除';
                    delBtn.textContent = '删除';

                    left.addEventListener('click', () => {
                        Array.from(container.children).forEach(c => c.classList.remove('bg-primary/10'));
                        row.classList.add('bg-primary/10');
                        loadPlatformToConfig(key);
                    });

                    delBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        if (!allPlatformConfigs[key]) return;
                        delete allPlatformConfigs[key];
                        // 删除平台配置后保存完整配置 - 现在所有配置都包含platformName
                        localStorage.setItem('allAIPlatformConfigs', JSON.stringify(allPlatformConfigs));
                        if (favoriteModels && favoriteModels[key]) delete favoriteModels[key];
                        populateSavedPlatformsList();
                        populateUsagePlatforms();
                        // 若当前右侧显示的是被删项，清空表单
                        if (platformSelect.value === key) {
                            platformSelect.value = '';
                            apiKeyInput.value = '';
                            cloudflareAccountId.value = '';
                            azureEndpoint.value = '';
                            if (favoriteModelsList) favoriteModelsList.innerHTML = '';
                            updateConfigStatus();
                        }
                        showStatus('已删除平台配置', 'success');
                    });

                    row.appendChild(left);
                    row.appendChild(delBtn);
                    container.appendChild(row);
                });
            }

            async function loadPlatformToConfig(key) {
                if (!key || !allPlatformConfigs[key]) return;
                const cfg = allPlatformConfigs[key];
                // 设定 platformSelect 为 key 并加载其配置
                platformSelect.value = key;

                apiKeyInput.value = cfg.apiKey || '';
                cloudflareAccountId.value = cfg.cloudflareAccountId || '';
                azureEndpoint.value = cfg.azureEndpoint || '';
                temperatureInput.value = cfg.temperature || 0.7;
                maxTokensInput.value = cfg.maxTokens || 1000;

                // 先确保模型已加载（否则无法回显复选）
                try {
                    const info = aiService.getPlatforms()[key] || {};
                    const needFetch = Array.isArray(aiService.getModels(key)) ? aiService.getModels(key).length === 0 : true;
                    if (needFetch && cfg.apiKey) {
                        modelLoadingIndicator.classList.remove('hidden');
                        const options = {};
                        if (key === 'cloudflare' && cfg.cloudflareAccountId) options.cloudflareAccountId = cfg.cloudflareAccountId;
                        await aiService.fetchModels(key, cfg.apiKey, options);
                    }
                } catch (e) {
                    console.warn('加载模型失败（回显仍继续）:', e);
                } finally {
                    modelLoadingIndicator.classList.add('hidden');
                }

                // 加载 favoriteModels 到内存变量并刷新列表
                if (cfg.favoriteModels) {
                    favoriteModels[key] = cfg.favoriteModels;
                } else {
                    favoriteModels[key] = [];
                }
                // 更新界面
                updateFavoriteModelsList();

                // 展示配置面板并更新状态
                if (configContent) expandConfig();
                updateConfigStatus();
            }

            // 添加 / 删除 平台按钮逻辑
            const addPlatformBtn = document.getElementById('addPlatformBtn');
            const removePlatformBtn = document.getElementById('removePlatformBtn');

            if (addPlatformBtn) {
                addPlatformBtn.addEventListener('click', () => {
                    // 点击“添加”时：仅在右侧展示空表单供填写（不创建临时数据、不写入 storage）
                    // 清空右侧表单字段以便用户填写新配置
                    platformSelect.value = '';
                    apiKeyInput.value = '';
                    cloudflareAccountId.value = '';
                    azureEndpoint.value = '';
                    temperatureInput.value = 0.7;
                    maxTokensInput.value = 1000;
                    // 清空右侧常用模型 UI（不影响已保存数据）
                    if (favoriteModelsList) favoriteModelsList.innerHTML = '';
                    if (configContent) expandConfig();
                    showStatus('请在右侧填写新平台配置，填写完成后点击“保存配置”以创建新项', 'info');
                });
            }

            // 顶部删除按钮已移除；删除操作在侧栏每一项的“删除”按钮中实现

            // 在保存配置后刷新侧栏并自动选中当前平台
            const _origSaveCurrentPlatformConfig = saveCurrentPlatformConfig;
            saveCurrentPlatformConfig = function () {
                _origSaveCurrentPlatformConfig();

                // 当前在编辑的 key：优先从 platformSelect 获取（如果为空，尝试从已选侧栏项或临时草稿保持一致）
                let currentKey = platformSelect.value || null;

                // 如果 platformSelect 为空，但 loadPlatformToConfig 在加载草稿时会把 platformSelect 设置为草稿 key
                if (!currentKey && typeof document !== 'undefined') {
                    // 尝试从 savedPlatformsList 中找到带选中样式的项
                    const container = document.getElementById('savedPlatformsList');
                    if (container) {
                        const selected = Array.from(container.children).find(c => c.classList.contains('bg-primary/10'));
                        if (selected) currentKey = selected.dataset.platformKey;
                    }
                }

                // 如果仍没有 key，退出保存扩展逻辑
                if (!currentKey) {
                    // 避免重复保存，直接返回
                    return;
                }

                // 如果是草稿 key（以 custom_ 开头），尝试把草稿迁移为真实 key
                if (currentKey.startsWith('custom_')) {
                    // 优先使用用户在 platformSelect 中选择的真实平台作为新 key
                    const chosenPlatform = platformSelect.value && !platformSelect.value.startsWith('custom_') ? platformSelect.value : null;
                    let newKey = chosenPlatform;

                    // 若用户未在 platformSelect 选择平台，则尝试使用平台友好名作为 key（去空格与非字母数字）
                    if (!newKey) {
                        const draftCfg = allPlatformConfigs[currentKey] || {};
                        const nameCandidate = (draftCfg.platformName || '').trim();
                        if (nameCandidate) {
                            newKey = nameCandidate.replace(/\s+/g, '_').replace(/[^\w\-]/g, '').toLowerCase();
                        }
                    }

                    // 如果仍无可用 newKey，则使用时间戳命名但不保留 custom_ 前缀
                    if (!newKey) {
                        newKey = `platform_${Date.now()}`;
                    }

                    // 若 newKey 已存在，追加时间戳以避免覆盖
                    if (allPlatformConfigs[newKey] && newKey !== currentKey) {
                        newKey = `${newKey}_${Date.now()}`;
                    }

                    // 迁移草稿到 newKey
                    allPlatformConfigs[newKey] = allPlatformConfigs[currentKey];
                    // 如果用户在保存时选择了真实平台名，记录它
                    if (platformSelect.value && !platformSelect.value.startsWith('custom_')) {
                        // 设定平台标识为 newKey（已是 chosenPlatform）
                    }
                    // 删除草稿 key
                    delete allPlatformConfigs[currentKey];
                    // 更新 currentKey 引用为 newKey
                    currentKey = newKey;
                    // 将 platformSelect 设为新的 key（以便后续 UI 同步）
                    platformSelect.value = currentKey;
                }

                // 更新友好名称（若存在）
                if (currentKey && allPlatformConfigs[currentKey]) {
                    allPlatformConfigs[currentKey].platformName = allPlatformConfigs[currentKey].platformName || (aiService.getPlatforms()[currentKey]?.name) || currentKey;
                }

                // 写回存储并刷新侧栏（保存后再刷新）
                // 现在所有配置都包含platformName，确保数据一致性
                // 强制确保所有配置都有platformName，避免数据不一致
                Object.keys(allPlatformConfigs).forEach(key => {
                    if (allPlatformConfigs[key] && !allPlatformConfigs[key].platformName) {
                        allPlatformConfigs[key].platformName = (aiService.getPlatforms()[key]?.name) || key;
                    }
                });
                localStorage.setItem('allAIPlatformConfigs', JSON.stringify(allPlatformConfigs));
                populateSavedPlatformsList();

                // 自动选中当前 platform 在侧栏
                const container = document.getElementById('savedPlatformsList');
                if (container) {
                    Array.from(container.children).forEach(c => {
                        if (c.dataset.platformKey === currentKey) c.classList.add('bg-primary/10');
                        else c.classList.remove('bg-primary/10');
                    });
                }
            };

            // 提供一个公开方法，允许从外部设置提示词并打开弹窗
            window.setAIPromptAndOpenModal = function (prompt) {
                if (modal) modal.dataset.presetPrompt = prompt;
                if (window.AIServiceModalAutoOpen === true) openModal();
            };

            // 折叠/展开配置区域（占位实现，避免未定义报错）
            function expandConfig() {
                // TODO: 实现折叠逻辑，或保留为空避免报错
                console.debug('[expandConfig] 折叠/展开配置区域（未实现）');
            }

            // 解析模板占位符：支持 {{name}} / ${name} / %name%
            function resolveTemplatePlaceholders(templateText, placeholders = {}, placeholderFormat = '{{name}}', options = {}) {
                const { missingPolicy = 'error', defaultPlaceholderValue = '' } = options || {};
                const text = String(templateText || '');
                const usedPlaceholders = [];
                const missingPlaceholders = [];

                console.log('[aiModal] Debug - resolveTemplatePlaceholders input:', { templateText, placeholders, placeholderFormat });

                // 选择正则模式
                let regex;
                if (placeholderFormat === '{{name}}') {
                    regex = /\{\{\s*([a-zA-Z0-9_]+)\s*\}\}/g;
                } else if (placeholderFormat === '${name}') {
                    regex = /\$\{\s*([a-zA-Z0-9_]+)\s*\}/g;
                } else if (placeholderFormat === '%name%') {
                    regex = /%\s*([a-zA-Z0-9_]+)\s*%/g;
                } else {
                    // 自定义格式：用 'name' 作为占位符关键字，推断前后缀
                    const idx = placeholderFormat.indexOf('name');
                    const prefix = idx >= 0 ? placeholderFormat.slice(0, idx) : '';
                    const suffix = idx >= 0 ? placeholderFormat.slice(idx + 4) : '';
                    const esc = s => s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
                    regex = new RegExp(`${esc(prefix)}\\s*([a-zA-Z0-9_]+)\\s*${esc(suffix)}`, 'g');
                }

                // 固定仅基于传入的 templateText 进行替换：有值就替换，无值保留原样
                let resolved = String(templateText || '').replace(regex, (match, key) => {
                    usedPlaceholders.push(key);
                    const has = Object.prototype.hasOwnProperty.call(placeholders || {}, key);
                    if (has && placeholders[key] !== undefined && placeholders[key] !== null) {
                        return String(placeholders[key]);
                    } else {
                        missingPlaceholders.push(key);
                        return match; // 无值则保持占位符原样
                    }
                });

                // 严格校验：任何缺失都报错
                if (options.validateStrict && missingPlaceholders.length > 0) {
                    const msg = `缺少占位符值: ${missingPlaceholders.join(', ')}`;
                    const error = { code: 'MISSING_PLACEHOLDER', message: msg, detail: { missingPlaceholders } };
                    throw error;
                }

                return { resolvedText: resolved, usedPlaceholders, missingPlaceholders };
            }

            // 仅预览解析结果（不发送）
            window.previewResolvedTemplate = function ({ templateData = {}, options = {} } = {}) {
                const { templateText = '', placeholders = {}, placeholderFormat = '{{name}}' } = templateData || {};
                if (!templateText) {
                    throw { code: 'MISSING_TEMPLATE', message: '未提供模板文本或模板ID', detail: {} };
                }
                return resolveTemplatePlaceholders(templateText, placeholders, placeholderFormat, options);
            };



            window.openAIServiceModal = function (options = {}) {
                const { title, initialView, presetPrompt, requestId, miniPrompt } = options;

                // 设置标题
                const titleEl = document.getElementById('modalTitle');
                if (titleEl && typeof title === 'string' && title.trim()) {
                    titleEl.textContent = title.trim();
                }

                // 传入初始视图与预设提示词
                if (typeof initialView === 'string') {
                    modal.dataset.initialView = initialView;
                } else {
                    delete modal.dataset.initialView;
                }
                if (typeof presetPrompt === 'string') {
                    modal.dataset.presetPrompt = presetPrompt;
                }
                if (typeof requestId === 'string' && requestId) {
                    modal.dataset.requestId = requestId;
                } else {
                    delete modal.dataset.requestId;
                }
                if (typeof miniPrompt === 'string') {
                    modal.dataset.miniPrompt = miniPrompt;
                }

                openModal();
            };

            function populatePromptParamsFromPayload(params) {
                try {
                    if (!promptParamsSelect) return;
                    promptParamsSelect.innerHTML = '';
                    if (!params) return;
                    // 参数可能是数组 ['name','title'] 或 对象 { name: { desc, value }, title: {...} }
                    if (Array.isArray(params)) {
                        params.forEach(p => {
                            const name = typeof p === 'string' ? p : (p.name || '');
                            const desc = (typeof p === 'object' && (p.description || p.desc)) ? (p.description || p.desc) : '';
                            const val = (typeof p === 'object' && (p.value !== undefined)) ? String(p.value) : '';
                            const opt = document.createElement('option');
                            opt.value = name;
                            opt.textContent = name; // 显示参数名
                            opt.title = desc;
                            // 将描述与真实值保存在 dataset 中，便于在实际值视图读取
                            if (desc) opt.dataset.desc = desc;
                            if (val) opt.dataset.value = val;
                            promptParamsSelect.appendChild(opt);
                        });
                    } else if (typeof params === 'object') {
                        Object.entries(params).forEach(([k, v]) => {
                            const opt = document.createElement('option');
                            opt.value = k;
                            // 文本显示为参数名 k，title 显示描述（优先 description/desc），便于鼠标悬停查看
                            if (v && typeof v === 'object') {
                                opt.textContent = k;
                                opt.title = v.description || v.desc || '';
                                if (v.description || v.desc) opt.dataset.desc = v.description || v.desc || '';
                                if (v.value !== undefined) opt.dataset.value = String(v.value);
                            } else {
                                opt.textContent = k;
                                opt.title = '';
                            }
                            promptParamsSelect.appendChild(opt);
                        });
                    }
                    // 触发一次视图刷新，确保 toggle/preview 使用新参数
                    promptParamsSelect.dispatchEvent(new Event('change'));
                } catch (err) {
                    console.warn('populatePromptParamsFromPayload error', err);
                }
            }

            // 监听父页面转发的打开请求（来自 demo 父页面）
            window.addEventListener('message', (e) => {
                try {
                    console.log('收到message：', e);
                    const msg = e?.data;
                    if (!msg || typeof msg !== 'object') return;
                    // 仅处理 AI_MODAL_OPEN 指令
                    if (msg.type === 'AI_MODAL_OPEN' && msg.payload) {
                        const requestId = msg.requestId || msg.payload.requestId;
                        const { actionType, title, initialView, presetPrompt, params, miniPrompt, mode } = msg.payload;

                        console.debug('[aiModal] received AI_MODAL_OPEN', { actionType, requestId, title, initialView, params });

                        // 存储 actionType 以便后续使用
                        if (actionType) {
                            modal.dataset.actionType = actionType;
                            modal.dataset.requestId = requestId;
                        }
                        // 验证 params 是否为可用的对象或数组
                        let parsedParams = null;
                        try {
                            if (params === undefined || params === null) {
                                parsedParams = null;
                            } else if (typeof params === 'string') {
                                // 尝试解析 JSON 字符串
                                parsedParams = JSON.parse(params);
                            } else if (typeof params === 'object') {
                                parsedParams = params;
                            } else {
                                throw new Error('params 类型无效，期望 object 或 array 或 JSON 字符串');
                            }
                        } catch (err) {
                            const msgText = '[aiModal] 解析 params 失败: ' + (err && err.message ? err.message : String(err));
                            console.error(msgText, { rawParams: params });
                            // 回传错误给父窗口，便于上游定位错误
                            try {
                                window.parent?.postMessage({
                                    type: 'AI_MODAL_RESULT',

                                    requestId: requestId || null,
                                    status: 'error',
                                    detail: { message: msgText, phase: 'open', rawParams: params }
                                }, '*');
                            } catch (postErr) { console.warn('[aiModal] postMessage send error failed', postErr); }
                            return;
                        }

                        // 若解析后存在 parsedParams，但不是对象或数组，则视为无效
                        if (parsedParams !== null && typeof parsedParams !== 'object') {
                            const msgText = '[aiModal] params 解析后类型非法，应为 object 或 array';
                            console.error(msgText, { parsedParams });
                            try {
                                window.parent?.postMessage({
                                    type: 'AI_MODAL_RESULT',

                                    requestId: requestId || null,
                                    status: 'error',
                                    detail: { message: msgText, phase: 'open', rawParams: params }
                                }, '*');
                            } catch (postErr) { console.warn('[aiModal] postMessage send error failed', postErr); }
                            return;
                        }

                        // 缓存到 dataset（始终存入 JSON 字符串或删除字段）
                        try {
                            if (parsedParams) {
                                modal.dataset.presetParams = JSON.stringify(parsedParams);
                            } else {
                                delete modal.dataset.presetParams;
                            }
                        } catch (err) {
                            console.warn('[aiModal] 设置 dataset.presetParams 失败', err);
                        }

                        // 填充参数下拉（若 parsedParams 为 null 则清空）
                        try {
                            populatePromptParamsFromPayload(parsedParams || {});
                        } catch (err) {
                            console.warn('[aiModal] populatePromptParamsFromPayload 失败', err);
                        }

                        // 如果父页面传入了 templateData，则优先处理：选中模板、填充 usagePromptInput.dataset.template、并把 placeholders 的真实值放入 presetParams 以供参数下拉查看
                        try {
                            if (msg.payload && msg.payload.templateData) {
                                try {
                                    const td = msg.payload.templateData || {};
                                    // 如果 templateData 是字符串容错：支持 templateData.templateText 或 templateData.templateKey/templateId
                                    const providedTemplateText = (td.templateText && String(td.templateText).trim()) ? td.templateText : '';
                                    const providedPlaceholders = td.placeholders || {};

                                    // 将 placeholders 的值规范化为 { key: {desc, value} } 形式便于 UI 展示
                                    let presetObj = parsedParams || {};
                                    try {
                                        presetObj = presetObj || {};
                                    } catch (_) { presetObj = {}; }

                                    // 把 templateData.placeholders 的真实值注入到 presetObj（不覆盖已有描述，仅设置 value）
                                    Object.keys(providedPlaceholders || {}).forEach(function (k) {
                                        try {
                                            const v = providedPlaceholders[k];
                                            if (v && typeof v === 'object' && Object.prototype.hasOwnProperty.call(v, 'value')) {
                                                // 保留 desc（若存在）并写入 value
                                                const desc = v.desc || v.description || '';
                                                presetObj[k] = { desc: desc, value: String(v.value ?? '') };
                                            } else {
                                                // 简单值或字符串
                                                presetObj[k] = { desc: '', value: String(v ?? '') };
                                            }
                                        } catch (e) { /* noop */ }
                                    });

                                    // 把 templateData 本身也缓存到 dataset 以便后续预览/发送使用
                                    try {
                                        modal.dataset.presetTemplateData = JSON.stringify(td);
                                    } catch (_) { /* noop */ }

                                    // 如果提供了 templateText 且看起来像模板（包含 {{}}）则把它缓存为 textarea 的 template
                                    try {
                                        if (usagePromptInput) {
                                            if (providedTemplateText && providedTemplateText.indexOf('{{') >= 0) {
                                                usagePromptInput.dataset.template = providedTemplateText;
                                            } else if (td.templateKey || td.templateId) {
                                                // 若给出模板 key/id，尝试从已加载的模板列表中匹配并选中
                                                const keyCandidate = td.templateKey || td.templateId || '';
                                                if (keyCandidate) {
                                                    // 在 promptTemplates 中寻找 name 匹配项并选中
                                                    for (var ii = 0; ii < promptTemplates.length; ii++) {
                                                        if ((promptTemplates[ii].name || '') === keyCandidate) {
                                                            promptTemplateSelect.selectedIndex = ii + 1; // +1 因为第一个是默认项
                                                            // 设置 textarea 的 cached template 为该模板内容
                                                            usagePromptInput.dataset.template = promptTemplates[ii].content || '';
                                                            break;
                                                        }
                                                    }
                                                }
                                            } else if (!usagePromptInput.dataset.template || String(usagePromptInput.dataset.template).trim() === '') {
                                                // 回退到把第一个模板或空字符串缓存为 template（不覆盖用户已存在的值）
                                                const sel = promptTemplateSelect?.options[promptTemplateSelect.selectedIndex];
                                                const tplContent = sel?.dataset?.content || sel?.value || '';
                                                if (tplContent && String(tplContent).trim() !== '') {
                                                    usagePromptInput.dataset.template = tplContent;
                                                }
                                            }
                                        }
                                    } catch (err) { /* ignore */ }

                                    // 更新 presetParams（合并并写回 dataset）
                                    try {
                                        modal.dataset.presetParams = JSON.stringify(presetObj);
                                    } catch (err) { /* ignore */ }

                                    // 重新填充参数下拉并保持当前选项（优先展示传入的占位符）
                                    try {
                                        populatePromptParamsFromPayload(presetObj || {});
                                    } catch (err) {
                                        console.warn('[aiModal] populatePromptParamsFromPayload after templateData failed', err);
                                    }
                                } catch (err) {
                                    console.warn('[aiModal] process payload.templateData failed', err);
                                }
                            }
                        } catch (err) {
                            console.warn('[aiModal] handle templateData on open failed', err);
                        }

                        // silent 模式：强制 mini 模式并打标
                        if (mode === 'silent') {
                            modal.dataset.silentMode = '1';
                            // 强制 initialView 为 mini
                            msg.payload.initialView = 'mini';
                        }
                        try {
                            window.openAIServiceModal({ title, initialView, presetPrompt, requestId, miniPrompt });

                            // silent 模式：打开后立即自动发送
                            if (mode === 'silent') {
                                // 等一小段事件队列，确保 UI 切到 mini
                                setTimeout(() => {
                                    const miniSendBtn = document.getElementById('miniSendBtn');
                                    if (miniSendBtn) miniSendBtn.click();
                                    else {
                                        // 降级：点主发送按钮
                                        const usageSubmitBtn = document.getElementById('usageSubmitBtn');
                                        if (usageSubmitBtn) usageSubmitBtn.click();
                                    }
                                }, 0);
                            }

                            // 如果父 payload 指定要自动运行（兼容 headless 或 autoRun），仅在明确标记时触发
                            try {
                                const shouldAutoRun = !!(msg.payload && msg.payload.mode === 'silent');
                                if (shouldAutoRun) {
                                    // 若 autoRun 或 silent，则触发一次预览或发送（dryRun:false 表示真正发送）
                                    // 但为了安全，优先触发组件内的 runAIHeadless（若 mode==='silent'）或直接点击发送按钮（模拟用户交互）
                                    if (msg.payload.mode === 'silent') {
                                        // headless path: instruct parent to run headless via runAIHeadless inside iframe
                                        // 这里不自动调用 usageSubmitBtn.click()，而是触发组件内的 headless path if available
                                        try {
                                            // runAIHeadless 路径将由父页面的 headless 请求走，不在 modal 中自动执行
                                        } catch (_) { /* noop */ }
                                    } else {
                                        // 若 autoRun 且 modal 打开，则模拟用户点击发送（谨慎）
                                        try {
                                            // 将 textarea 的 current resolved 文本更新到视图再触发发送
                                            try { applyView(); } catch (_) { /* noop */ }
                                            if (usageSubmitBtn) {
                                                usageSubmitBtn.click();
                                            }
                                        } catch (err) { console.warn('[aiModal] autoRun send failed', err); }
                                    }
                                }
                            } catch (arErr) { /* noop */ }

                            // 额外容错：打开后确保有可用于解析的模板缓存（usagePromptInput.dataset.template）
                            try {
                                if (usagePromptInput) {
                                    // 优先使用当前 textarea 值，其次使用选中模板的内容，再回退到空字符串
                                    const cur = usagePromptInput.value && String(usagePromptInput.value).trim();
                                    if (!usagePromptInput.dataset.template || String(usagePromptInput.dataset.template).trim() === '') {
                                        if (cur && cur.length > 0) {
                                            usagePromptInput.dataset.template = usagePromptInput.value;
                                            console.debug('[aiModal] cached template from textarea');
                                        } else {
                                            // 尝试从模板下拉获取内容
                                            const sel = promptTemplateSelect?.options[promptTemplateSelect.selectedIndex];
                                            const tplContent = sel?.dataset?.content || sel?.value || '';
                                            if (tplContent && String(tplContent).trim() !== '') {
                                                usagePromptInput.dataset.template = tplContent;
                                                console.debug('[aiModal] cached template from promptTemplateSelect');
                                            } else {
                                                // 最后回退为空字符串，保持不覆盖已有 dataset.template
                                                console.debug('[aiModal] no template to cache on open');
                                            }
                                        }
                                    }
                                }
                            } catch (cacheErr) {
                                console.warn('[aiModal] cache template after open failed', cacheErr);
                            }
                        } catch (err) {
                            console.error('[aiModal] openAIServiceModal 调用失败', err);
                            try {
                                window.parent?.postMessage({
                                    type: 'AI_MODAL_RESULT',

                                    requestId: requestId || null,
                                    status: 'error',
                                    detail: { message: '[aiModal] open fail: ' + (err.message || String(err)), phase: 'open' }
                                }, '*');
                            } catch (_) { /* noop */ }
                        }
                    }
                } catch (err) {
                    console.error('[aiModal] message handler unexpected error', err);
                }
            }, false);



            // 迷你模式功能
            let isMiniMode = false;

            // 切换迷你模式
            function toggleMiniMode() {
                isMiniMode = !isMiniMode;
                const modal = document.getElementById('aiServiceModal');
                const miniView = document.getElementById('aiMiniView');
                const usageView = document.getElementById('aiUsageView');
                const configView = document.getElementById('aiConfigView');
                const templateConfigView = document.getElementById('templateConfigView');
                const minimizeButton = document.getElementById('minimizeButton');

                console.log('[toggleMiniMode] 切换模式，当前isMiniMode:', isMiniMode);

                if (isMiniMode) {
                    // 切换到迷你模式
                    modal.classList.add('mini-mode');
                    miniView.classList.remove('hidden');
                    usageView.classList.add('hidden');
                    configView.classList.add('hidden');
                    templateConfigView.classList.add('hidden');

                    // 更新按钮图标为最大化
                    if (minimizeButton) {
                        minimizeButton.innerHTML = '<i class="fa fa-expand"></i>';
                        minimizeButton.title = '最大化';
                    }

                    // 同步当前配置到迷你模式
                    console.log('[toggleMiniMode] 切换到迷你模式，调用syncToMiniMode');
                    syncToMiniMode();
                } else {
                    // 切换到正常模式
                    modal.classList.remove('mini-mode');
                    miniView.classList.add('hidden');
                    usageView.classList.remove('hidden');

                    // 更新按钮图标为最小化
                    if (minimizeButton) {
                        minimizeButton.innerHTML = '<i class="fa fa-compress"></i>';
                        minimizeButton.title = '最小化';
                    }

                    // 同步迷你模式的输入到完整模式
                    console.log('[toggleMiniMode] 切换到完整模式，调用syncFromMiniMode');
                    syncFromMiniMode();
                }
            }

            // 同步配置到迷你模式
            function syncToMiniMode() {
                const userPromptInput = document.getElementById('userPromptInput');
                const miniUserPromptInput = document.getElementById('miniUserPromptInput');
                const userTemplateSearchInput = document.getElementById('userTemplateSearchInput');
                const miniUserTemplateSearchInput = document.getElementById('miniUserTemplateSearchInput');

                if (userPromptInput && miniUserPromptInput) {
                    miniUserPromptInput.value = userPromptInput.value;
                    // 同步占位符
                    if (userPromptInput.placeholder) {
                        miniUserPromptInput.placeholder = userPromptInput.placeholder;
                    }
                }

                // 同步模板选择
                if (userTemplateSearchInput && miniUserTemplateSearchInput) {
                    miniUserTemplateSearchInput.value = userTemplateSearchInput.value;
                }

                // 更新迷你模式模板标签显示
                updateMiniTemplateTags();
            }

            // 同步迷你模式到完整模式
            function syncFromMiniMode() {
                const userPromptInput = document.getElementById('userPromptInput');
                const miniUserPromptInput = document.getElementById('miniUserPromptInput');
                const userTemplateSearchInput = document.getElementById('userTemplateSearchInput');
                const miniUserTemplateSearchInput = document.getElementById('miniUserTemplateSearchInput');

                console.log('[syncFromMiniMode] 元素检查:');
                console.log('- userPromptInput:', userPromptInput ? '存在' : '不存在');
                console.log('- miniUserPromptInput:', miniUserPromptInput ? '存在' : '不存在');
                console.log('- userTemplateSearchInput:', userTemplateSearchInput ? '存在' : '不存在');
                console.log('- miniUserTemplateSearchInput:', miniUserTemplateSearchInput ? '存在' : '不存在');

                if (userPromptInput && miniUserPromptInput) {
                    console.log('[syncFromMiniMode] 开始同步，miniUserPromptInput值:', miniUserPromptInput.value);
                    console.log('[syncFromMiniMode] 当前userPromptInput值:', userPromptInput.value);
                    userPromptInput.value = miniUserPromptInput.value;
                    console.log('[syncFromMiniMode] 已同步输入框值:', miniUserPromptInput.value);
                    // 同步占位符
                    if (miniUserPromptInput.placeholder) {
                        userPromptInput.placeholder = miniUserPromptInput.placeholder;
                    }
                } else {
                    console.log('[syncFromMiniMode] 元素不存在，无法同步输入框');
                }

                // 同步模板选择
                if (userTemplateSearchInput && miniUserTemplateSearchInput) {
                    userTemplateSearchInput.value = miniUserTemplateSearchInput.value;
                    console.log('[syncFromMiniMode] 已同步模板搜索值:', miniUserTemplateSearchInput.value);
                } else {
                    console.log('[syncFromMiniMode] 模板搜索元素不存在，无法同步');
                }
            }

            // 迷你模式发送请求
            async function sendMiniRequest() {
                const miniUserPromptInput = document.getElementById('miniUserPromptInput');
                const miniStatus = document.getElementById('miniStatus');
                const miniExpandBtn = document.getElementById('miniExpandBtn');

                // 迷你模式下允许空提示词发送
                if (!miniUserPromptInput) {
                    return;
                }

                // 同步输入到用户提示词输入框
                const userPromptInput = document.getElementById('userPromptInput');
                const userTemplateSearchInput = document.getElementById('userTemplateSearchInput');
                const miniUserTemplateSearchInput = document.getElementById('miniUserTemplateSearchInput');

                if (userPromptInput) {
                    userPromptInput.value = miniUserPromptInput.value;
                    // 同步占位符
                    if (miniUserPromptInput.placeholder) {
                        userPromptInput.placeholder = miniUserPromptInput.placeholder;
                    }
                }

                // 同步模板选择
                if (userTemplateSearchInput && miniUserTemplateSearchInput) {
                    userTemplateSearchInput.value = miniUserTemplateSearchInput.value;
                }

                // 使用现有的AI请求逻辑
                try {
                    // 显示加载状态 - 添加旋转动画
                    if (miniExpandBtn) {
                        miniExpandBtn.disabled = true;
                        miniExpandBtn.innerHTML = '<i class="fa fa-spinner fa-spin mr-1"></i>';
                        miniExpandBtn.classList.add('loading');
                    }

                    if (miniStatus) {
                        miniStatus.textContent = '正在发送请求...';
                        miniStatus.className = 'text-xs text-blue-600';
                    }

                    // 调用现有的发送函数

                    await sendAIRequest();


                    if (miniStatus) {
                        miniStatus.textContent = '请求已发送';
                        miniStatus.className = 'text-xs text-green-600';
                    }
                } catch (error) {
                    if (miniStatus) {
                        miniStatus.textContent = '发送失败: ' + error.message;
                        miniStatus.className = 'text-xs text-red-600';
                    }
                } finally {
                    // 恢复按钮状态
                    if (miniExpandBtn) {
                        miniExpandBtn.disabled = false;
                        miniExpandBtn.innerHTML = '<i class="fa fa-paper-plane"></i>';
                        miniExpandBtn.classList.remove('loading');
                    }
                }
            }

            // 绑定迷你模式事件
            document.addEventListener('DOMContentLoaded', function () {
                const minimizeButton = document.getElementById('minimizeButton');
                const miniExpandBtn = document.getElementById('miniExpandBtn');
                const miniUserPromptInput = document.getElementById('miniUserPromptInput');
                const expandButton = document.getElementById('expandButton');
                const closeMiniModalBtn = document.getElementById('closeMiniModalBtn');

                if (minimizeButton) {
                    minimizeButton.addEventListener('click', toggleMiniMode);
                    // 添加触摸事件支持，确保移动端响应
                    minimizeButton.addEventListener('touchstart', function (e) {
                        e.stopPropagation(); // 防止事件冒泡到拖拽层
                    }, { passive: true });
                    minimizeButton.addEventListener('touchend', function (e) {
                        e.preventDefault(); // 防止鼠标事件重复触发
                        toggleMiniMode();
                    }, { passive: false });
                }

                if (expandButton) {
                    expandButton.addEventListener('click', toggleMiniMode);
                    // 添加触摸事件支持
                    expandButton.addEventListener('touchstart', function (e) {
                        e.stopPropagation();
                    }, { passive: true });
                    expandButton.addEventListener('touchend', function (e) {
                        e.preventDefault();
                        toggleMiniMode();
                    }, { passive: false });
                }

                if (closeMiniModalBtn) {
                    closeMiniModalBtn.addEventListener('click', closeModal);
                    // 添加触摸事件支持
                    closeMiniModalBtn.addEventListener('touchstart', function (e) {
                        e.stopPropagation();
                    }, { passive: true });
                    closeMiniModalBtn.addEventListener('touchend', function (e) {
                        e.preventDefault();
                        closeModal();
                    }, { passive: false });
                }

                if (miniExpandBtn) {
                    miniExpandBtn.addEventListener('click', sendMiniRequest);
                }

                if (miniUserPromptInput) {
                    miniUserPromptInput.addEventListener('keypress', function (e) {
                        if (e.key === 'Enter' && !e.ctrlKey && !e.shiftKey) {
                            e.preventDefault();
                            sendMiniRequest();
                        }
                    });
                }

                // 绑定迷你模式模板相关事件
                bindMiniTemplateEvents();

                // 用户提示词模板功能初始化
                initializeUserTemplates();
            });

            // 用户提示词模板管理功能
            const USER_TEMPLATES_KEY = 'myPromptTemplates';
            const USER_TEMPLATES_FILE = 'user-templates.json';

            // 初始化用户模板功能
            async function initializeUserTemplates() {
                try {
                    // 加载用户模板数据
                    await loadUserTemplates();

                    // 绑定用户模板相关事件
                    bindUserTemplateEvents();

                    // 初始化迷你模式模板标签显示
                    updateMiniTemplateTags();

                    console.log('[UserTemplates] 用户模板功能初始化完成');
                } catch (error) {
                    console.error('[UserTemplates] 初始化失败:', error);
                }
            }

            // 用户模板搜索相关功能
            let userTemplateSearchTimeout = null;
            let allUserTemplates = [];
            let selectedTemplateId = '';

            // 模糊搜索函数
            function fuzzySearch(query, items, keys = ['name', 'description']) {
                if (!query.trim()) return items;

                const lowerQuery = query.toLowerCase();
                return items.filter(item => {
                    return keys.some(key => {
                        const value = item[key] || '';
                        return value.toLowerCase().includes(lowerQuery);
                    });
                });
            }

            // 更新搜索下拉框
            function updateTemplateDropdown(filteredTemplates = null) {
                const dropdown = document.getElementById('userTemplateDropdown');
                const searchInput = document.getElementById('userTemplateSearchInput');

                if (!dropdown || !searchInput) return;

                const templates = filteredTemplates || allUserTemplates;
                const searchTerm = searchInput.value.toLowerCase();

                dropdown.innerHTML = '';

                if (templates.length === 0 && searchTerm) {
                    const noResults = document.createElement('div');
                    noResults.className = 'template-dropdown-item no-results';
                    noResults.textContent = '没有找到匹配的模板';
                    dropdown.appendChild(noResults);
                } else {
                    templates.forEach(template => {
                        const item = document.createElement('div');
                        item.className = 'template-dropdown-item';
                        if (template.id === selectedTemplateId) {
                            item.classList.add('selected');
                        }
                        if (template.type === 'custom') {
                            item.classList.add('custom-option');
                        }

                        item.textContent = template.name;
                        item.title = template.description || template.name;
                        item.dataset.templateId = template.id;
                        item.dataset.content = template.content;

                        item.addEventListener('click', () => {
                            selectTemplate(template);
                        });

                        dropdown.appendChild(item);
                    });
                }

                // 显示下拉框
                dropdown.classList.remove('hidden');
            }

            // 更新迷你模式搜索下拉框
            function updateMiniTemplateDropdown(filteredTemplates = null) {
                const dropdown = document.getElementById('miniUserTemplateDropdown');
                const searchInput = document.getElementById('miniUserTemplateSearchInput');

                if (!dropdown || !searchInput) return;

                const templates = filteredTemplates || allUserTemplates;
                const searchTerm = searchInput.value.toLowerCase();

                dropdown.innerHTML = '';

                if (templates.length === 0 && searchTerm) {
                    const noResults = document.createElement('div');
                    noResults.className = 'template-dropdown-item no-results';
                    noResults.textContent = '没有找到匹配的模板';
                    dropdown.appendChild(noResults);
                } else {
                    templates.forEach(template => {
                        const item = document.createElement('div');
                        item.className = 'template-dropdown-item';
                        if (template.id === selectedTemplateId) {
                            item.classList.add('selected');
                        }
                        if (template.type === 'custom') {
                            item.classList.add('custom-option');
                        }

                        item.textContent = template.name;
                        item.title = template.description || template.name;
                        item.dataset.templateId = template.id;
                        item.dataset.content = template.content;

                        item.addEventListener('click', () => {
                            selectMiniTemplate(template);
                        });

                        dropdown.appendChild(item);
                    });
                }

                // 计算下拉框位置
                const searchInputRect = searchInput.getBoundingClientRect();
                dropdown.style.position = 'fixed';
                dropdown.style.top = (searchInputRect.bottom + 4) + 'px';
                dropdown.style.left = searchInputRect.left + 'px';
                dropdown.style.width = searchInputRect.width + 'px';
                dropdown.style.maxHeight = '200px';
                dropdown.style.zIndex = '9999';

                // 显示下拉框
                dropdown.classList.remove('hidden');
            }

            // 更新迷你模式模板标签显示
            function updateMiniTemplateTags(filteredTemplates = null) {
                const tagsContainer = document.getElementById('miniTemplateTags');
                if (!tagsContainer) return;

                const templates = filteredTemplates || allUserTemplates;
                tagsContainer.innerHTML = '';

                // 首先添加自定义标签（如果没有选中任何模板，则选中自定义）
                const customTag = document.createElement('span');
                customTag.className = 'mini-template-tag';
                if (!selectedTemplateId) {
                    customTag.classList.add('selected');
                }
                customTag.textContent = '自定义';
                customTag.title = '当前为自定义内容';
                customTag.addEventListener('click', () => {
                    // 切换到自定义状态
                    selectedTemplateId = '';
                    localStorage.setItem('selectedUserTemplateId', '');
                    localStorage.setItem('selectedUserTemplateName', '自定义');
                    updateMiniTemplateTags();
                });
                tagsContainer.appendChild(customTag);

                if (templates.length === 0) {
                    return;
                }

                // 只显示前9个模板，避免过多标签
                const displayTemplates = templates.slice(0, 9);

                displayTemplates.forEach(template => {
                    const tag = document.createElement('span');
                    tag.className = 'mini-template-tag';

                    if (template.id === selectedTemplateId) {
                        tag.classList.add('selected');
                    }
                    if (template.type === 'custom') {
                        tag.classList.add('custom');
                    }

                    tag.textContent = template.name;
                    tag.title = template.description || template.name;
                    tag.dataset.templateId = template.id;
                    tag.dataset.content = template.content;

                    tag.addEventListener('click', () => {
                        selectMiniTemplateTag(template);
                    });

                    tagsContainer.appendChild(tag);
                });

                // 如果还有更多模板，显示"+N更多"按钮
                if (templates.length > 9) {
                    const moreIndicator = document.createElement('span');
                    moreIndicator.className = 'mini-template-more';
                    moreIndicator.textContent = `+${templates.length - 9}更多`;
                    moreIndicator.title = '点击展开完整模式查看更多模板';

                    // 点击"+N更多"按钮时，触发expandButton的点击事件，进入完整模式
                    moreIndicator.addEventListener('click', () => {
                        const expandButton = document.getElementById('expandButton');
                        if (expandButton) {
                            expandButton.click();
                        }
                    });

                    tagsContainer.appendChild(moreIndicator);
                }
            }

            // 选择迷你模式模板标签
            function selectMiniTemplateTag(template) {
                const userPromptInput = document.getElementById('miniUserPromptInput');
                if (!userPromptInput) return;

                // 使用handleTemplateSwitch处理模板切换（包含二次确认逻辑）
                const switchResult = handleTemplateSwitch(template.id);

                if (switchResult) {
                    // 只有在用户确认切换后才更新UI
                    userPromptInput.value = template.content;
                    selectedTemplateId = template.id;

                    // 更新标签选中状态
                    updateMiniTemplateTags();

                    console.log('[UserTemplates] 迷你模式选择模板标签:', template.name);
                } else {
                    // 用户取消了切换，保持当前状态
                    console.log('[UserTemplates] 迷你模式用户取消了模板选择');
                }
            }

            // 选择模板
            function selectTemplate(template) {
                const searchInput = document.getElementById('userTemplateSearchInput');
                const dropdown = document.getElementById('userTemplateDropdown');
                const userPromptInput = document.getElementById('userPromptInput');

                if (!searchInput || !dropdown) return;

                // 使用handleTemplateSwitch处理模板切换（包含二次确认逻辑）
                const switchResult = handleTemplateSwitch(template.id);

                if (switchResult) {
                    // 只有在用户确认切换后才更新UI
                    searchInput.value = template.name;
                    if (userPromptInput) {
                        userPromptInput.value = template.content;
                    }
                    selectedTemplateId = template.id;

                    // 隐藏下拉框
                    dropdown.classList.add('hidden');

                    console.log('[UserTemplates] 选择模板:', template.name);
                } else {
                    // 用户取消了切换，保持当前状态
                    console.log('[UserTemplates] 用户取消了模板选择');
                }
            }

            // 选择迷你模式模板
            function selectMiniTemplate(template) {
                const searchInput = document.getElementById('miniUserTemplateSearchInput');
                const dropdown = document.getElementById('miniUserTemplateDropdown');
                const userPromptInput = document.getElementById('miniUserPromptInput');

                if (!searchInput || !dropdown || !userPromptInput) return;

                // 使用handleTemplateSwitch处理模板切换（包含二次确认逻辑）
                const switchResult = handleTemplateSwitch(template.id);

                if (switchResult) {
                    // 只有在用户确认切换后才更新UI
                    searchInput.value = template.name;
                    userPromptInput.value = template.content;
                    selectedTemplateId = template.id;

                    // 隐藏下拉框
                    dropdown.classList.add('hidden');

                    console.log('[UserTemplates] 迷你模式选择模板:', template.name);
                } else {
                    // 用户取消了切换，保持当前状态
                    console.log('[UserTemplates] 迷你模式用户取消了模板选择');
                }
            }

            // 处理模板切换（保留原有的二次确认逻辑）
            function handleTemplateSwitch(template) {
                // 这里会调用原有的模板切换逻辑
                // 我们需要模拟原有的select元素的change事件
                const fakeSelect = {
                    value: template.id,
                    options: [{
                        dataset: {
                            content: template.content
                        },
                        textContent: template.name
                    }],
                    selectedIndex: 0
                };

                // 调用原有的onUserTemplateSelectChange逻辑
                handleUserTemplateChange(fakeSelect);

                // 假设用户确认了切换（原有逻辑应该处理了确认对话框）
                return true;
            }

            // 搜索输入事件处理
            function handleTemplateSearchInput() {
                const searchInput = document.getElementById('userTemplateSearchInput');
                const dropdown = document.getElementById('userTemplateDropdown');

                if (!searchInput || !dropdown) return;

                clearTimeout(userTemplateSearchTimeout);

                userTemplateSearchTimeout = setTimeout(() => {
                    const searchTerm = searchInput.value.trim();

                    if (searchTerm === '') {
                        // 如果搜索框为空，显示所有模板
                        updateTemplateDropdown(allUserTemplates);
                    } else {
                        // 执行模糊搜索
                        const filteredTemplates = fuzzySearch(searchTerm, allUserTemplates);
                        updateTemplateDropdown(filteredTemplates);
                    }
                }, 300); // 300ms防抖
            }

            // 迷你模式搜索输入事件处理
            function handleMiniTemplateSearchInput() {
                const searchInput = document.getElementById('miniUserTemplateSearchInput');
                const dropdown = document.getElementById('miniUserTemplateDropdown');

                if (!searchInput || !dropdown) return;

                clearTimeout(userTemplateSearchTimeout);

                userTemplateSearchTimeout = setTimeout(() => {
                    const searchTerm = searchInput.value.trim();

                    if (searchTerm === '') {
                        // 如果搜索框为空，显示所有模板
                        updateMiniTemplateDropdown(allUserTemplates);
                    } else {
                        // 执行模糊搜索
                        const filteredTemplates = fuzzySearch(searchTerm, allUserTemplates);
                        updateMiniTemplateDropdown(filteredTemplates);
                    }
                }, 300); // 300ms防抖
            }

            // 绑定搜索相关事件
            function bindTemplateSearchEvents() {
                const searchInput = document.getElementById('userTemplateSearchInput');
                const dropdown = document.getElementById('userTemplateDropdown');

                if (!searchInput || !dropdown) return;

                // 搜索输入事件
                searchInput.addEventListener('input', handleTemplateSearchInput);

                // 搜索框聚焦事件
                searchInput.addEventListener('focus', () => {
                    if (typeof allUserTemplates !== 'undefined' && allUserTemplates.length > 0) {
                        updateTemplateDropdown(allUserTemplates);
                    }
                });

                // 点击外部关闭下拉框
                document.addEventListener('click', (e) => {
                    if (!searchInput.contains(e.target) && !dropdown.contains(e.target)) {
                        dropdown.classList.add('hidden');
                    }
                });

                // 键盘导航
                searchInput.addEventListener('keydown', (e) => {
                    const items = dropdown.querySelectorAll('.template-dropdown-item:not(.no-results)');
                    const currentIndex = Array.from(items).findIndex(item => item.classList.contains('selected'));

                    if (e.key === 'ArrowDown') {
                        e.preventDefault();
                        const nextIndex = currentIndex < items.length - 1 ? currentIndex + 1 : 0;
                        if (items[nextIndex]) {
                            items.forEach(item => item.classList.remove('selected'));
                            items[nextIndex].classList.add('selected');
                            items[nextIndex].scrollIntoView({ block: 'nearest' });
                        }
                    } else if (e.key === 'ArrowUp') {
                        e.preventDefault();
                        const prevIndex = currentIndex > 0 ? currentIndex - 1 : items.length - 1;
                        if (items[prevIndex]) {
                            items.forEach(item => item.classList.remove('selected'));
                            items[prevIndex].classList.add('selected');
                            items[prevIndex].scrollIntoView({ block: 'nearest' });
                        }
                    } else if (e.key === 'Enter') {
                        e.preventDefault();
                        const selectedItem = dropdown.querySelector('.template-dropdown-item.selected');
                        if (selectedItem && !selectedItem.classList.contains('no-results')) {
                            selectedItem.click();
                        }
                    } else if (e.key === 'Escape') {
                        dropdown.classList.add('hidden');
                    }
                });
            }

            // 绑定迷你模式搜索相关事件
            function bindMiniTemplateSearchEvents() {
                const searchInput = document.getElementById('miniUserTemplateSearchInput');
                const dropdown = document.getElementById('miniUserTemplateDropdown');

                if (!searchInput || !dropdown) return;

                // 搜索输入事件
                searchInput.addEventListener('input', handleMiniTemplateSearchInput);

                // 搜索框聚焦事件
                searchInput.addEventListener('focus', () => {
                    if (typeof allUserTemplates !== 'undefined' && allUserTemplates.length > 0) {
                        updateMiniTemplateDropdown(allUserTemplates);
                    }
                });

                // 点击外部关闭下拉框
                document.addEventListener('click', (e) => {
                    if (!searchInput.contains(e.target) && !dropdown.contains(e.target)) {
                        dropdown.classList.add('hidden');
                    }
                });

                // 键盘导航
                searchInput.addEventListener('keydown', (e) => {
                    const items = dropdown.querySelectorAll('.template-dropdown-item:not(.no-results)');
                    const currentIndex = Array.from(items).findIndex(item => item.classList.contains('selected'));

                    if (e.key === 'ArrowDown') {
                        e.preventDefault();
                        const nextIndex = currentIndex < items.length - 1 ? currentIndex + 1 : 0;
                        if (items[nextIndex]) {
                            items.forEach(item => item.classList.remove('selected'));
                            items[nextIndex].classList.add('selected');
                            items[nextIndex].scrollIntoView({ block: 'nearest' });
                        }
                    } else if (e.key === 'ArrowUp') {
                        e.preventDefault();
                        const prevIndex = currentIndex > 0 ? currentIndex - 1 : items.length - 1;
                        if (items[prevIndex]) {
                            items.forEach(item => item.classList.remove('selected'));
                            items[prevIndex].classList.add('selected');
                            items[prevIndex].scrollIntoView({ block: 'nearest' });
                        }
                    } else if (e.key === 'Enter') {
                        e.preventDefault();
                        const selectedItem = dropdown.querySelector('.template-dropdown-item.selected');
                        if (selectedItem && !selectedItem.classList.contains('no-results')) {
                            selectedItem.click();
                        }
                    } else if (e.key === 'Escape') {
                        dropdown.classList.add('hidden');
                    }
                });
            }

            // 加载用户模板数据
            async function loadUserTemplates() {
                try {
                    // 1. 从user-templates.json加载内置模板
                    const response = await fetch(USER_TEMPLATES_FILE);
                    const builtInTemplates = response.ok ? await response.json() : [];

                    // 2. 从localStorage加载用户自定义模板
                    const userTemplates = JSON.parse(localStorage.getItem(USER_TEMPLATES_KEY) || '[]');

                    // 3. 如果是首次使用（没有用户模板），自动导入所有内置模板
                    if (userTemplates.length === 0 && builtInTemplates.length > 0) {
                        console.log('[UserTemplates] 首次使用，自动导入内置模板');
                        const userBuiltInTemplates = builtInTemplates.map(template => ({
                            ...template,
                            id: 'user_' + template.id,
                            type: template.type
                        }));

                        // 保存到localStorage
                        localStorage.setItem(USER_TEMPLATES_KEY, JSON.stringify(userBuiltInTemplates));

                        // 更新用户模板列表
                        const allTemplates = userBuiltInTemplates;
                        updateUserTemplateSelect(allTemplates);

                        // 自动选择默认模板（如果没有上次使用的模板，则选择第一个）
                        autoSelectDefaultTemplate(allTemplates);

                        console.log('[UserTemplates] 自动导入完成，共', allTemplates.length, '个模板');
                    } else {
                        // 正常情况：直接显示用户模板
                        const allTemplates = [...userTemplates];
                        updateUserTemplateSelect(allTemplates);

                        // 自动选择默认模板（如果没有上次使用的模板，则选择第一个）
                        autoSelectDefaultTemplate(allTemplates);

                        console.log('[UserTemplates] 模板加载完成，共', allTemplates.length, '个模板');
                    }
                } catch (error) {
                    console.error('[UserTemplates] 加载模板失败:', error);
                    // 回退到空模板列表
                    updateUserTemplateSelect([]);
                }
            }

            // 更新用户模板下拉框（适配新的搜索系统）
            function updateUserTemplateSelect(templates) {
                const searchInput = document.getElementById('userTemplateSearchInput');
                const dropdown = document.getElementById('userTemplateDropdown');

                if (!searchInput || !dropdown) return;

                // 获取模板使用时间记录
                const templateUsageTimes = {};
                try {
                    const usageData = localStorage.getItem('userTemplateUsageTimes');
                    if (usageData) {
                        Object.assign(templateUsageTimes, JSON.parse(usageData));
                    }
                } catch (e) {
                    console.warn('[UserTemplates] 读取模板使用时间记录失败:', e);
                }

                // 按最近使用时间降序排序
                const sortedTemplates = [...templates].sort((a, b) => {
                    const timeA = templateUsageTimes[a.id] || 0;
                    const timeB = templateUsageTimes[b.id] || 0;
                    return timeB - timeA; // 降序排序
                });

                // 保存排序后的模板到搜索系统
                allUserTemplates = sortedTemplates;

                // 更新搜索框占位符
                searchInput.placeholder = '搜索用户提示词模板...';

                console.log('[UserTemplates] 用户模板搜索系统已更新，按最近使用时间排序');
            }

            // 自动选择默认模板（适配新的搜索系统）
            function autoSelectDefaultTemplate(templates) {
                const searchInput = document.getElementById('userTemplateSearchInput');
                const userPromptInput = document.getElementById('userPromptInput');
                const miniSearchInput = document.getElementById('miniUserTemplateSearchInput');
                const miniUserPromptInput = document.getElementById('miniUserPromptInput');

                // 延迟执行，确保DOM元素已加载
                setTimeout(() => {
                    // 获取上一次使用的模板ID
                    const lastUsedTemplateId = localStorage.getItem('lastUsedUserTemplateId');

                    let selectedTemplate = null;

                    // 如果存在上一次使用的模板，优先选择
                    if (lastUsedTemplateId) {
                        selectedTemplate = templates.find(t => t.id === lastUsedTemplateId);
                    }

                    // 如果没有上一次使用的模板，选择第一个模板
                    if (!selectedTemplate && templates.length > 0) {
                        selectedTemplate = templates[0];
                    }

                    // 处理完整模式
                    if (searchInput && userPromptInput) {
                        // 应用选中的模板
                        if (selectedTemplate) {
                            searchInput.value = selectedTemplate.name;
                            selectedTemplateId = selectedTemplate.id;
                            userPromptInput.value = selectedTemplate.content;
                            console.log('[UserTemplates] 完整模式自动选择模板:', selectedTemplate.name);
                        } else {
                            // 没有模板可用，显示自定义
                            searchInput.value = '';
                            selectedTemplateId = '';
                            console.log('[UserTemplates] 完整模式没有可用模板，显示自定义');
                        }
                    }

                    // 处理迷你模式
                    if (miniSearchInput && miniUserPromptInput) {
                        // 应用选中的模板
                        if (selectedTemplate) {
                            miniSearchInput.value = selectedTemplate.name;
                            selectedTemplateId = selectedTemplate.id;
                            miniUserPromptInput.value = selectedTemplate.content;
                            console.log('[UserTemplates] 迷你模式自动选择模板:', selectedTemplate.name);
                        } else {
                            // 没有模板可用，显示自定义
                            miniSearchInput.value = '';
                            selectedTemplateId = '';
                            console.log('[UserTemplates] 迷你模式没有可用模板，显示自定义');
                        }

                        // 更新迷你模式模板标签显示
                        updateMiniTemplateTags();
                    }
                }, 100);
            }

            // 绑定用户模板相关事件
            function bindUserTemplateEvents() {
                // 管理按钮点击事件
                const manageBtn = document.getElementById('userTemplateManageBtn');
                if (manageBtn) {
                    manageBtn.addEventListener('click', openUserTemplateManager);
                }

                // 绑定新的搜索系统事件
                bindTemplateSearchEvents();

                // 用户提示词输入框内容变化事件
                const userPromptInput = document.getElementById('userPromptInput');
                if (userPromptInput) {
                    // 监听输入事件
                    userPromptInput.addEventListener('input', onUserPromptInputChange);
                    // 监听change事件（失焦时触发）
                    userPromptInput.addEventListener('change', onUserPromptInputChange);
                }
            }

            // 绑定迷你模式模板相关事件
            function bindMiniTemplateEvents() {
                // 迷你模式管理按钮点击事件
                const miniManageBtn = document.getElementById('miniUserTemplateManageBtn');
                if (miniManageBtn) {
                    miniManageBtn.addEventListener('click', openUserTemplateManager);
                }

                // 绑定迷你模式搜索系统事件
                bindMiniTemplateSearchEvents();

                // 迷你模式输入框内容变化事件
                const miniUserPromptInput = document.getElementById('miniUserPromptInput');
                if (miniUserPromptInput) {
                    // 监听输入事件
                    miniUserPromptInput.addEventListener('input', onMiniUserPromptInputChange);
                    // 监听change事件（失焦时触发）
                    miniUserPromptInput.addEventListener('change', onMiniUserPromptInputChange);
                    // 监听回车事件
                    miniUserPromptInput.addEventListener('keypress', function (e) {
                        if (e.key === 'Enter' && !e.ctrlKey && !e.shiftKey) {
                            e.preventDefault();
                            sendMiniRequest();
                        }
                    });
                }

                // 迷你模式发送按钮事件
                const miniSendBtn = document.getElementById('miniSendBtn');
                if (miniSendBtn) {
                    miniSendBtn.addEventListener('click', sendMiniRequest);
                }
            }

            // 用户提示词输入框内容变化事件处理
            function onUserPromptInputChange() {
                try {
                    const userPromptInput = document.getElementById('userPromptInput');
                    const searchInput = document.getElementById('userTemplateSearchInput');

                    if (!userPromptInput || !searchInput) {
                        console.warn('[UserTemplates] 找不到必要的DOM元素');
                        return;
                    }

                    const currentContent = userPromptInput.value.trim();

                    // 如果当前选择的是"自定义"选项，不需要处理
                    if (!selectedTemplateId) {
                        return;
                    }

                    // 获取当前选中模板的原始内容
                    const selectedTemplate = allUserTemplates.find(t => t.id === selectedTemplateId);
                    if (!selectedTemplate) {
                        console.warn('[UserTemplates] 找不到选中的模板:', selectedTemplateId);
                        return;
                    }

                    const originalTemplateContent = selectedTemplate.content;

                    // 如果用户修改了内容，且与原始模板内容不同，则自动切换到"自定义"
                    if (currentContent && originalTemplateContent && currentContent !== originalTemplateContent) {
                        selectedTemplateId = '';
                        searchInput.value = '自定义';
                        // 同时更新localStorage，标记当前为自定义状态
                        localStorage.setItem('lastUsedUserTemplateId', 'custom');
                        console.log('[UserTemplates] 用户修改了提示词，自动切换到自定义模板');

                        // 触发搜索输入框的change事件，更新UI
                        const changeEvent = new Event('change', { bubbles: true });
                        searchInput.dispatchEvent(changeEvent);
                    }
                } catch (error) {
                    console.error('[UserTemplates] onUserPromptInputChange执行失败:', error);
                }
            }

            // 迷你模式：处理用户提示词输入变化
            function onMiniUserPromptInputChange() {
                try {
                    const miniUserPromptInput = document.getElementById('miniUserPromptInput');

                    if (!miniUserPromptInput) {
                        console.warn('[UserTemplates] 找不到必要的迷你模式DOM元素');
                        return;
                    }

                    const currentContent = miniUserPromptInput.value.trim();

                    // 如果当前选择的是"自定义"选项，不需要处理
                    if (!selectedTemplateId) {
                        return;
                    }

                    // 获取当前选中模板的原始内容
                    const selectedTemplate = allUserTemplates.find(t => t.id === selectedTemplateId);
                    if (!selectedTemplate) {
                        console.warn('[UserTemplates] 找不到选中的模板:', selectedTemplateId);
                        return;
                    }

                    const originalTemplateContent = selectedTemplate.content;

                    // 如果用户修改了内容，且与原始模板内容不同，则自动切换到"自定义"
                    if (currentContent && originalTemplateContent && currentContent !== originalTemplateContent) {
                        selectedTemplateId = '';
                        // 同时更新localStorage，标记当前为自定义状态
                        localStorage.setItem('lastUsedUserTemplateId', 'custom');
                        console.log('[UserTemplates] 迷你模式：用户修改了提示词，自动切换到自定义模板');

                        // 更新模板标签显示，取消选中状态
                        updateMiniTemplateTags();
                    }
                } catch (error) {
                    console.error('[UserTemplates] onMiniUserPromptInputChange执行失败:', error);
                }
            }

            // 打开用户模板管理界面
            function openUserTemplateManager() {
                try {
                    // 创建全屏模态框
                    const modal = document.createElement('div');
                    modal.id = 'userTemplateManagerModal';
                    modal.className = 'fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-50';
                    modal.innerHTML = `
                        <div class="bg-white rounded-lg shadow-2xl w-full h-full max-w-full max-h-full flex flex-col">
                            <div class="flex justify-between items-center p-4 border-b bg-gray-50">
                                <h2 class="text-xl font-bold text-gray-900">
                                    <i class="fa fa-magic mr-2 text-blue-600"></i>
                                    用户提示词模板管理
                                </h2>
                                <button id="closeTemplateManager" class="text-gray-400 hover:text-gray-600 p-2">
                                    <i class="fa fa-times text-xl"></i>
                                </button>
                            </div>
                            <div class="flex-1 overflow-hidden">
                                <iframe src="user-template-manager.html" class="w-full h-full border-0" 
                                        id="templateManagerFrame" name="templateManagerFrame"></iframe>
                            </div>
                        </div>
                    `;

                    // 添加到body
                    document.body.appendChild(modal);

                    // 绑定关闭事件
                    const closeBtn = document.getElementById('closeTemplateManager');
                    closeBtn.addEventListener('click', () => {
                        closeUserTemplateManager();
                    });

                    // 点击背景关闭
                    modal.addEventListener('click', (e) => {
                        if (e.target === modal) {
                            closeUserTemplateManager();
                        }
                    });

                    // ESC键关闭
                    const escHandler = (e) => {
                        if (e.key === 'Escape') {
                            closeUserTemplateManager();
                            document.removeEventListener('keydown', escHandler);
                        }
                    };
                    document.addEventListener('keydown', escHandler);

                    // 监听iframe消息，处理关闭请求和应用模板
                    const messageHandler = (e) => {
                        if (e.data && e.data.type === 'CLOSE_TEMPLATE_MANAGER') {
                            closeUserTemplateManager();
                            window.removeEventListener('message', messageHandler);
                        } else if (e.data && e.data.type === 'useTemplate' && e.data.template) {
                            // 应用模板：更新下拉框和输入框
                            applyTemplateFromManager(e.data.template);
                            window.removeEventListener('message', messageHandler);
                        }
                    };
                    window.addEventListener('message', messageHandler);

                    // 监听iframe加载完成
                    const frame = document.getElementById('templateManagerFrame');
                    frame.addEventListener('load', () => {
                        console.log('[UserTemplates] 模板管理器已加载完成');
                    });

                    console.log('[UserTemplates] 已打开全屏模板管理界面');
                } catch (error) {
                    console.error('[UserTemplates] 打开管理界面失败:', error);
                    alert('打开模板管理界面失败: ' + error.message);
                }
            }

            // 关闭用户模板管理界面
            function closeUserTemplateManager() {
                const modal = document.getElementById('userTemplateManagerModal');
                if (modal) {
                    modal.remove();
                    // 重新加载模板数据
                    loadUserTemplates();
                    console.log('[UserTemplates] 模板管理界面已关闭');
                }
            }

            // 从模板管理器应用模板
            function applyTemplateFromManager(templateData) {
                try {
                    console.log('[UserTemplates] 从管理器应用模板:', templateData);

                    // 关闭模板管理器
                    closeUserTemplateManager();

                    // 获取搜索输入框和用户提示词输入框
                    const searchInput = document.getElementById('userTemplateSearchInput');
                    const userPromptInput = document.getElementById('userPromptInput');

                    if (!searchInput || !userPromptInput) {
                        console.error('[UserTemplates] 找不到必要的DOM元素');
                        return;
                    }

                    // 查找或添加模板到用户模板数组
                    let template = allUserTemplates.find(t => t.id === (templateData.id || templateData.name));
                    if (!template) {
                        // 如果模板不存在，添加到数组
                        template = {
                            id: templateData.id || templateData.name,
                            name: templateData.name,
                            content: templateData.content
                        };
                        allUserTemplates.push(template);
                    }

                    // 选中模板
                    selectedTemplateId = template.id;
                    searchInput.value = template.name;

                    // 更新输入框内容
                    userPromptInput.value = templateData.content;

                    // 更新localStorage
                    localStorage.setItem('lastUsedUserTemplateId', templateData.id || templateData.name);

                    // 记录模板使用时间
                    recordTemplateUsage(templateData.id || templateData.name);

                    console.log('[UserTemplates] 模板已自动应用:', templateData.name);

                    // 隐藏下拉框
                    const dropdown = document.getElementById('userTemplateDropdown');
                    if (dropdown) {
                        dropdown.classList.add('hidden');
                    }

                } catch (error) {
                    console.error('[UserTemplates] 应用模板失败:', error);
                    alert('应用模板失败: ' + error.message);
                }
            }



            // 处理模板切换（带二次确认功能）
            function handleTemplateSwitch(templateId) {
                const template = allUserTemplates.find(t => t.id === templateId);
                if (!template) return;

                const templateContent = template.content;
                const templateName = template.name;

                // 获取当前用户提示词输入框的内容
                const userPromptInput = document.getElementById('userPromptInput');
                if (!userPromptInput) return;
                const currentContent = userPromptInput.value.trim();

                // 获取上次使用的模板ID（用于判断是否是第一次使用）
                const lastUsedTemplateId = localStorage.getItem('lastUsedUserTemplateId') || '';

                // 如果当前内容为空，直接应用模板
                if (!currentContent) {
                    userPromptInput.value = templateContent;
                    localStorage.setItem('lastUsedUserTemplateId', templateId);
                    // 记录模板使用时间
                    recordTemplateUsage(templateId);
                    console.log('[UserTemplates] 模板已自动应用到用户提示词输入框');
                    return true;
                }

                // 只有从"自定义"切换到其他模板时才需要二次确认
                if (lastUsedTemplateId === 'custom' && currentContent) {
                    // 从自定义切换到其他模板，需要确认
                    if (confirm(`确定要用模板"${templateName}"替换当前的用户提示词吗？`)) {
                        userPromptInput.value = templateContent;
                        localStorage.setItem('lastUsedUserTemplateId', templateId);
                        // 记录模板使用时间
                        recordTemplateUsage(templateId);
                        console.log('[UserTemplates] 模板已应用到用户提示词输入框');
                        return true;
                    } else {
                        // 用户取消，重置选择为自定义
                        console.log('[UserTemplates] 用户取消了模板应用');
                        return false;
                    }
                } else {
                    // 从模板A切换到模板B，直接替换，不需要确认
                    userPromptInput.value = templateContent;
                    localStorage.setItem('lastUsedUserTemplateId', templateId);
                    // 记录模板使用时间
                    recordTemplateUsage(templateId);
                    console.log('[UserTemplates] 模板已直接应用到用户提示词输入框');
                    return true;
                }
            }

            // 记录模板使用时间
            function recordTemplateUsage(templateId) {
                try {
                    // 获取现有的使用时间记录
                    let usageTimes = {};
                    try {
                        const usageData = localStorage.getItem('userTemplateUsageTimes');
                        if (usageData) {
                            usageTimes = JSON.parse(usageData);
                        }
                    } catch (e) {
                        console.warn('[UserTemplates] 读取使用时间记录失败:', e);
                    }

                    // 更新当前模板的使用时间
                    usageTimes[templateId] = Date.now();

                    // 保存回localStorage
                    localStorage.setItem('userTemplateUsageTimes', JSON.stringify(usageTimes));
                    console.log('[UserTemplates] 已记录模板使用时间:', templateId);
                } catch (error) {
                    console.error('[UserTemplates] 记录模板使用时间失败:', error);
                }
            }


        </script>
</body>

</html>