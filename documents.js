/**
 * MindWord - æ ‘å¿ƒ | åƒç”»å›¾ä¸€æ ·å†™æ–‡æ¡£çš„æ€ç»´å¯¼å›¾å†™ä½œå·¥å…·
 * GitHub: https://github.com/TimiKays/MindWord
 * 
 * Copyright 2025 Timi Kays
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// =============== æ–‡æ¡£åº“ä¸ä¾§æ  ===============
/*
## ğŸ  æ–‡æ¡£åº“ç®¡ç†åŠŸèƒ½
### 1. æ–‡æ¡£å­˜å‚¨ä¸åŠ è½½
- localStorage å­˜å‚¨ ï¼šä½¿ç”¨ mw_documents å’Œ mw_active_doc ä¸¤ä¸ª key å­˜å‚¨æ–‡æ¡£æ•°æ®å’Œå½“å‰æ´»åŠ¨æ–‡æ¡£
- åŸºç¡€ CRUD æ“ä½œ ï¼šæä¾› mw_loadDocs() ã€ mw_saveDocs() ã€ mw_setActive() ã€ mw_getActive() ç­‰åŸºç¡€å‡½æ•°
### 2. æ–‡æ¡£åˆ—è¡¨æ¸²æŸ“ (mw_renderList)
- æ™ºèƒ½è¿‡æ»¤ ï¼šè‡ªåŠ¨æ¸…ç†å·²åˆ é™¤æ–‡æ¡£å’Œè‡ªåŠ¨ç”Ÿæˆçš„ç©ºæ–‡æ¡£
- æ‹–æ‹½æ’åº ï¼šæ”¯æŒé€šè¿‡æ‹–æ‹½é‡æ–°æ’åºæ–‡æ¡£ï¼ˆä»…åœ¨éæ‰¹é‡æ¨¡å¼ä¸‹ï¼‰
- åŒæ¨¡å¼æ˜¾ç¤º ï¼š
  - æ­£å¸¸æ¨¡å¼ï¼šæ˜¾ç¤ºæ–‡æ¡£åç§°å’Œæ“ä½œæŒ‰é’®
  - æ‰¹é‡æ¨¡å¼ï¼šæ˜¾ç¤ºå¤é€‰æ¡†ï¼Œæ”¯æŒå¤šé€‰æ“ä½œ
### 3. æ–‡æ¡£æ“ä½œåŠŸèƒ½
- æ–°å»ºæ–‡æ¡£ ï¼š mw_newDoc() â†’ mw_showNewDocDialog() â†’ mw_confirmNewDoc()
  - æ”¯æŒ AI è‡ªåŠ¨ç”Ÿæˆåˆå§‹å†…å®¹
  - åˆ›å»ºåè‡ªåŠ¨åŒæ­¥åˆ°ä¸‰ä¸ªé¢æ¿ï¼ˆç¼–è¾‘å™¨ã€é¢„è§ˆã€æ€ç»´å¯¼å›¾ï¼‰
- æ‰“å¼€æ–‡æ¡£ ï¼š mw_openDoc()
  - è®¾ç½®æ´»åŠ¨æ–‡æ¡£
  - åŒæ­¥é€šçŸ¥æ‰€æœ‰é¢æ¿åŠ è½½å†…å®¹
  - è‡ªåŠ¨å…³é—­ä¾§è¾¹æ 
- åˆ é™¤æ–‡æ¡£ ï¼š mw_deleteDoc() â†’ mw_showDeleteConfirm() â†’ mw_confirmDeleteDoc()
  - è½¯åˆ é™¤æœºåˆ¶ï¼ˆæ ‡è®° deletedAt æ—¶é—´æˆ³ï¼‰
  - æ”¯æŒæ‰¹é‡åˆ é™¤
  - åˆ é™¤åè‡ªåŠ¨åˆ‡æ¢åˆ°ä¸‹ä¸€ä¸ªå¯ç”¨æ–‡æ¡£
### 4. é«˜çº§åŠŸèƒ½
- è‡ªåŠ¨æ¸…ç† ï¼š mw_cleanAutoGeneratedEmptyDocs() æ¸…ç†ç³»ç»Ÿè‡ªåŠ¨ç”Ÿæˆçš„ç©ºæ–‡æ¡£
- æ’åºä¿å­˜ ï¼š mw_saveDocOrder() ä¿å­˜ç”¨æˆ·æ‹–æ‹½åçš„æ–‡æ¡£é¡ºåº
- è·¨è®¾å¤‡åŒæ­¥ ï¼šåˆ é™¤æ“ä½œä¼šåŒæ­¥åˆ°æ‰€æœ‰è®¾å¤‡

*/

const MW_STORAGE_KEYS = {
  docs: 'mw_documents',
  active: 'mw_active_doc'
};

function mw_loadDocs() {
  try { return JSON.parse(localStorage.getItem(MW_STORAGE_KEYS.docs) || '[]'); } catch (_) { return []; }
}
function mw_saveDocs(docs) {
  localStorage.setItem(MW_STORAGE_KEYS.docs, JSON.stringify(docs));
}
function mw_setActive(docId) {
  localStorage.setItem(MW_STORAGE_KEYS.active, docId || '');
}
function mw_getActive() {
  return localStorage.getItem(MW_STORAGE_KEYS.active) || '';
}

function mw_cleanAutoGeneratedEmptyDocs() {
  const docs = mw_loadDocs();
  const hasRealDocs = docs.some(doc => !doc.deletedAt && !isAutoGeneratedEmptyDoc(doc));

  if (hasRealDocs) {
    // å¦‚æœæœ‰çœŸå®æ–‡æ¡£ï¼Œåˆ é™¤æ‰€æœ‰è‡ªåŠ¨ç”Ÿæˆçš„ç©ºæ–‡æ¡£
    const cleanedDocs = docs.filter(doc => !isAutoGeneratedEmptyDoc(doc));
    if (cleanedDocs.length !== docs.length) {
      mw_saveDocs(cleanedDocs);
      console.log('è‡ªåŠ¨æ¸…ç†äº†', docs.length - cleanedDocs.length, 'ä¸ªè‡ªåŠ¨ç”Ÿæˆçš„ç©ºæ–‡æ¡£');
      return true;
    }
  }
  return false;
}

function mw_saveDocOrder(orderedIds) {
  const docs = mw_loadDocs();
  const orderedDocs = [];

  // æŒ‰ç…§æ–°çš„é¡ºåºé‡æ–°æ’åˆ—æ–‡æ¡£
  orderedIds.forEach(id => {
    const doc = docs.find(d => d.id === id);
    if (doc) {
      orderedDocs.push(doc);
    }
  });

  // æ·»åŠ å‰©ä½™çš„æ–‡æ¡£ï¼ˆæœªæ‹–æ‹½æ’åºçš„ï¼‰
  docs.forEach(doc => {
    if (!orderedIds.includes(doc.id)) {
      orderedDocs.push(doc);
    }
  });

  mw_saveDocs(orderedDocs);
}

function mw_renderList() {
  const list = document.getElementById('doc-list');

  // å…ˆæ¸…ç†è‡ªåŠ¨ç”Ÿæˆçš„ç©ºæ–‡æ¡£
  const cleaned = mw_cleanAutoGeneratedEmptyDocs();

  const docs = mw_loadDocs();
  const active = mw_getActive();
  const batchMode = document.getElementById('batch-actions').classList.contains('show');
  list.innerHTML = '';

  // è¿‡æ»¤æ‰å·²åˆ é™¤çš„æ–‡æ¡£å’Œè‡ªåŠ¨ç”Ÿæˆçš„ç©ºæ–‡æ¡£
  const visibleDocs = docs.filter(doc => !doc.deletedAt && !isAutoGeneratedEmptyDoc(doc));

  if (!visibleDocs.length) {
    list.innerHTML = '<div style="padding:12px;color:#64748b;font-size:12px;">æš‚æ— æ–‡æ¡£ï¼Œç‚¹å‡»"æ–°å¢"åˆ›å»º</div>';
    return;
  }

  // æ·»åŠ æ‹–æ‹½æ’åºåŠŸèƒ½ï¼ˆä»…åœ¨éæ‰¹é‡æ¨¡å¼ä¸‹ï¼‰
  if (!batchMode) {
    list.style.cursor = 'grab';
    let draggedElement = null;
    let draggedId = null;

    list.addEventListener('dragstart', (e) => {
      if (e.target.classList.contains('doc-item')) {
        draggedElement = e.target;
        draggedId = e.target.dataset.docId;
        e.target.style.opacity = '0.5';
        e.dataTransfer.effectAllowed = 'move';
      }
    });

    list.addEventListener('dragend', (e) => {
      if (e.target.classList.contains('doc-item')) {
        e.target.style.opacity = '';
        draggedElement = null;
        draggedId = null;
      }
    });

    list.addEventListener('dragover', (e) => {
      e.preventDefault();
      e.dataTransfer.dropEffect = 'move';

      const afterElement = getDragAfterElement(list, e.clientY);
      if (afterElement == null) {
        list.appendChild(draggedElement);
      } else {
        list.insertBefore(draggedElement, afterElement);
      }
    });

    list.addEventListener('drop', (e) => {
      e.preventDefault();
      if (draggedElement && draggedId) {
        // è·å–æ–°çš„æ’åº
        const docItems = Array.from(list.querySelectorAll('.doc-item'));
        const orderedIds = docItems.map(item => item.dataset.docId);

        // ä¿å­˜æ–°çš„æ’åº
        mw_saveDocOrder(orderedIds);

        // é‡æ–°æ¸²æŸ“åˆ—è¡¨ä»¥ä¿æŒçŠ¶æ€
        mw_renderList();

        console.log('æ–‡æ¡£æ’åºå·²æ›´æ–°');
      }
    });

    function getDragAfterElement(container, y) {
      const draggableElements = [...container.querySelectorAll('.doc-item:not(.dragging)')];

      return draggableElements.reduce((closest, child) => {
        const box = child.getBoundingClientRect();
        const offset = y - box.top - box.height / 2;

        if (offset < 0 && offset > closest.offset) {
          return { offset: offset, element: child };
        } else {
          return closest;
        }
      }, { offset: Number.NEGATIVE_INFINITY }).element;
    }
  }

  visibleDocs.forEach(doc => {
    const row = document.createElement('div');
    row.className = 'doc-item' + (active === doc.id ? ' active' : '') + (batchMode ? ' batch-mode' : '');
    row.draggable = !batchMode; // ä»…åœ¨éæ‰¹é‡æ¨¡å¼ä¸‹å¯æ‹–æ‹½
    row.dataset.docId = doc.id; // æ·»åŠ æ–‡æ¡£IDç”¨äºæ‹–æ‹½æ’åº

    if (batchMode) {
      // æ‰¹é‡æ¨¡å¼ï¼šæ˜¾ç¤ºå¤é€‰æ¡†
      row.innerHTML = `
                        <input type="checkbox" class="doc-checkbox" data-doc-id="${doc.id}" title="é€‰æ‹©æ–‡æ¡£">
                        <div class="doc-name" title="${doc.name}">${doc.name}</div>
                        <div class="doc-buttons">
                            <button data-act="export" data-i18n="app.toolbar.export">å¯¼å‡º</button>
                            <button data-act="copy" data-i18n="app.toolbar.copy" title="å¤åˆ¶æ–°å»º">å¤åˆ¶</button>
                            <button data-act="del" data-i18n="app.node.delete" style="color:#b91c1c;border-color:#fecaca;">åˆ é™¤</button>
                        </div>
                    `;
    } else {
      // æ­£å¸¸æ¨¡å¼ï¼šä¸æ˜¾ç¤ºå¤é€‰æ¡†
      row.innerHTML = `
                        <div class="doc-name" title="${doc.name}">${doc.name}</div>
                        <div class="doc-buttons">
                            <button data-act="export" data-i18n="app.toolbar.export">å¯¼å‡º</button>
                            <button data-act="copy" data-i18n="app.toolbar.copy" title="å¤åˆ¶æ–°å»º">å¤åˆ¶</button>
                            <button data-act="del" data-i18n="app.node.delete" style="color:#b91c1c;border-color:#fecaca;">åˆ é™¤</button>
                        </div>
                    `;
    }

    row.onclick = (e) => {
      // å¦‚æœç‚¹å‡»çš„æ˜¯æŒ‰é’®æˆ–å¤é€‰æ¡†ï¼Œä¸è§¦å‘æ•´è¡Œç‚¹å‡»
      if (e.target.tagName === 'BUTTON' || e.target.type === 'checkbox') return;
      if (batchMode) {
        // æ‰¹é‡æ¨¡å¼ä¸‹ï¼Œç‚¹å‡»è¡Œåˆ‡æ¢å¤é€‰æ¡†çŠ¶æ€
        const checkbox = row.querySelector('.doc-checkbox');
        if (checkbox) {
          checkbox.checked = !checkbox.checked;
        }
      } else {
        mw_openDoc(doc.id);
      }
    };

    if (!batchMode) {
      row.querySelector('[data-act="export"]').onclick = () => mw_exportDocZip(doc.id);
      row.querySelector('[data-act="copy"]').onclick = () => mw_copyNewDoc(doc.id);
      row.querySelector('[data-act="del"]').onclick = () => mw_deleteDoc(doc.id);
    } else {
      // æ‰¹é‡æ¨¡å¼ä¸‹ä¹Ÿéœ€è¦ç»‘å®šå¤åˆ¶æŒ‰é’®äº‹ä»¶
      row.querySelector('[data-act="copy"]').onclick = () => mw_copyNewDoc(doc.id);
    }

    list.appendChild(row);
  });

  // å¯¹æ–°åˆ›å»ºçš„æŒ‰é’®åº”ç”¨å›½é™…åŒ–ç¿»è¯‘
  if (window.i18nManager) {
    window.i18nManager.updatePageTranslations();
  }
}

function mw_toggleSidebar(open) {
  const el = document.getElementById('doc-sidebar');
  if (open === true) el.classList.add('open');
  else if (open === false) el.classList.remove('open');
  else el.classList.toggle('open');
  el.setAttribute('aria-hidden', el.classList.contains('open') ? 'false' : 'true');
}

function mw_newDoc() {
  mw_showNewDocDialog();
}

// æ˜¾ç¤ºæ–°å»ºæ–‡æ¡£å¯¹è¯æ¡†
function mw_showNewDocDialog() {
  const overlay = document.getElementById('new-doc-overlay');
  const dialog = document.getElementById('new-doc-dialog');
  const input = document.getElementById('new-doc-name');

  // è®¾ç½®é»˜è®¤å€¼
  input.value = 'æœªå‘½åæ–‡æ¡£';

  // æ˜¾ç¤ºå¯¹è¯æ¡†å’Œé®ç½©
  overlay.style.display = 'block';
  dialog.style.display = 'block';

  // èšç„¦è¾“å…¥æ¡†
  setTimeout(() => {
    input.focus();
    input.select();
  }, 100);
}

// éšè—æ–°å»ºæ–‡æ¡£å¯¹è¯æ¡†
function mw_hideNewDocDialog() {
  const overlay = document.getElementById('new-doc-overlay');
  const dialog = document.getElementById('new-doc-dialog');

  overlay.style.display = 'none';
  dialog.style.display = 'none';
}

// ç¡®è®¤åˆ›å»ºæ–°æ–‡æ¡£
function mw_confirmNewDoc(useAIGenerate) {
  const input = document.getElementById('new-doc-name');
  const name = input.value.trim();

  if (!name) {
    alert('è¯·è¾“å…¥æ–‡æ¡£åç§°');
    return;
  }

  mw_hideNewDocDialog();

  const id = 'doc_' + Date.now();
  const doc = {
    id, name,
    md: '# ' + name + '\n',
    images: [], // {id, name, mime}
    createdAt: Date.now(),
    updatedAt: Date.now(),
    version: 1
  };
  const docs = mw_loadDocs();
  docs.push(doc);
  mw_saveDocs(docs);
  mw_setActive(id);
  mw_renderList();
  mw_notifyEditorLoad(doc);
  mw_notifyMindmapLoad(doc); // é€šçŸ¥æ€ç»´å¯¼å›¾é¢æ¿åŠ è½½æ–°æ–‡æ¡£

  // å¦‚æœä½¿ç”¨AIç”Ÿæˆï¼Œç«‹å³éšè—ä¾§è¾¹æ å¹¶æ¿€æ´»æ€ç»´å¯¼å›¾é¡µé¢çš„AIåŠŸèƒ½
  if (useAIGenerate) {
    // ç«‹å³éšè—æ–‡æ¡£ä¾§è¾¹æ 
    mw_toggleSidebar(false);

    setTimeout(() => {
      const mindmapFrame = document.querySelector('iframe[data-panel="mindmap"], iframe#iframe-mindmap, iframe[src*="jsmind/mindmap.html"]');
      if (mindmapFrame && mindmapFrame.contentWindow && mindmapFrame.contentWindow.aiGenerateInitialTreeMini) {
        mindmapFrame.contentWindow.aiGenerateInitialTreeMini({
          placeholders: {
            name: { value: name }
          },
          autoRun: true
        });
      } else {
        console.warn('[AI] æ— æ³•æ‰¾åˆ°æ€ç»´å¯¼å›¾iframeæˆ–aiGenerateInitialTreeMiniå‡½æ•°');
      }
    }, 500); // å»¶è¿Ÿç¡®ä¿æ€ç»´å¯¼å›¾åŠ è½½å®Œæˆ
  }

  try { showSuccess && showSuccess('å·²åˆ›å»ºå¹¶æ‰“å¼€'); } catch (_) { }
}

// åˆ‡æ¢æ–‡æ¡£
function mw_openDoc(id) {
  console.log('[DOC] mw_openDoc starting for doc id:', id);
  const docs = mw_loadDocs();
  const doc = docs.find(d => d.id === id);
  if (!doc) {
    console.warn('[DOC] mw_openDoc failed: document not found for id:', id);
    return alert('æ–‡æ¡£ä¸å­˜åœ¨');
  }
  console.log('[DOC] mw_openDoc found document:', doc.name, 'id:', doc.id, 'version:', doc.version);

  mw_setActive(id);
  console.log('[DOC] mw_openDoc set active document to:', id);

  mw_renderList();
  console.log('[DOC] mw_openDoc rendered document list');

  // æ‰“å¼€æ—¶ä»¥ Markdown ä¸ºå‡†åŒæ­¥ä¸‰é¢æ¿
  console.log('[DOC] mw_openDoc starting panel notifications...');
  mw_notifyEditorLoad(doc);
  console.log('[DOC] mw_openDoc notified editor panel');

  mw_notifyPreviewLoad(doc);
  console.log('[DOC] mw_openDoc notified preview panel');

  mw_notifyMindmapLoad(doc);
  console.log('[DOC] mw_openDoc completed mindmap notification');

  // ç«‹å³å…³é—­ä¾§æ å¹¶ç¡®ä¿ç¼–è¾‘å™¨é¢æ¿æ˜¾ç¤ºï¼ˆé¿å… handleTabClick åœ¨éä¸“æ³¨æ¨¡å¼ä¸‹æŠŠç¼–è¾‘å™¨åˆ‡æ¢ä¸ºéšè—ï¼‰
  try {
    mw_toggleSidebar(false);
    console.log('[DOC] mw_openDoc toggled sidebar');
  } catch (e) {
    console.warn('[DOC] mw_openDoc failed to toggle sidebar:', e);
  }

  try {
    // panels.editor = true;
    saveStateToStorage();
    updateLayout();
    updateTabs();
    console.log('[DOC] mw_openDoc updated layout and tabs');
  } catch (e) {
    console.warn('[DOC] mw_openDoc failed to update layout/tabs:', e);
  }

  console.log('[DOC] mw_openDoc completed successfully for doc:', doc.name);
}

// åˆ é™¤æ–‡æ¡£ï¼ˆæ˜¾ç¤ºç¡®è®¤å¯¹è¯æ¡†ï¼‰
function mw_deleteDoc(docId) {
  const docs = mw_loadDocs();
  const doc = docs.find(d => d.id === docId);
  if (!doc) return;

  // æ˜¾ç¤ºåˆ é™¤ç¡®è®¤å¯¹è¯æ¡†
  mw_showDeleteConfirm(docId, doc.name);
}

// æ˜¾ç¤ºåˆ é™¤ç¡®è®¤å¯¹è¯æ¡†ï¼ˆä¾§è¾¹æ å†…åµŒç‰ˆæœ¬ï¼‰
function mw_showDeleteConfirm(docId, docName) {
  const overlay = document.getElementById('delete-confirm-overlay');
  const dialog = document.getElementById('delete-confirm-dialog');
  const message = document.getElementById('delete-confirm-message');

  // è®¾ç½®ç¡®è®¤æ¶ˆæ¯
  message.textContent = `ç¡®å®šè¦åˆ é™¤æ–‡æ¡£ "${docName}"ï¼Ÿæ­¤æ“ä½œä¼šåœ¨æ‰€æœ‰è®¾å¤‡ä¸ŠåŒæ­¥åˆ é™¤`;

  // å­˜å‚¨æ–‡æ¡£IDç”¨äºç¡®è®¤åˆ é™¤
  dialog.dataset.docId = docId;

  // æ˜¾ç¤ºå¯¹è¯æ¡†å’Œé®ç½©
  overlay.style.display = 'block';
  dialog.style.display = 'block';
}

// æ˜¾ç¤ºæ‰¹é‡åˆ é™¤ç¡®è®¤å¯¹è¯æ¡†ï¼ˆä¾§è¾¹æ å†…åµŒç‰ˆæœ¬ï¼‰
function mw_showBatchDeleteConfirm() {
  const checkboxes = document.querySelectorAll('.doc-checkbox:checked');
  if (checkboxes.length === 0) {
    alert('è¯·å…ˆé€‰æ‹©è¦åˆ é™¤çš„æ–‡æ¡£');
    return;
  }

  const overlay = document.getElementById('delete-confirm-overlay');
  const dialog = document.getElementById('delete-confirm-dialog');
  const message = document.getElementById('delete-confirm-message');

  // æ¸…é™¤æ–‡æ¡£IDï¼Œç¡®ä¿è¿™æ˜¯æ‰¹é‡åˆ é™¤æ¨¡å¼
  dialog.removeAttribute('data-doc-id');

  // è®¾ç½®ç¡®è®¤æ¶ˆæ¯
  message.textContent = `ç¡®å®šè¦åˆ é™¤é€‰ä¸­çš„ ${checkboxes.length} ä¸ªæ–‡æ¡£ï¼Ÿæ­¤æ“ä½œä¼šåœ¨æ‰€æœ‰è®¾å¤‡ä¸ŠåŒæ­¥åˆ é™¤`;

  // æ˜¾ç¤ºå¯¹è¯æ¡†å’Œé®ç½©
  overlay.style.display = 'block';
  dialog.style.display = 'block';
}

// ç¡®è®¤æ‰¹é‡åˆ é™¤
async function mw_confirmBatchDelete() {
  mw_hideDeleteConfirm();

  const checkboxes = document.querySelectorAll('.doc-checkbox:checked');
  let docs = mw_loadDocs();
  const selectedIds = Array.from(checkboxes).map(cb => cb.dataset.docId);

  // æ ‡è®°é€‰ä¸­æ–‡æ¡£ä¸ºå·²åˆ é™¤
  let deletedCount = 0;
  selectedIds.forEach(id => {
    const idx = docs.findIndex(d => d.id === id);
    if (idx >= 0) {
      docs[idx] = {
        id: docs[idx].id,
        name: docs[idx].name,
        deletedAt: Date.now(),
        updatedAt: Date.now()
      };
      deletedCount++;
    }
  });

  mw_saveDocs(docs);

  // åˆ é™¤å…³è”çš„å›¾ç‰‡
  if (window.imageStorage) {
    let totalDeletedImages = 0;
    for (const docId of selectedIds) {
      try {
        const deletedImagesCount = await window.imageStorage.deleteImagesByDocumentId(docId);
        totalDeletedImages += deletedImagesCount;
        console.log(`åˆ é™¤äº†æ–‡æ¡£ ${docId} çš„ ${deletedImagesCount} å¼ å›¾ç‰‡`);
      } catch (error) {
        console.error(`åˆ é™¤æ–‡æ¡£ ${docId} å…³è”å›¾ç‰‡å¤±è´¥:`, error);
      }
    }
    if (totalDeletedImages > 0) {
      console.log(`æ‰¹é‡åˆ é™¤æ–‡æ¡£æ—¶æ€»å…±åˆ é™¤äº† ${totalDeletedImages} å¼ å›¾ç‰‡`);
    }
  }

  // å¦‚æœåˆ é™¤çš„æ–‡æ¡£ä¸­åŒ…å«å½“å‰æ´»åŠ¨æ–‡æ¡£
  const activeId = mw_getActive();
  if (selectedIds.includes(activeId)) {
    // æ¸…ç©ºå½“å‰æ´»åŠ¨æ–‡æ¡£
    mw_setActive('');

    // æ‰¾åˆ°ç¬¬ä¸€ä¸ªæœªåˆ é™¤çš„æ–‡æ¡£
    const activeDoc = docs.find(d => !d.deletedAt);
    if (activeDoc) {
      mw_setActive(activeDoc.id);
      // é€šçŸ¥å„ä¸ªé¢æ¿åŠ è½½ç¬¬ä¸€ä¸ªæœªåˆ é™¤æ–‡æ¡£
      mw_notifyEditorLoad(activeDoc);
      mw_notifyPreviewLoad(activeDoc);
      mw_notifyMindmapLoad(activeDoc);
    } else {
      // æ²¡æœ‰å‰©ä½™æœªåˆ é™¤æ–‡æ¡£ï¼Œä¸å†è‡ªåŠ¨ç”Ÿæˆç©ºæ–‡æ¡£
      // æ¸…ç©ºæ´»åŠ¨æ–‡æ¡£ï¼Œè®©ç”¨æˆ·æ‰‹åŠ¨åˆ›å»ºæ–°æ–‡æ¡£
      console.log('æ²¡æœ‰å‰©ä½™æ–‡æ¡£ï¼Œç­‰å¾…ç”¨æˆ·æ‰‹åŠ¨åˆ›å»º');
    }
  }

  // é€€å‡ºæ‰¹é‡æ¨¡å¼
  mw_exitBatchMode();
  mw_renderList();
  try { showSuccess && showSuccess(`å·²åˆ é™¤ ${deletedCount} ä¸ªæ–‡æ¡£ï¼Œå°†åœ¨æ‰€æœ‰è®¾å¤‡åŒæ­¥`); } catch (_) { }
}

// éšè—åˆ é™¤ç¡®è®¤å¯¹è¯æ¡†
function mw_hideDeleteConfirm() {
  const overlay = document.getElementById('delete-confirm-overlay');
  const dialog = document.getElementById('delete-confirm-dialog');

  overlay.style.display = 'none';
  dialog.style.display = 'none';
  dialog.removeAttribute('data-doc-id');
}

// ç¡®è®¤åˆ é™¤å•ä¸ªæ–‡æ¡£
async function mw_confirmDeleteDoc() {
  const dialog = document.getElementById('delete-confirm-dialog');
  const docId = dialog.dataset.docId;

  if (!docId) return;

  mw_hideDeleteConfirm();

  let docs = mw_loadDocs();
  const idx = docs.findIndex(d => d.id === docId);
  if (idx >= 0) {
    docs[idx] = {
      id: docs[idx].id,
      name: docs[idx].name,
      deletedAt: Date.now(),
      updatedAt: Date.now()
    };
    mw_saveDocs(docs);

    // åˆ é™¤å…³è”çš„å›¾ç‰‡
    if (window.imageStorage) {
      try {
        const deletedImagesCount = await window.imageStorage.deleteImagesByDocumentId(docId);
        console.log(`åˆ é™¤äº†æ–‡æ¡£ ${docId} çš„ ${deletedImagesCount} å¼ å›¾ç‰‡`);
      } catch (error) {
        console.error(`åˆ é™¤æ–‡æ¡£ ${docId} å…³è”å›¾ç‰‡å¤±è´¥:`, error);
      }
    }

    // å¦‚æœåˆ é™¤çš„æ˜¯å½“å‰æ´»åŠ¨æ–‡æ¡£
    const activeId = mw_getActive();
    if (docId === activeId) {
      // æ¸…ç©ºå½“å‰æ´»åŠ¨æ–‡æ¡£
      mw_setActive('');

      // æ‰¾åˆ°ç¬¬ä¸€ä¸ªæœªåˆ é™¤çš„æ–‡æ¡£
      const activeDoc = docs.find(d => !d.deletedAt);
      if (activeDoc) {
        mw_setActive(activeDoc.id);
        // é€šçŸ¥å„ä¸ªé¢æ¿åŠ è½½ç¬¬ä¸€ä¸ªæœªåˆ é™¤æ–‡æ¡£
        mw_notifyEditorLoad(activeDoc);
        mw_notifyPreviewLoad(activeDoc);
        mw_notifyMindmapLoad(activeDoc);
      } else {
        // æ²¡æœ‰å‰©ä½™æœªåˆ é™¤æ–‡æ¡£ï¼Œä¸å†è‡ªåŠ¨ç”Ÿæˆæœªå‘½åæ–‡æ¡£ï¼Œç­‰å¾…ç”¨æˆ·æ‰‹åŠ¨åˆ›å»º
        console.log('æ²¡æœ‰å‰©ä½™æ–‡æ¡£ï¼Œç­‰å¾…ç”¨æˆ·æ‰‹åŠ¨åˆ›å»º');
        // æ¸…ç©ºå½“å‰æ´»åŠ¨æ–‡æ¡£
        mw_setActive(null);
        mw_renderList();
        // é€šçŸ¥å„ä¸ªé¢æ¿æ¸…ç©ºå†…å®¹
        mw_notifyEditorLoad({ id: null, name: '', md: '', images: [] });
        mw_notifyPreviewLoad({ md: '', images: [] });
        mw_notifyMindmapLoad({ md: '', images: [] });
      }
    }

    mw_renderList();
    try { showSuccess && showSuccess('æ–‡æ¡£å·²åˆ é™¤ï¼Œå°†åœ¨æ‰€æœ‰è®¾å¤‡åŒæ­¥'); } catch (_) { }
  }
}

// æ‰¹é‡åˆ é™¤åŠŸèƒ½
function mw_batchDeleteDocs() {
  mw_showBatchDeleteConfirm();
}

// è¿›å…¥æ‰¹é‡æ¨¡å¼
function mw_enterBatchMode() {
  document.getElementById('batch-actions').classList.add('show');
  mw_renderList();
}

// é€€å‡ºæ‰¹é‡æ¨¡å¼
function mw_exitBatchMode() {
  document.getElementById('batch-actions').classList.remove('show');
  mw_renderList();
}

// å…¨é€‰æ–‡æ¡£
function mw_selectAllDocs() {
  document.querySelectorAll('.doc-checkbox').forEach(cb => cb.checked = true);
}

// å…¨ä¸é€‰æ–‡æ¡£
function mw_selectNoneDocs() {
  document.querySelectorAll('.doc-checkbox').forEach(cb => cb.checked = false);
}

function mw_notifyEditorLoad(doc) {
  const editorIframe = document.querySelector('iframe[data-panel="editor"], iframe#iframe-editor, iframe[src*="editor/editor.html"]');
  // ç¡®ä¿å›¾ç‰‡æ•°æ®æ ¼å¼æ­£ç¡®ä¼ é€’ç»™ç¼–è¾‘å™¨
  const images = doc.images || [];
  const payload = {
    id: doc.id,
    name: doc.name,
    md: doc.md,
    images: images,
    rev: doc.version || doc.updatedAt || Date.now(),
    origin: 'index'
  };
  if (editorIframe && editorIframe.contentWindow) {
    try {
      editorIframe.contentWindow.postMessage({ type: 'mw_load_document', payload }, '*');
      console.log('[DOC] -> editor mw_load_document', payload.id, 'rev=', payload.rev);
    } catch (e) { console.warn('postMessage to editor failed', e); }
  } else {
    // iframe æœªå°±ç»ªï¼Œç¼“å­˜å¾…å‘å†…å®¹ï¼Œonload ç«‹å³æ´¾å‘
    try { window.__mw_pendingEditorDocument = payload; } catch (_) { }
  }
}

function mw_notifyPreviewLoad(doc) {
  const previewIframe = document.querySelector('iframe[data-panel="preview"], iframe#iframe-preview, iframe[src*="md2word/md2word.html"], iframe[src*="preview"]');
  const payload = { md: doc.md, images: doc.images || [], rev: doc.version || doc.updatedAt || Date.now(), origin: 'index' };
  if (previewIframe && previewIframe.contentWindow) {
    try {
      previewIframe.contentWindow.postMessage({ type: 'mw_load_markdown', payload }, '*');
      console.log('[DOC] -> preview mw_load_markdown', (doc.id || ''), 'rev=', payload.rev);
    } catch (e) { console.warn('postMessage to preview failed', e); }
  } else {
    // iframe å°šæœªå°±ç»ªï¼Œç¼“å­˜å¾…å‘é€æ•°æ®ï¼Œå¾… onload æ—¶ç«‹å³å‘é€
    try { window.__mw_pendingPreviewMarkdown = payload; } catch (_) { }
  }
}

function mw_notifyMindmapLoad(doc) {
  console.log('[DOC] mw_notifyMindmapLoad starting for doc:', (doc.name || 'unnamed'), 'id:', (doc.id || 'none'));

  const mmIframe = document.querySelector('iframe[data-panel="mindmap"], iframe#iframe-mindmap, iframe[src*="jsmind/mindmap.html"]');
  console.log('[DOC] mw_notifyMindmapLoad found iframe:', !!mmIframe);

  if (mmIframe) {
    console.log('[DOC] mw_notifyMindmapLoad iframe details - src:', (mmIframe.src || 'none'));
    console.log('[DOC] mw_notifyMindmapLoad iframe details - contentWindow exists:', !!mmIframe.contentWindow);
    console.log('[DOC] mw_notifyMindmapLoad iframe details - readyState:', (mmIframe.readyState || 'unknown'));
  }

  const payload = {
    md: doc.md,
    images: doc.images || [],
    rev: doc.version || doc.updatedAt || Date.now(),
    origin: 'index',
    docId: doc.id
  };

  console.log('[DOC] mw_notifyMindmapLoad prepared payload - rev:', payload.rev, 'md length:', (doc.md ? doc.md.length : 0));

  if (mmIframe && mmIframe.contentWindow) {
    console.log('[DOC] mw_notifyMindmapLoad attempting to send message to mindmap iframe...');
    try {
      mmIframe.contentWindow.postMessage({ type: 'mw_load_markdown', payload }, '*');
      console.log('[DOC] -> mindmap mw_load_markdown SUCCESS', (doc.id || ''), 'rev=', payload.rev);
    } catch (e) {
      console.error('[DOC] -> mindmap mw_load_markdown FAILED', (doc.id || ''), 'error:', e);
      console.warn('postMessage to mindmap failed', e);
    }
  } else {
    console.warn('[DOC] mw_notifyMindmapLoad iframe not ready, caching payload for later');
    try {
      window.__mw_pendingMindmapMarkdown = payload;
      console.log('[DOC] mw_notifyMindmapLoad cached payload for iframe onload');
    } catch (e) {
      console.error('[DOC] mw_notifyMindmapLoad failed to cache payload:', e);
    }
  }

  console.log('[DOC] mw_notifyMindmapLoad completed');
}

// ===== å¯¼å‡ºä¸ºZIPï¼ˆå•æ–‡æ¡£/å…¨éƒ¨ï¼‰ =====
async function mw_exportDocZip(id) {
  const docs = mw_loadDocs();
  const doc = docs.find(d => d.id === id);
  if (!doc) return alert('æ–‡æ¡£ä¸å­˜åœ¨');
  const zip = new JSZip();
  const safeName = (doc.name || 'document').replace(/[\\/:*?"<>|]+/g, '_');
  const root = zip.folder(safeName);

  // md
  root.file('index.md', doc.md || '');

  // images
  if (doc.images && doc.images.length) {
    const imgFolder = root.folder('images');

    // ä»IndexedDBè·å–å›¾ç‰‡æ•°æ®
    let imagesMap;
    if (window.imageStorage) {
      try {
        imagesMap = await window.imageStorage.getImagesMap();
      } catch (error) {
        console.warn('ä»IndexedDBè·å–å›¾ç‰‡å¤±è´¥:', error);
        imagesMap = new Map();
      }
    } else {
      imagesMap = new Map();
    }

    for (let i = 0; i < doc.images.length; i++) {
      const img = doc.images[i];

      // ä¼˜å…ˆä»IndexedDBè·å–å›¾ç‰‡æ•°æ®ï¼Œå¦‚æœæ²¡æœ‰åˆ™ä½¿ç”¨æ–‡æ¡£ä¸­çš„æ•°æ®
      let imageData = imagesMap.get(img.id);
      if (!imageData && img.dataUrl) {
        imageData = img;
      }

      if (!imageData || !imageData.dataUrl) {
        console.warn(`å¯¼å‡ºå›¾ç‰‡å¤±è´¥: å›¾ç‰‡ ${img.id} æ•°æ®ä¸å¯ç”¨`);
        continue;
      }

      // ç”Ÿæˆå”¯ä¸€çš„æ–‡ä»¶åï¼Œä¼˜å…ˆä½¿ç”¨å›¾ç‰‡IDï¼Œç¡®ä¿ä¸markdownå¼•ç”¨ä¿æŒä¸€è‡´
      let fname;
      if (img.id) {
        // å¦‚æœæœ‰IDï¼Œç›´æ¥ä½¿ç”¨IDä½œä¸ºæ–‡ä»¶åï¼Œä¿æŒä¸markdownå¼•ç”¨ä¸€è‡´
        fname = img.id + '.png';
      } else if (img.name) {
        // å¦‚æœæœ‰åå­—ï¼Œä½¿ç”¨åå­—
        fname = img.name;
      } else {
        // å¦‚æœéƒ½æ²¡æœ‰ï¼Œç”Ÿæˆå¸¦ç´¢å¼•çš„å”¯ä¸€åç§°
        fname = 'img_' + i + '_' + Date.now() + '.png';
      }

      // ç¡®ä¿æ–‡ä»¶åå”¯ä¸€ï¼ˆé˜²æ­¢å¤šä¸ªå›¾ç‰‡åŒåï¼‰
      const baseName = fname.replace(/\.[^.]+$/, '');
      const ext = fname.match(/\.[^.]+$/) ? fname.match(/\.[^.]+$/)[0] : '.png';
      let finalName = fname;
      let counter = 1;

      // æ£€æŸ¥æ–‡ä»¶åæ˜¯å¦å·²å­˜åœ¨ï¼Œå¦‚æœå­˜åœ¨åˆ™æ·»åŠ åºå·
      while (imgFolder.file(finalName)) {
        finalName = baseName + '_' + counter + ext;
        counter++;
      }

      // å°† dataURL è½¬ä¸ºäºŒè¿›åˆ¶
      const blob = await window.imageStorage.dataUrlToBlob(imageData.dataUrl);
      const ab = await blob.arrayBuffer();
      imgFolder.file(finalName, ab);

      console.log('mw_exportDocZip: å¯¼å‡ºå›¾ç‰‡', finalName, 'åŸID:', img.id, 'åŸname:', img.name);
    }
  }



  // meta
  root.file('meta.json', JSON.stringify({
    id: doc.id,
    name: doc.name,
    version: doc.version || 1,
    exportedAt: Date.now()
  }, null, 2));

  const blob = await zip.generateAsync({ type: 'blob' });
  saveAs(blob, safeName + '.zip');
  try { showSuccess && showSuccess('ZIP å¯¼å‡ºå®Œæˆ'); } catch (_) { }
}

// å¯¼å‡ºå…¨éƒ¨ä¸º ZIP
async function mw_exportAllZip() {
  const docs = mw_loadDocs();
  if (!docs.length) return alert('æ²¡æœ‰æ–‡æ¡£å¯å¯¼å‡º');

  const loadingMsg = "æ­£åœ¨æ‰“åŒ… " + docs.length + " ä¸ªæ–‡æ¡£...";
  try { showInfo && showInfo(loadingMsg, 2000); } catch (_) { }

  const zip = new JSZip();

  // 1. å¯¼å‡º AI è¾…åŠ©é…ç½®
  const aiFolder = zip.folder('ai');
  const aiCfg = mw_fetchAIPlatformConfigsSnapshot();
  if (aiCfg) aiFolder.file('platform-configs.json', JSON.stringify(aiCfg, null, 2));

  let myPromptTemplates = [];
  try {
    const stored = localStorage.getItem('myPromptTemplates');
    if (stored) myPromptTemplates = JSON.parse(stored);
  } catch (e) { console.warn('Export templates warning:', e); }

  if (myPromptTemplates && myPromptTemplates.length > 0) {
    aiFolder.file('my-prompt-templates.json', JSON.stringify(myPromptTemplates, null, 2));
  }

  // 2. å¾ªç¯å¯¼å‡ºæ¯ä¸ªæ–‡æ¡£
  for (const doc of docs) {
    // å®‰å…¨çš„æ–‡ä»¶åå¤„ç†
    let safeName = (doc.name || 'document').replace(/[\\/:*?"<>|]+/g, '_').trim();
    if (!safeName) safeName = "Untitled_" + doc.id;

    // ä¸ºæ¯ä¸ªæ–‡æ¡£åˆ›å»ºä¸€ä¸ªæ–‡ä»¶å¤¹
    const root = zip.folder(safeName);
    root.file('index.md', doc.md || '');

    // è·å–è¯¥æ–‡æ¡£çš„å®Œæ•´å›¾ç‰‡æ•°æ®
    let imagesMap = {};
    if (window.imageStorage && window.imageStorage.getImagesMap) {
      try {
        const mapResult = await window.imageStorage.getImagesMap(doc.id);
        console.log('mw_exportAllZip: è·å–åˆ°çš„imagesMap', {
          docId: doc.id,
          isMap: mapResult instanceof Map,
          size: mapResult.size || Object.keys(mapResult).length,
          firstKey: mapResult.keys ? mapResult.keys().next().value : Object.keys(mapResult)[0],
          firstImage: mapResult.get ? mapResult.get(mapResult.keys().next().value) : mapResult[Object.keys(mapResult)[0]]
        });

        // å¦‚æœæ˜¯Mapå¯¹è±¡ï¼Œè½¬æ¢ä¸ºæ™®é€šå¯¹è±¡
        if (mapResult instanceof Map) {
          imagesMap = {};
          for (const [key, value] of mapResult.entries()) {
            imagesMap[key] = value;
          }
        } else {
          imagesMap = mapResult;
        }
      } catch (err) {
        console.error('è·å–å›¾ç‰‡æ•°æ®å¤±è´¥:', err);
      }
    }

    // å¤„ç†å›¾ç‰‡å¯¼å‡º
    if (doc.images && Array.isArray(doc.images) && doc.images.length > 0) {
      const imgFolder = root.folder('images');
      for (let i = 0; i < doc.images.length; i++) {
        const img = doc.images[i];
        // ç”Ÿæˆå”¯ä¸€çš„æ–‡ä»¶åï¼Œä¼˜å…ˆä½¿ç”¨å›¾ç‰‡IDï¼Œç¡®ä¿ä¸markdownå¼•ç”¨ä¿æŒä¸€è‡´
        let fname;
        if (img.id) {
          // å¦‚æœæœ‰IDï¼Œç›´æ¥ä½¿ç”¨IDä½œä¸ºæ–‡ä»¶åï¼Œä¿æŒä¸markdownå¼•ç”¨ä¸€è‡´
          fname = img.id + '.png';
        } else if (img.name) {
          // å¦‚æœæœ‰åå­—ï¼Œä½¿ç”¨åå­—
          fname = img.name;
        } else {
          // å¦‚æœéƒ½æ²¡æœ‰ï¼Œç”Ÿæˆå¸¦ç´¢å¼•çš„å”¯ä¸€åç§°
          fname = 'img_' + i + '_' + Date.now() + '.png';
        }

        // ç¡®ä¿æ–‡ä»¶åå”¯ä¸€ï¼ˆé˜²æ­¢å¤šä¸ªå›¾ç‰‡åŒåï¼‰
        const baseName = fname.replace(/\.[^.]+$/, '');
        const ext = fname.match(/\.[^.]+$/) ? fname.match(/\.[^.]+$/)[0] : '.png';
        let finalName = fname;
        let counter = 1;

        // æ£€æŸ¥æ–‡ä»¶åæ˜¯å¦å·²å­˜åœ¨ï¼Œå¦‚æœå­˜åœ¨åˆ™æ·»åŠ åºå·
        while (imgFolder.file(finalName)) {
          finalName = baseName + '_' + counter + ext;
          counter++;
        }

        try {
          // ä»imagesMapè·å–å®Œæ•´çš„å›¾ç‰‡æ•°æ®
          const imageData = imagesMap[img.id] || img;
          console.log('mw_exportAllZip: å›¾ç‰‡æ•°æ®', {
            id: img.id,
            hasDataUrl: !!imageData.dataUrl,
            dataUrlLength: imageData.dataUrl ? imageData.dataUrl.length : 0,
            dataUrlPrefix: imageData.dataUrl ? imageData.dataUrl.substring(0, 50) + '...' : 'null'
          });

          // dataUrl è½¬ Blob å†è½¬ ArrayBuffer
          const blob = await window.imageStorage.dataUrlToBlob(imageData.dataUrl || '');
          console.log('mw_exportAllZip: è½¬æ¢åçš„Blob', {
            size: blob.size,
            type: blob.type
          });

          const ab = await blob.arrayBuffer();
          console.log('mw_exportAllZip: è½¬æ¢åçš„ArrayBuffer', {
            byteLength: ab.byteLength
          });

          imgFolder.file(finalName, ab);
          console.log('mw_exportAllZip: å¯¼å‡ºå›¾ç‰‡', finalName, 'æ–‡æ¡£:', safeName, 'åŸID:', img.id, 'åŸname:', img.name);
        } catch (err) {
          console.error(`å¯¼å‡ºå›¾ç‰‡ ${finalName} å¤±è´¥:`, err);
        }
      }
    }

    // å¯¼å‡ºå…ƒæ•°æ®
    root.file('meta.json', JSON.stringify({
      id: doc.id,
      name: doc.name,
      version: doc.version || 1,
      updatedAt: doc.updatedAt
    }, null, 2));
  }

  // ç”Ÿæˆå¹¶ä¸‹è½½
  const blob = await zip.generateAsync({ type: 'blob' });
  saveAs(blob, 'MindWord_AllDocs.zip');
  try { showSuccess && showSuccess('å…¨éƒ¨ ZIP å¯¼å‡ºå®Œæˆ'); } catch (_) { }
}

// ===== å¯¼å…¥ZIPï¼ˆæ”¯æŒå¤šæ–‡æ¡£ï¼‰ =====
async function mw_importZip(file) {
  if (!file) return;
  const zip = await JSZip.loadAsync(file);

  // å…¼å®¹å¤šç§å‹ç¼©å™¨çš„è·¯å¾„æ ¼å¼ï¼šæ”¶é›† zip.files ä¸­çš„æ‰€æœ‰é¡¶çº§æ–‡ä»¶å¤¹ï¼ˆå»é‡ï¼‰
  const topFolderSet = new Set();
  Object.keys(zip.files).forEach(name => {
    if (!name) return;
    const parts = name.split('/');
    if (parts.length > 1 && parts[0].trim()) {
      topFolderSet.add(parts[0].trim() + '/');
    } else if (name.endsWith('/') && !name.slice(0, -1).includes('/')) {
      // å…¼å®¹åªæœ‰ç›®å½•æ¡ç›®çš„æƒ…å†µï¼ˆä¾‹å¦‚æŸäº›å·¥å…·ä¼šä»…ä¿ç•™ç›®å½• entryï¼‰
      topFolderSet.add(name);
    }
  });
  const topFolders = Array.from(topFolderSet);
  const docs = mw_loadDocs();

  // æ–°å¢ï¼šIDå†²çªå¤„ç†ç›¸å…³å˜é‡
  let conflictResolution = null; // ç”¨æˆ·é€‰æ‹©çš„å†²çªå¤„ç†æ–¹å¼: 'keep_latest', 'replace', 'create_new'
  const conflicts = []; // å­˜å‚¨æ£€æµ‹åˆ°çš„å†²çªä¿¡æ¯

  // è¯»å–æ ¹çº§ ai é…ç½®ï¼ˆè‹¥å­˜åœ¨ï¼‰ï¼Œå¹¶ä¾›æ‰€æœ‰æ–‡æ¡£å¤ç”¨ã€‚
  // è¯´æ˜ï¼šå¯¼å‡ºçš„ AI é…ç½®ç°åœ¨æ”¾åœ¨ ZIP æ ¹ç›®å½•çš„ ai/ æ–‡ä»¶å¤¹ä¸‹ï¼ˆä¸å„æ–‡æ¡£æ–‡ä»¶å¤¹å¹³çº§ï¼‰ã€‚
  let rootAiCfg = null, rootTpl = null;
  try {
    const rootAiFolder = zip.folder('ai');
    if (rootAiFolder) {
      const cfg = rootAiFolder.file('platform-configs.json');
      const tpf = rootAiFolder.file('prompt-templates.json');
      const myTpf = rootAiFolder.file('my-prompt-templates.json');
      if (cfg) try { rootAiCfg = JSON.parse(await cfg.async('string')); } catch (_) { console.warn('mw_importZip: parse root platform-configs.json failed'); }
      if (tpf) try { rootTpl = JSON.parse(await tpf.async('string')); } catch (_) { console.warn('mw_importZip: parse root prompt-templates.json failed'); }
      if (myTpf) {
        try {
          const myTemplates = JSON.parse(await myTpf.async('string'));
          if (myTemplates && myTemplates.length > 0) {
            // å°†myPromptTemplatesä¿å­˜åˆ°localStorage
            localStorage.setItem('myPromptTemplates', JSON.stringify(myTemplates));
            console.log('mw_importZip: æˆåŠŸå¯¼å…¥my-prompt-templates.json');
          }
        } catch (_) {
          console.warn('mw_importZip: parse root my-prompt-templates.json failed');
        }
      }
    }
  } catch (err) {
    console.warn('mw_importZip: read root ai folder failed', err);
  }

  // è‹¥æ²¡æœ‰é¡¶çº§æ–‡ä»¶å¤¹ï¼Œå°è¯•å•æ–‡æ¡£ï¼ˆç›´æ¥ index.mdï¼‰
  const processOne = async (folderName) => {
    const folder = zip.folder(folderName);
    const mdFile = folder.file('index.md');
    if (!mdFile) return;
    const md = await mdFile.async('string');

    // å°è¯•è¯»å–meta.jsonè·å–åŸå§‹ID
    let originalId = null;
    let originalName = null;
    let originalVersion = 1;
    let originalUpdatedAt = null;
    try {
      const metaFile = folder.file('meta.json');
      if (metaFile) {
        const metaContent = await metaFile.async('string');
        const meta = JSON.parse(metaContent);
        originalId = meta.id;
        originalName = meta.name;
        originalVersion = meta.version || 1;
        originalUpdatedAt = meta.updatedAt;
        console.log('mw_importZip: ä»meta.jsonè¯»å–åˆ°åŸå§‹ID:', originalId, 'åç§°:', originalName, 'æ›´æ–°æ—¶é—´:', originalUpdatedAt);
      }
    } catch (err) {
      console.warn('mw_importZip: è¯»å–meta.jsonå¤±è´¥ï¼Œå°†ä½¿ç”¨æ–°ID:', err);
    }

    // åªåœ¨æœ‰å›¾ç‰‡æ–‡ä»¶æ—¶æ‰å¤„ç†å›¾ç‰‡ç›¸å…³é€»è¾‘
    let images = [];

    // ä»markdownå†…å®¹ä¸­æå–å›¾ç‰‡å¼•ç”¨ï¼Œå»ºç«‹å›¾ç‰‡IDåˆ°å›¾ç‰‡IDçš„æ˜ å°„ï¼ˆç”¨äºåç»­æŸ¥æ‰¾ï¼‰
    const imageIdMap = new Map();
    const imageRegex = /!\[([^\]]*)\]\(([^)]+)\)/g;
    let match;
    while ((match = imageRegex.exec(md)) !== null) {
      const imageName = match[1]; // å›¾ç‰‡åç§°
      const imageId = match[2]; // å›¾ç‰‡ID
      if (imageId && !imageId.match(/^(https?:\/\/|data:)/)) {
        // å»ºç«‹å›¾ç‰‡IDåˆ°è‡ªèº«çš„æ˜ å°„ï¼Œç”¨äºåç»­é€šè¿‡æ–‡ä»¶åï¼ˆä¸å«æ‰©å±•åï¼‰æŸ¥æ‰¾
        imageIdMap.set(imageId, imageId);
        console.log('mw_importZip: å‘ç°å›¾ç‰‡å¼•ç”¨', imageName, '->', imageId);
      }
    }

    // æ£€æŸ¥æ˜¯å¦æœ‰å›¾ç‰‡æ–‡ä»¶ï¼ˆä¸ä¾èµ–folderæ–¹æ³•ï¼Œç›´æ¥æ‰«ææ‰€æœ‰æ–‡ä»¶ï¼‰
    const imageFiles = [];
    const folderPrefix = folderName ? folderName : '';
    const imagesPrefix = folderPrefix + (folderPrefix.endsWith('/') ? '' : '/') + 'images/';

    // éå†zipä¸­çš„æ‰€æœ‰æ–‡ä»¶ï¼Œæ‰¾åˆ°å±äºå½“å‰æ–‡æ¡£çš„å›¾ç‰‡æ–‡ä»¶
    Object.values(zip.files).forEach(file => {
      if (file.dir) return;
      const fileName = file.name;
      if (fileName.startsWith(imagesPrefix)) {
        imageFiles.push(file);
        console.log('mw_importZip: å‘ç°å›¾ç‰‡æ–‡ä»¶', fileName);
      }
    });

    // å¦‚æœæœ‰å›¾ç‰‡æ–‡ä»¶ï¼Œæ‰è¿›è¡Œå¤„ç†
    if (imageFiles.length > 0) {
      for (const entry of imageFiles) {
        try {
          const fullName = entry.name || '';
          const mime = mw_guessMime(fullName);

          // åªå¤„ç†å›¾ç‰‡æ–‡ä»¶ï¼Œè¿‡æ»¤æ‰éå›¾ç‰‡æ–‡ä»¶ï¼ˆå¦‚meta.jsonã€index.mdç­‰ï¼‰
          if (!mime.startsWith('image/')) {
            console.log('mw_importZip: è·³è¿‡éå›¾ç‰‡æ–‡ä»¶', fullName);
            continue;
          }

          // entry æœ¬èº«å°±æ˜¯ JSZip çš„ file å¯¹è±¡ â€”â€” ç›´æ¥è°ƒç”¨å…¶ async æ–¹æ³•æ›´ç¨³å¥
          const ab = await entry.async('arraybuffer');
          // å°†arrayBufferè½¬æ¢ä¸ºDataURL
          const dataUrl = await window.imageStorage.blobToDataUrl(new Blob([ab], { type: mime }));
          // åªä¿ç•™æ–‡ä»¶åï¼Œä¸å¸¦è·¯å¾„
          const fname = fullName.split('/').pop() || fullName;

          // ä¼˜å…ˆä½¿ç”¨markdownä¸­å·²æœ‰çš„å›¾ç‰‡IDï¼Œé€šè¿‡æ–‡ä»¶åï¼ˆä¸å«æ‰©å±•åï¼‰åŒ¹é…
          const fileNameWithoutExt = fname.replace(/\.[^.]+$/, ''); // ç§»é™¤æ‰©å±•å
          let imageId = imageIdMap.get(fileNameWithoutExt);
          if (!imageId) {
            imageId = 'img_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            console.log('mw_importZip: ç”Ÿæˆæ–°å›¾ç‰‡ID', fname, '->', imageId);
          } else {
            console.log('mw_importZip: ä½¿ç”¨ç°æœ‰å›¾ç‰‡ID', fname, '->', imageId);
          }

          // å°†å›¾ç‰‡ä¿å­˜åˆ°IndexedDBï¼Œåªåœ¨æ–‡æ¡£ä¸­ä¿å­˜åŸºæœ¬ä¿¡æ¯
          if (window.imageStorage) {
            try {
              // å°†dataUrlè½¬æ¢ä¸ºBlob
              const blob = await window.imageStorage.dataUrlToBlob(dataUrl);

              // è·å–å½“å‰æ–‡æ¡£ID
              const docId = originalId || ('doc_' + Date.now() + '_' + Math.floor(Math.random() * 1000));

              await window.imageStorage.saveImage(imageId, blob, {
                name: fname,
                type: mime,
                documentId: docId
              });
              console.log('mw_importZip: å›¾ç‰‡å·²ä¿å­˜åˆ°IndexedDB', imageId);
            } catch (error) {
              console.warn('mw_importZip: ä¿å­˜å›¾ç‰‡åˆ°IndexedDBå¤±è´¥', imageId, error);
            }
          }

          // åªåœ¨æ–‡æ¡£ä¸­ä¿å­˜å›¾ç‰‡åŸºæœ¬ä¿¡æ¯ï¼Œä¸ä¿å­˜dataUrl
          images.push({ id: imageId, name: fname, mime });
        } catch (err) {
          console.warn('mw_importZip: è¯»å–å›¾ç‰‡æ¡ç›®å¤±è´¥ï¼Œå·²è·³è¿‡', entry && entry.name, err);
        }
      }
    }
    // AIé…ç½®ä¿¡æ¯ä¸åº”è¯¥å­˜å‚¨åœ¨å•ä¸ªæ–‡æ¡£ä¸­ï¼Œå®ƒä»¬æ˜¯å…¨å±€é…ç½®
    // ä»ä¸Šå±‚é¢„è¯»å–çš„ rootAiCfg / rootTpl ç›´æ¥å¤ç”¨ï¼ˆé¿å…æŸ¥æ‰¾å·²è¢«ç§»é™¤çš„å­æ–‡ä»¶å¤¹ï¼‰
    let aiCfg = rootAiCfg;
    let tpl = rootTpl;
    // è¯´æ˜ï¼šæ—§çš„å­æ–‡ä»¶å¤¹å…¼å®¹é€»è¾‘å·²å¼ƒç”¨ï¼Œæ•…ä¸å†å°è¯• folder.folder('ai')ï¼Œä»¥é¿å…è¦†ç›–æˆ–è¯»å–å¤±è´¥ã€‚
    const safeName = originalName || folderName.replace(/\/$/, '').replace(/[\\/:*?"<>|]+/g, '_');

    // IDå†²çªæ£€æµ‹å’Œå¤„ç†
    let finalId = originalId || ('doc_' + Date.now() + '_' + Math.floor(Math.random() * 1000));
    let finalName = safeName || 'å¯¼å…¥æ–‡æ¡£';
    let finalUpdatedAt = Date.now();

    if (originalId) {
      // æ£€æŸ¥æœ¬åœ°æ˜¯å¦å·²å­˜åœ¨ç›¸åŒIDçš„æ–‡æ¡£
      const existingDoc = docs.find(d => d.id === originalId);
      if (existingDoc) {
        // å‘ç°IDå†²çª
        if (conflictResolution === null) {
          // ç¬¬ä¸€æ¬¡å‘ç°å†²çªï¼Œæ˜¾ç¤ºé€‰æ‹©å¯¹è¯æ¡†
          conflicts.push({
            id: originalId,
            localName: existingDoc.name,
            importName: safeName,
            localTime: existingDoc.updatedAt || 0,
            importTime: originalUpdatedAt || Date.now()
          });
          conflictResolution = await showImportConflictDialog(conflicts);
        }

        // æ ¹æ®ç”¨æˆ·é€‰æ‹©å¤„ç†å†²çª
        switch (conflictResolution) {
          case 'keep_latest':
            // ä¿ç•™æœ€æ–°çš„ï¼ˆæ¯”è¾ƒupdatedAtï¼‰
            const existingTime = existingDoc.updatedAt || 0;
            const importTime = originalUpdatedAt || Date.now();
            if (importTime > existingTime) {
              // å¯¼å…¥çš„æ–‡æ¡£æ›´æ–°ï¼Œæ›¿æ¢ç°æœ‰æ–‡æ¡£
              console.log('mw_importZip: ä¿ç•™æœ€æ–°æ–‡æ¡£ï¼Œæ›¿æ¢ç°æœ‰æ–‡æ¡£:', originalId);
              // ç§»é™¤ç°æœ‰æ–‡æ¡£ï¼Œä½¿ç”¨å¯¼å…¥çš„æ–‡æ¡£
              docs.splice(docs.indexOf(existingDoc), 1);
            } else {
              // ç°æœ‰æ–‡æ¡£æ›´æ–°ï¼Œè·³è¿‡å¯¼å…¥
              console.log('mw_importZip: ç°æœ‰æ–‡æ¡£æ›´æ–°ï¼Œè·³è¿‡å¯¼å…¥:', originalId);
              return;
            }
            break;

          case 'replace':
            // æ›¿æ¢ä¸ºå¯¼å…¥çš„æ–‡æ¡£
            console.log('mw_importZip: æ›¿æ¢ä¸ºå¯¼å…¥æ–‡æ¡£:', originalId);
            docs.splice(docs.indexOf(existingDoc), 1);
            break;

          case 'create_new':
            // åˆ›å»ºæ–°ID
            finalId = 'doc_' + Date.now() + '_' + Math.floor(Math.random() * 1000);
            finalName = (safeName || 'å¯¼å…¥æ–‡æ¡£') + '_å‰¯æœ¬';
            console.log('mw_importZip: åˆ›å»ºæ–°IDæ–‡æ¡£:', finalId, 'åç§°:', finalName);
            break;

          default:
            // é»˜è®¤è·³è¿‡
            console.log('mw_importZip: é»˜è®¤è·³è¿‡å†²çªæ–‡æ¡£:', originalId);
            return;
        }
      }
    }

    // åˆ›å»ºæ–‡æ¡£å¯¹è±¡ï¼Œä¸å†åŒ…å«AIé…ç½®ä¿¡æ¯ï¼ˆå®ƒä»¬åº”è¯¥å­˜å‚¨åœ¨ç‹¬ç«‹çš„localStorageé”®ä¸­ï¼‰
    const newDoc = {
      id: finalId,
      name: finalName,
      md,
      images,
      createdAt: Date.now(),
      updatedAt: finalUpdatedAt,
      version: originalVersion
    };
    docs.push(newDoc);
  };

  if (topFolders.length) {
    for (const folderName of topFolders) { await processOne(folderName); }
  } else {
    // å°è¯•æ ¹çº§ index.md
    const mdFile = zip.file('index.md');
    if (mdFile) await processOne('');
  }

  mw_saveDocs(docs);
  mw_renderList();
  try { showSuccess && showSuccess('ZIP å¯¼å…¥å®Œæˆ'); } catch (_) { }

  // å¦‚æœè§£æåˆ°äº†æ ¹çº§ AI é…ç½®ï¼Œåˆ™å†™å…¥é¢æ¿æœŸæœ›çš„ localStorage å¹¶å°è¯•åˆ·æ–° AI é¢æ¿
  try {
    if (rootAiCfg) {
      try { localStorage.setItem('allAIPlatformConfigs', JSON.stringify(rootAiCfg)); } catch (e) { console.warn('[mw_importZip] write allAIPlatformConfigs failed', e); }
    }
    // ä¸å†å¯¼å…¥æ—§çš„prompt-templates.jsonï¼Œåªå¯¼å…¥ç”¨æˆ·è‡ªå®šä¹‰çš„my-prompt-templates.json
    // if (rootTpl) {
    //     try { localStorage.setItem('promptTemplates', JSON.stringify(rootTpl)); } catch (e) { console.warn('[mw_importZip] write promptTemplates failed', e); }
    // }

    // å°è¯•åˆ·æ–°åŒæºçš„ aiModalFrameï¼ˆå¦‚æœå¯è®¿é—®ï¼‰
    try {
      var af = document.getElementById('aiModalFrame');
      if (af && af.contentWindow) {
        try {
          af.contentWindow.populateSavedPlatformsList && af.contentWindow.populateSavedPlatformsList();
          af.contentWindow.populateUsagePlatforms && af.contentWindow.populateUsagePlatforms();
          af.contentWindow.populateTemplateSelect && af.contentWindow.populateTemplateSelect();
        } catch (e) { console.warn('[mw_importZip] refresh aiModalFrame failed', e); }
      } else {
        // å›é€€ï¼šå‘é€ postMessageï¼Œç”± AI é¢æ¿ç›‘å¬å¹¶è‡ªè¡Œå†™å…¥/åˆ·æ–°ï¼ˆè‹¥å·²å®ç°ç›‘å¬ï¼‰
        // ä¸å†å‘é€æ—§çš„templatesæ•°æ®ï¼Œåªå‘é€configs
        window.postMessage({ type: 'IMPORT_AI_FROM_ZIP', payload: { configs: rootAiCfg, templates: null } }, '*');
      }
    } catch (e) { console.warn('[mw_importZip] notify ai panel failed', e); }
  } catch (e) {
    console.warn('[mw_importZip] write ai configs failed', e);
  }
}

// ===== è¾…åŠ©å‡½æ•° =====
// åˆ¤æ–­æ–‡æ¡£æ˜¯å¦æ˜¯è‡ªåŠ¨ç”Ÿæˆçš„ç©ºæ–‡æ¡£ï¼ˆæ²¡æœ‰çœŸå®å­èŠ‚ç‚¹ï¼‰
function isAutoGeneratedEmptyDoc(doc) {
  if (!doc) return false;

  // æ£€æŸ¥åç§°æ˜¯å¦ä¸ºé»˜è®¤çš„"æœªå‘½åæ–‡æ¡£"
  const name = doc.name || '';
  if (name !== 'æœªå‘½åæ–‡æ¡£') return false;

  // æ£€æŸ¥å†…å®¹æ˜¯å¦ä¸ºé»˜è®¤çš„"# æœªå‘½åæ–‡æ¡£\n"
  const md = doc.md || '';
  if (md.trim() !== '# æœªå‘½åæ–‡æ¡£') return false;

  // æ£€æŸ¥æ˜¯å¦æœ‰å›¾ç‰‡ï¼ˆç©ºæ–‡æ¡£ä¸åº”è¯¥æœ‰å›¾ç‰‡ï¼‰
  if (doc.images && doc.images.length > 0) return false;

  return true;
}

function mw_extractTitleFromMd(md) {
  try {
    const lines = String(md || '').split(/\r?\n/);
    const first = (lines.find(l => l.trim().length > 0) || '').trim();
    if (!first) return 'æœªå‘½åæ–‡æ¡£';
    const cleaned = first
      .replace(/^#{1,6}\s*/, '')
      .replace(/^[-*+]\s+/, '')
      .replace(/^\d+\.\s+/, '')
      .trim();
    return cleaned || 'æœªå‘½åæ–‡æ¡£';
  } catch (_) { return 'æœªå‘½åæ–‡æ¡£'; }
}
function mw_guessMime(name) {
  const lower = (name || '').toLowerCase();
  if (lower.endsWith('.png')) return 'image/png';
  if (lower.endsWith('.jpg') || lower.endsWith('.jpeg')) return 'image/jpeg';
  if (lower.endsWith('.gif')) return 'image/gif';
  if (lower.endsWith('.webp')) return 'image/webp';
  return 'application/octet-stream';
}
function mw_fetchAIPlatformConfigsSnapshot() {
  try {
    const frame = document.getElementById('aiModalFrame');
    const ls = frame && frame.contentWindow && frame.contentWindow.localStorage;
    if (!ls) return null;
    const raw = ls.getItem('allAIPlatformConfigs');
    if (!raw) return null;
    const json = JSON.parse(raw);
    return json;
  } catch (_) { return null; }
}
function mw_fetchAIPromptTemplatesSnapshot() {
  try {
    return window.__prompt_templates || null;
  } catch (_) { return null; }
}

// ===== ZIPå¯¼å…¥å†²çªå¤„ç†ç›¸å…³å‡½æ•° =====
// æ˜¾ç¤ºIDå†²çªé€‰æ‹©å¯¹è¯æ¡†
async function showImportConflictDialog(conflicts) {
  if (!conflicts || conflicts.length === 0) return 'keep_latest';

  return new Promise((resolve) => {
    const conflictList = conflicts.map(conflict =>
      `æ–‡æ¡£ï¼š${conflict.importName}\n` +
      `æ–‡æ¡£IDï¼š${conflict.id}\n` +
      `æœ¬åœ°ä¿®æ”¹æ—¶é—´ï¼š${new Date(conflict.localTime).toLocaleString()}\n` +
      `å¯¼å…¥ä¿®æ”¹æ—¶é—´ï¼š${new Date(conflict.importTime).toLocaleString()}\n`
    ).join('\n---\n\n');

    const message = `æ£€æµ‹åˆ°æ–‡æ¡£å†²çªï¼š\n\n${conflictList}\n` +
      'è¯·é€‰æ‹©å¤„ç†æ–¹å¼ï¼š\n\n' +
      'ã€ä¿ç•™æœ€æ–°çš„ã€‘ä¿ç•™ä¿®æ”¹æ—¶é—´è¾ƒæ–°çš„æ–‡æ¡£ï¼ˆæ¨èï¼‰\n' +
      'ã€æ›¿æ¢ä¸ºå¯¼å…¥çš„ã€‘ç”¨å¯¼å…¥çš„æ–‡æ¡£å®Œå…¨æ›¿æ¢ç°æœ‰æ–‡æ¡£\n' +
      'ã€å¦å¤–åˆ›å»ºã€‘ä¸ºå¯¼å…¥çš„æ–‡æ¡£ç”Ÿæˆæ–°IDï¼Œä¿ç•™ä¸¤ä»½æ–‡æ¡£\n\n' +
      'æ³¨æ„ï¼šæ‚¨çš„é€‰æ‹©å°†åº”ç”¨äºæœ¬æ¬¡å¯¼å…¥çš„æ‰€æœ‰å†²çªæ–‡æ¡£ã€‚';

    // åˆ›å»ºè‡ªå®šä¹‰å¯¹è¯æ¡†
    const dialog = document.createElement('div');
    dialog.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0,0,0,0.5);
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    z-index: 10000;
                    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                `;

    const content = document.createElement('div');
    content.style.cssText = `
                    background: white;
                    border-radius: 8px;
                    padding: 24px;
                    max-width: 600px;
                    max-height: 80vh;
                    overflow-y: auto;
                    box-shadow: 0 10px 25px rgba(0,0,0,0.2);
                    border: 1px solid #e5e7eb;
                `;

    const title = document.createElement('h3');
    title.textContent = 'æ–‡æ¡£å¯¼å…¥å†²çªå¤„ç†';
    title.style.cssText = `
                    margin: 0 0 16px 0;
                    color: #1f2937;
                    font-size: 18px;
                    font-weight: 600;
                `;

    const messageDiv = document.createElement('div');
    messageDiv.style.cssText = `
                    white-space: pre-line;
                    margin-bottom: 24px;
                    color: #4b5563;
                    font-size: 14px;
                    line-height: 1.5;
                `;
    messageDiv.textContent = message;

    const buttonContainer = document.createElement('div');
    buttonContainer.style.cssText = `
                    display: flex;
                    gap: 12px;
                    justify-content: flex-end;
                    margin-top: 20px;
                `;

    const createButton = (text, value, isPrimary = false) => {
      const btn = document.createElement('button');
      btn.textContent = text;
      btn.style.cssText = `
                        padding: 8px 16px;
                        border: 1px solid ${isPrimary ? '#3b82f6' : '#d1d5db'};
                        background: ${isPrimary ? '#3b82f6' : 'white'};
                        color: ${isPrimary ? 'white' : '#374151'};
                        border-radius: 6px;
                        font-size: 14px;
                        cursor: pointer;
                        transition: all 0.2s;
                        font-weight: 500;
                    `;
      btn.onmouseover = () => {
        btn.style.background = isPrimary ? '#2563eb' : '#f9fafb';
        btn.style.borderColor = isPrimary ? '#2563eb' : '#9ca3af';
      };
      btn.onmouseout = () => {
        btn.style.background = isPrimary ? '#3b82f6' : 'white';
        btn.style.borderColor = isPrimary ? '#3b82f6' : '#d1d5db';
      };
      btn.onclick = () => {
        document.body.removeChild(dialog);
        resolve(value);
      };
      return btn;
    };

    // åˆ›å»ºä¸‰ä¸ªæŒ‰é’®
    const keepLatestBtn = createButton('ä¿ç•™æœ€æ–°çš„', 'keep_latest', true);
    const replaceBtn = createButton('æ›¿æ¢ä¸ºå¯¼å…¥çš„', 'replace');
    const createNewBtn = createButton('å¦å¤–åˆ›å»º', 'create_new');

    buttonContainer.appendChild(createNewBtn);
    buttonContainer.appendChild(replaceBtn);
    buttonContainer.appendChild(keepLatestBtn);

    content.appendChild(title);
    content.appendChild(messageDiv);
    content.appendChild(buttonContainer);
    dialog.appendChild(content);

    document.body.appendChild(dialog);

    // ç‚¹å‡»èƒŒæ™¯å…³é—­å¯¹è¯æ¡†ï¼ˆé»˜è®¤é€‰æ‹©ä¿ç•™æœ€æ–°çš„ï¼‰
    dialog.onclick = (e) => {
      if (e.target === dialog) {
        document.body.removeChild(dialog);
        resolve('keep_latest');
      }
    };

    // ESCé”®å…³é—­å¯¹è¯æ¡†
    const handleEscape = (e) => {
      if (e.key === 'Escape') {
        document.body.removeChild(dialog);
        document.removeEventListener('keydown', handleEscape);
        resolve('keep_latest');
      }
    };
    document.addEventListener('keydown', handleEscape);
  });
}

// å¤„ç†å•ä¸ªæ–‡æ¡£çš„IDå†²çª
function resolveDocIdConflict(existingDoc, importDoc, resolution) {
  switch (resolution) {
    case 'keep_latest':
      // ä¿ç•™ä¿®æ”¹æ—¶é—´è¾ƒæ–°çš„æ–‡æ¡£
      if (Number(existingDoc.updatedAt) >= Number(importDoc.updatedAt)) {
        return { action: 'skip', doc: existingDoc };
      } else {
        return { action: 'replace', doc: importDoc };
      }
    case 'replace':
      // æ€»æ˜¯ç”¨å¯¼å…¥çš„æ–‡æ¡£æ›¿æ¢
      return { action: 'replace', doc: importDoc };
    case 'create_new':
      // ä¸ºå¯¼å…¥æ–‡æ¡£ç”Ÿæˆæ–°ID
      const newDoc = { ...importDoc };
      newDoc.id = 'doc_' + Date.now() + '_' + Math.floor(Math.random() * 1000);
      return { action: 'create', doc: newDoc };
    default:
      return { action: 'skip', doc: existingDoc };
  }
}

// ===== æ¸…ç©ºæ‰€æœ‰æœ¬åœ°æ•°æ® =====
async function mw_clearAllData() {
  if (confirm('âš ï¸ è­¦å‘Šï¼šæ­¤æ“ä½œå°†æ°¸ä¹…åˆ é™¤æ‰€æœ‰æœ¬åœ°æ•°æ®ï¼\n\nç¡®è®¤è¦æ¸…ç©ºä»¥ä¸‹æ•°æ®å—ï¼Ÿ\nâ€¢ æ‰€æœ‰æ–‡æ¡£æ•°æ®\nâ€¢ AIå¹³å°é…ç½®\nâ€¢ æç¤ºè¯æ¨¡æ¿\nâ€¢ ç¼–è¾‘å™¨è®¾ç½®\nâ€¢ æ‰€æœ‰å›¾ç‰‡æ•°æ®\n\næ­¤æ“ä½œä¸å¯æ¢å¤ï¼Œå»ºè®®å…ˆå¯¼å‡ºå¤‡ä»½ã€‚')) {
    try {
      // æ¸…ç©ºæ‰€æœ‰localStorageæ•°æ®
      localStorage.clear();

      // æ¸…ç©ºIndexedDBä¸­çš„æ‰€æœ‰å›¾ç‰‡
      if (window.imageStorage) {
        await window.imageStorage.clearAllImages();
      }

      // é‡æ–°åˆå§‹åŒ–å¿…è¦çš„æ•°æ®ç»“æ„
      localStorage.setItem('mindword_docs', '[]');
      localStorage.setItem('mw_active_doc', '');

      // åˆ·æ–°ç•Œé¢
      mw_renderList();

      // é€šçŸ¥ç¼–è¾‘å™¨æ¸…ç©ºå†…å®¹
      window.postMessage({ type: 'mw_apply_markdown', payload: { md: '', images: [] } }, '*');

      // æ˜¾ç¤ºæˆåŠŸæ¶ˆæ¯
      try { showSuccess && showSuccess('æ‰€æœ‰æœ¬åœ°æ•°æ®å·²æ¸…ç©º'); } catch (_) { }

      console.log('æ‰€æœ‰æœ¬åœ°æ•°æ®å·²æ¸…ç©º');
    } catch (error) {
      console.error('æ¸…ç©ºæ•°æ®å¤±è´¥:', error);
      try { showError && showError('æ¸…ç©ºæ•°æ®å¤±è´¥: ' + error.message); } catch (_) { }
    }
  }
}

// ===== äº‹ä»¶ç»‘å®š =====
(function initDocSidebar() {
  const btn = document.getElementById('doc-menu-btn');
  const closeBtn = document.getElementById('btn-close-sidebar');
  const newBtn = document.getElementById('btn-new-doc');
  const exportAllBtn = document.getElementById('btn-export-all');
  const importInput = document.getElementById('import-zip-input');
  const importBtn = document.getElementById('btn-import-zip');
  const clearDataBtn = document.getElementById('btn-clear-data');
  const batchModeBtn = document.getElementById('btn-batch-mode');
  const batchSelectAllBtn = document.getElementById('btn-batch-select-all');
  const batchSelectNoneBtn = document.getElementById('btn-batch-select-none');
  const batchDeleteBtn = document.getElementById('btn-batch-delete');
  const batchCancelBtn = document.getElementById('btn-batch-cancel');
  const sidebar = document.getElementById('doc-sidebar');

  btn && (btn.onclick = () => { mw_toggleSidebar(); mw_renderList(); });
  closeBtn && (closeBtn.onclick = () => mw_toggleSidebar(false));
  newBtn && (newBtn.onclick = () => mw_newDoc());
  exportAllBtn && (exportAllBtn.onclick = () => mw_exportAllZip());
  importBtn && (importBtn.onclick = () => importInput && importInput.click());
  importInput && importInput.addEventListener('change', (e) => {
    const f = e.target.files && e.target.files[0];
    if (f) mw_importZip(f);
    e.target.value = '';
  });
  clearDataBtn && (clearDataBtn.onclick = () => mw_clearAllData());
  batchModeBtn && (batchModeBtn.onclick = () => mw_enterBatchMode());
  batchSelectAllBtn && (batchSelectAllBtn.onclick = () => mw_selectAllDocs());
  batchSelectNoneBtn && (batchSelectNoneBtn.onclick = () => mw_selectNoneDocs());
  batchDeleteBtn && (batchDeleteBtn.onclick = () => mw_batchDeleteDocs());
  batchCancelBtn && (batchCancelBtn.onclick = () => mw_exitBatchMode());

  // ä¾§æ»‘æ å¤±å»ç„¦ç‚¹æ—¶è‡ªåŠ¨æ”¶èµ·
  if (sidebar) {
    sidebar.addEventListener('blur', function (e) {
      // æ£€æŸ¥æ–°çš„ç„¦ç‚¹å…ƒç´ æ˜¯å¦åœ¨ä¾§æ»‘æ å†…éƒ¨
      setTimeout(() => {
        const activeElement = document.activeElement;
        const isFocusInsideSidebar = sidebar.contains(activeElement);
        const isFocusOnMenuBtn = activeElement === btn;

        // å¦‚æœç„¦ç‚¹ä¸åœ¨ä¾§æ»‘æ å†…ä¸”ä¸åœ¨èœå•æŒ‰é’®ä¸Šï¼Œåˆ™æ”¶èµ·ä¾§æ»‘æ 
        if (!isFocusInsideSidebar && !isFocusOnMenuBtn) {
          mw_toggleSidebar(false);
        }
      }, 0);
    });

    // ä¸ºä¾§æ»‘æ å†…çš„å¯äº¤äº’å…ƒç´ æ·»åŠ ç„¦ç‚¹ç®¡ç†
    sidebar.addEventListener('focusin', function (e) {
      // å½“ä¾§æ»‘æ å†…è·å¾—ç„¦ç‚¹æ—¶ï¼Œç¡®ä¿ä¾§æ»‘æ ä¿æŒæ‰“å¼€çŠ¶æ€
      if (!sidebar.classList.contains('open')) {
        mw_toggleSidebar(true);
      }
    });
  }

  // ç‚¹å‡»å¤–éƒ¨åŒºåŸŸï¼ˆåŒ…æ‹¬iframeï¼‰è‡ªåŠ¨æ”¶èµ·ä¾§æ»‘æ 
  function setupClickOutsideHandler() {
    let isProcessingClick = false;

    // å¤„ç†ç‚¹å‡»äº‹ä»¶
    function handleClickOutside(event) {
      if (isProcessingClick) return;

      const sidebar = document.getElementById('doc-sidebar');
      const menuBtn = document.getElementById('doc-menu-btn');

      if (!sidebar || !sidebar.classList.contains('open')) return;

      // æ£€æŸ¥ç‚¹å‡»æ˜¯å¦åœ¨ä¾§æ»‘æ å†…éƒ¨æˆ–èœå•æŒ‰é’®ä¸Š
      const isClickInsideSidebar = sidebar.contains(event.target);
      const isClickOnMenuBtn = menuBtn && (event.target === menuBtn || menuBtn.contains(event.target));

      if (!isClickInsideSidebar && !isClickOnMenuBtn) {
        isProcessingClick = true;
        mw_toggleSidebar(false);
        setTimeout(() => { isProcessingClick = false; }, 100);
      }
    }

    // å¤„ç†çª—å£å¤±ç„¦äº‹ä»¶ï¼ˆå¤„ç†iframeç‚¹å‡»ï¼‰
    function handleWindowBlur() {
      const sidebar = document.getElementById('doc-sidebar');
      if (sidebar && sidebar.classList.contains('open')) {
        // å»¶è¿Ÿæ£€æŸ¥ï¼Œç¡®ä¿iframeç‚¹å‡»è¢«æ•è·
        setTimeout(() => {
          mw_toggleSidebar(false);
        }, 50);
      }
    }

    // ç»‘å®šäº‹ä»¶
    document.addEventListener('click', handleClickOutside, true);
    window.addEventListener('blur', handleWindowBlur);

    // è¿”å›æ¸…ç†å‡½æ•°
    return function cleanup() {
      document.removeEventListener('click', handleClickOutside, true);
      window.removeEventListener('blur', handleWindowBlur);
    };
  }

  // åˆå§‹åŒ–ç‚¹å‡»å¤–éƒ¨åŒºåŸŸå¤„ç†
  const cleanupClickHandler = setupClickOutsideHandler();

  // é¡µé¢å¸è½½æ—¶æ¸…ç†äº‹ä»¶ç›‘å¬
  window.addEventListener('beforeunload', cleanupClickHandler);

  // åˆå§‹æ¸²æŸ“ä¸€æ¬¡ï¼ˆä¸å¼ºåˆ¶æ‰“å¼€ï¼‰
  mw_renderList();
})();

// ç›‘å¬æ¥è‡ªç¼–è¾‘å™¨çš„æ–‡æ¡£æ›´æ–°æ¶ˆæ¯
window.addEventListener('message', function (e) {
  const msg = e && e.data;
  if (!msg || typeof msg !== 'object') return;

  // 1. ç¼–è¾‘å™¨å†…å®¹å˜æ›´åŒæ­¥ (ä¿®å¤å›¾ç‰‡ä¸¢å¤±å’Œå¯¼å‡ºæ— å›¾ç‰‡çš„æ ¸å¿ƒ)
  // å½“ editor.html æ‰§è¡Œ saveToStorage æ—¶ä¼šå‘é€æ­¤æ¶ˆæ¯
  if (msg.type === 'mw_document_changed') {
    const payload = msg.payload || {};
    // è·å–ç›®æ ‡æ–‡æ¡£IDï¼Œä¼˜å…ˆä½¿ç”¨payloadé‡Œçš„IDï¼Œå¦åˆ™ä½¿ç”¨å½“å‰æ´»åŠ¨ID
    const targetId = payload.id || mw_getActive();

    if (targetId) {
      const docs = mw_loadDocs();
      const idx = docs.findIndex(d => d.id === targetId);

      if (idx >= 0) {
        // æ›´æ–°ä¸»æ•°æ®åº“ä¸­çš„æ–‡æ¡£æ•°æ®
        docs[idx].md = payload.md;

        // å…³é”®ï¼šåŒæ­¥å›¾ç‰‡æ•°æ®åˆ°IndexedDB
        if (window.imageStorage && Array.isArray(payload.images)) {
          // å°†å›¾ç‰‡æ•°æ®ä¿å­˜åˆ°IndexedDB
          const imagesMap = new Map();
          payload.images.forEach(img => {
            if (img.id && img.dataUrl) {
              imagesMap.set(img.id, {
                id: img.id,
                name: img.name,
                mime: img.mime,
                dataUrl: img.dataUrl
              });
            }
          });

          if (imagesMap.size > 0) {
            // ä¸ºæ¯ä¸ªå›¾ç‰‡æ·»åŠ æ–‡æ¡£IDå¹¶è½¬æ¢æ•°æ®æ ¼å¼
            const imagesWithDocId = new Map();
            for (const [id, imageData] of imagesMap.entries()) {
              imagesWithDocId.set(id, {
                id: imageData.id,
                name: imageData.name,
                type: imageData.mime,  // å°† mime è½¬æ¢ä¸º type
                data: imageData.dataUrl, // å°† dataUrl è½¬æ¢ä¸º data
                documentId: targetId
              });
            }
            window.imageStorage.saveImages(imagesWithDocId).catch(error => {
              console.warn('ä¿å­˜å›¾ç‰‡åˆ°IndexedDBå¤±è´¥:', error);
            });
          }
        }

        // æ›´æ–°æ–‡æ¡£ä¸­çš„å›¾ç‰‡å¼•ç”¨ï¼ˆåªä¿ç•™åŸºæœ¬ä¿¡æ¯ï¼Œä¸å­˜å‚¨dataUrlï¼‰
        docs[idx].images = Array.isArray(payload.images) ? payload.images.map(img => ({
          id: img.id,
          name: img.name,
          mime: img.mime
        })) : [];

        docs[idx].updatedAt = Date.now();

        // å¦‚æœç‰ˆæœ¬å·å­˜åœ¨åˆ™æ›´æ–°
        if (payload.rev) {
          docs[idx].version = payload.rev;
        }

        // å°è¯•æ›´æ–°æ–‡æ¡£æ ‡é¢˜ï¼ˆå¦‚æœå†…å®¹å˜äº†ï¼‰
        const newName = mw_extractTitleFromMd(payload.md);
        if (newName && docs[idx].name !== newName) {
          docs[idx].name = newName;
        }

        mw_saveDocs(docs);

        // å¦‚æœå¤„äºéæ‰¹é‡æ¨¡å¼ï¼Œåˆ·æ–°åˆ—è¡¨ä»¥æ›´æ–°æ ‡é¢˜æˆ–é€‰ä¸­çŠ¶æ€
        const isBatchMode = document.getElementById('batch-actions').classList.contains('show');
        if (!isBatchMode) {
          mw_renderList();
        }

        console.log(`[SYNC] æ–‡æ¡£ ${targetId} å·²åŒæ­¥è‡³ä¸»æ•°æ®åº“ (å« ${docs[idx].images.length} å¼ å›¾ç‰‡)`);
      }
    }
    return;
  }

  // 2. ç¼–è¾‘å™¨è¯·æ±‚å½“å‰æ´»åŠ¨æ–‡æ¡£ï¼ˆå¦‚ç¼–è¾‘å™¨iframeåˆ·æ–°åï¼‰
  if (msg.type === 'mw_request_active') {
    const activeId = mw_getActive();
    if (!activeId) return;
    const docs = mw_loadDocs();
    const doc = docs.find(d => d.id === activeId);
    if (doc) mw_notifyEditorLoad(doc);
    return;
  }

  // 3. æ¥è‡ª AI æˆ–å…¶ä»–æ’ä»¶çš„ "åº”ç”¨ Markdown" è¯·æ±‚
  // æ•ˆæœï¼šç«‹å³æ›´æ–°æœ¬åœ°æ–‡æ¡£åº“å¹¶åŒæ—¶å¹¿æ’­ç»™ editor / preview / mindmap
  if (msg.type === 'mw_apply_markdown') {
    try {
      const payload = msg.payload || {};
      const md = typeof payload.md === 'string' ? payload.md : '';
      const images = Array.isArray(payload.images) ? payload.images : [];
      let docs = mw_loadDocs();
      const activeId = mw_getActive();

      if (activeId) {
        const idx = docs.findIndex(d => d.id === activeId);
        if (idx >= 0) {
          // è¦†ç›–å½“å‰æ´»åŠ¨æ–‡æ¡£
          docs[idx].md = md;

          // åŒæ­¥å›¾ç‰‡æ•°æ®åˆ°IndexedDB
          if (window.imageStorage && Array.isArray(images)) {
            const imagesMap = new Map();
            images.forEach(img => {
              if (img.id && img.dataUrl) {
                imagesMap.set(img.id, {
                  id: img.id,
                  name: img.name,
                  mime: img.mime,
                  dataUrl: img.dataUrl
                });
              }
            });

            if (imagesMap.size > 0) {
              // ä¸ºæ¯ä¸ªå›¾ç‰‡æ·»åŠ æ–‡æ¡£ID
              const imagesWithDocId = new Map();
              for (const [id, imageData] of imagesMap.entries()) {
                imagesWithDocId.set(id, {
                  id: imageData.id,
                  name: imageData.name,
                  type: imageData.mime,  // å°† mime è½¬æ¢ä¸º type
                  data: imageData.dataUrl, // å°† dataUrl è½¬æ¢ä¸º data
                  documentId: docs[idx].id
                });
              }
              window.imageStorage.saveImages(imagesWithDocId).catch(error => {
                console.warn('ä¿å­˜å›¾ç‰‡åˆ°IndexedDBå¤±è´¥:', error);
              });
            }
          }

          // æ›´æ–°æ–‡æ¡£ä¸­çš„å›¾ç‰‡å¼•ç”¨ï¼ˆåªä¿ç•™åŸºæœ¬ä¿¡æ¯ï¼‰
          docs[idx].images = Array.isArray(images) ? images.map(img => ({
            id: img.id,
            name: img.name,
            mime: img.mime
          })) : [];

          docs[idx].updatedAt = Date.now();
          docs[idx].version = (Number(docs[idx].version || 1) + 1);

          const newName = mw_extractTitleFromMd(md);
          if (newName && docs[idx].name !== newName) docs[idx].name = newName;

          mw_saveDocs(docs);
          mw_renderList();

          const doc = docs[idx];
          // å¹¿æ’­åˆ°ä¸‰ç«¯
          mw_notifyEditorLoad(doc);
          mw_notifyPreviewLoad(doc);
          mw_notifyMindmapLoad(doc);
          try { showSuccess && showSuccess('æ–‡æ¡£å·²æ›´æ–°'); } catch (_) { }
          return;
        }
      }

      // æ— æ´»åŠ¨æ–‡æ¡£ï¼šåˆ›å»ºæ–°æ–‡æ¡£
      const newId = 'doc_' + Date.now();
      const name = mw_extractTitleFromMd(md || '');

      // åŒæ­¥å›¾ç‰‡æ•°æ®åˆ°IndexedDB
      if (window.imageStorage && Array.isArray(images)) {
        const imagesMap = new Map();
        images.forEach(img => {
          if (img.id && img.dataUrl) {
            imagesMap.set(img.id, {
              id: img.id,
              name: img.name,
              mime: img.mime,
              dataUrl: img.dataUrl
            });
          }
        });

        if (imagesMap.size > 0) {
          // ä¸ºæ¯ä¸ªå›¾ç‰‡æ·»åŠ æ–°æ–‡æ¡£ID
          const imagesWithDocId = new Map();
          for (const [id, imageData] of imagesMap.entries()) {
            imagesWithDocId.set(id, {
              id: imageData.id,
              name: imageData.name,
              type: imageData.mime,  // å°† mime è½¬æ¢ä¸º type
              data: imageData.dataUrl, // å°† dataUrl è½¬æ¢ä¸º data
              documentId: newId
            });
          }
          window.imageStorage.saveImages(imagesWithDocId).catch(error => {
            console.warn('ä¿å­˜å›¾ç‰‡åˆ°IndexedDBå¤±è´¥:', error);
          });
        }
      }

      const doc = {
        id: newId,
        name,
        md: md || ('# ' + name + '\n'),
        images: Array.isArray(images) ? images.map(img => ({
          id: img.id,
          name: img.name,
          mime: img.mime
        })) : [],
        createdAt: Date.now(),
        updatedAt: Date.now(),
        version: 1
      };
      docs.push(doc);
      mw_saveDocs(docs);
      mw_setActive(newId);
      mw_renderList();

      mw_notifyEditorLoad(doc);
      try { showSuccess && showSuccess('å·²åˆ›å»ºæ–°æ–‡æ¡£å¹¶åº”ç”¨'); } catch (_) { }
      return;
    } catch (err) {
      console.warn('[INDEX] mw_apply_markdown failed', err);
    }
  }

}, { passive: true });

// ===== ç›‘å¬localStorageä¸­markdownæ•°æ®å˜åŒ–ï¼Œè‡ªåŠ¨æ›´æ–°æ–‡æ¡£æ ‡é¢˜ =====
let lastMarkdownData = localStorage.getItem('mindword_markdown_data');
let lastActiveDocId = mw_getActive();

// æ£€æŸ¥markdownæ•°æ®å˜åŒ–å¹¶æ›´æ–°æ–‡æ¡£æ ‡é¢˜
function checkMarkdownDataChange() {
  const currentMarkdownData = localStorage.getItem('mindword_markdown_data');
  const currentActiveId = mw_getActive();

  // å¦‚æœæ²¡æœ‰æ´»åŠ¨æ–‡æ¡£ä½†æœ‰markdownæ•°æ®ï¼Œåˆ›å»ºæ–°æ–‡æ¡£
  if (!currentActiveId && currentMarkdownData && currentMarkdownData !== lastMarkdownData) {
    lastMarkdownData = currentMarkdownData;

    const docs = mw_loadDocs();
    const newId = 'doc_' + Date.now();
    const name = mw_extractTitleFromMd(currentMarkdownData) || 'æœªå‘½åæ–‡æ¡£';

    const doc = {
      id: newId,
      name,
      md: currentMarkdownData,
      images: [],
      createdAt: Date.now(),
      updatedAt: Date.now(),
      version: 1
    };

    docs.push(doc);
    mw_saveDocs(docs);
    mw_setActive(newId);
    mw_renderList();

    // é€šçŸ¥å„é¢æ¿åŠ è½½æ–°æ–‡æ¡£
    mw_notifyEditorLoad(doc);
    mw_notifyPreviewLoad(doc);
    mw_notifyMindmapLoad(doc);

    try { showSuccess && showSuccess('å·²åˆ›å»ºæ–°æ–‡æ¡£'); } catch (_) { }
    return;
  }

  // æ£€æŸ¥æ˜¯å¦æœ‰æ´»åŠ¨æ–‡æ¡£ä¸”markdownæ•°æ®å‘ç”Ÿå˜åŒ–
  if (currentActiveId && currentMarkdownData !== lastMarkdownData) {
    lastMarkdownData = currentMarkdownData;

    const docs = mw_loadDocs();
    const idx = docs.findIndex(d => d.id === currentActiveId);

    if (idx >= 0 && currentMarkdownData) {
      // æ›´æ–°mdå†…å®¹ï¼ˆæ ¸å¿ƒä¿®å¤ï¼‰
      docs[idx].md = currentMarkdownData;
      docs[idx].updatedAt = Date.now();
      docs[idx].version = (Number(docs[idx].version || 1) + 1);

      // æå–æ–°æ ‡é¢˜
      const newName = mw_extractTitleFromMd(currentMarkdownData);

      // å¦‚æœæ ‡é¢˜å‘ç”Ÿå˜åŒ–ï¼Œæ›´æ–°æ–‡æ¡£ä¿¡æ¯
      if (newName && docs[idx].name !== newName) {
        docs[idx].name = newName;
      }

      // ä¿å­˜æ–‡æ¡£åˆ—è¡¨å¹¶åˆ·æ–°æ˜¾ç¤º
      mw_saveDocs(docs);
      mw_renderList();

      try { showSuccess && showSuccess('æ–‡æ¡£å†…å®¹å·²æ›´æ–°'); } catch (_) { }
    }
  }

  // æ£€æŸ¥æ´»åŠ¨æ–‡æ¡£æ˜¯å¦å‘ç”Ÿå˜åŒ–
  if (currentActiveId !== lastActiveDocId) {
    lastActiveDocId = currentActiveId;
    lastMarkdownData = currentMarkdownData;
  }
}

// è®¾ç½®localStorageç›‘å¬å™¨
window.addEventListener('storage', function (e) {
  if (e.key === 'mindword_markdown_data') {
    checkMarkdownDataChange();
  }
});

/**
 * æ¸…ç†æŒ‡å®šæ–‡æ¡£çš„æœªä½¿ç”¨å›¾ç‰‡
 * @param {string} docId - æ–‡æ¡£ID
 * @returns {Promise<Object>} æ¸…ç†ç»“æœ {removed: number, message: string}
 */
async function mw_cleanupDocImages(docId) {
  if (!window.imageStorage) {
    throw new Error('å›¾ç‰‡å­˜å‚¨ç®¡ç†å™¨æœªåˆå§‹åŒ–');
  }

  try {
    const docs = mw_loadDocs();
    const doc = docs.find(d => d.id === docId);
    if (!doc) {
      throw new Error('æ–‡æ¡£ä¸å­˜åœ¨');
    }

    // ä»æ–‡æ¡£å†…å®¹ä¸­æå–æ‰€æœ‰å›¾ç‰‡ID
    const usedImageIds = new Set();
    const imageRegex = /!\[[^\]]*\]\(([^)]+)\)/g;
    let match;
    while ((match = imageRegex.exec(doc.md || '')) !== null) {
      const imageId = match[1];
      if (imageId && !imageId.match(/^(https?:\/\/|data:)/)) {
        usedImageIds.add(imageId);
      }
    }

    // è·å–æ–‡æ¡£ä¸­å­˜å‚¨çš„å›¾ç‰‡IDåˆ—è¡¨
    const docImageIds = new Set((doc.images || []).map(img => img.id));

    // åªè·å–å½“å‰æ–‡æ¡£çš„å›¾ç‰‡IDï¼ˆé€šè¿‡documentIdè¿‡æ»¤ï¼‰
    const allImagesMap = await window.imageStorage.getImagesMap(docId);
    const allImageIds = new Set(allImagesMap.keys());

    // æ‰¾å‡ºå½“å‰æ–‡æ¡£æœªä½¿ç”¨çš„å›¾ç‰‡IDï¼ˆåœ¨å½“å‰æ–‡æ¡£çš„IndexedDBä¸­ä½†ä¸åœ¨æ–‡æ¡£å†…å®¹ä¸­ï¼‰
    const unusedImageIds = [];
    for (const imageId of allImageIds) {
      if (!usedImageIds.has(imageId)) {
        unusedImageIds.push(imageId);
      }
    }

    if (unusedImageIds.length === 0) {
      return { removed: 0, message: 'æ²¡æœ‰éœ€è¦æ¸…ç†çš„å›¾ç‰‡' };
    }

    // åˆ é™¤æœªä½¿ç”¨çš„å›¾ç‰‡
    let removedCount = 0;
    for (const imageId of unusedImageIds) {
      try {
        await window.imageStorage.deleteImage(imageId);
        removedCount++;
      } catch (error) {
        console.warn(`åˆ é™¤å›¾ç‰‡ ${imageId} å¤±è´¥:`, error);
      }
    }

    // æ›´æ–°æ–‡æ¡£ä¸­çš„å›¾ç‰‡åˆ—è¡¨ï¼Œç§»é™¤å·²åˆ é™¤çš„å›¾ç‰‡
    if (doc.images && doc.images.length > 0) {
      doc.images = doc.images.filter(img => !unusedImageIds.includes(img.id));
      doc.updatedAt = Date.now();
      doc.version = (Number(doc.version || 1) + 1);

      // ä¿å­˜æ›´æ–°åçš„æ–‡æ¡£
      const docIndex = docs.findIndex(d => d.id === docId);
      if (docIndex >= 0) {
        docs[docIndex] = doc;
        mw_saveDocs(docs);
      }
    }

    const message = `å·²æ¸…ç† ${removedCount} å¼ æœªä½¿ç”¨å›¾ç‰‡`;
    try { showSuccess && showSuccess(message); } catch (_) { }

    return { removed: removedCount, message };
  } catch (error) {
    const errorMessage = `å›¾ç‰‡æ¸…ç†å¤±è´¥ï¼š${error.message}`;
    try { showError && showError(errorMessage); } catch (_) { }
    throw new Error(errorMessage);
  }
}

/**
 * æ¸…ç†æ‰€æœ‰æ–‡æ¡£çš„æœªä½¿ç”¨å›¾ç‰‡ï¼ˆè·¨æ–‡æ¡£æ¸…ç†ï¼‰
 * @returns {Promise<Object>} æ¸…ç†ç»“æœ {removed: number, message: string}
 */
async function mw_cleanupAllUnusedImages() {
  if (!window.imageStorage) {
    throw new Error('å›¾ç‰‡å­˜å‚¨ç®¡ç†å™¨æœªåˆå§‹åŒ–');
  }

  try {
    const docs = mw_loadDocs();

    // æ”¶é›†æ‰€æœ‰æ–‡æ¡£ä¸­ä½¿ç”¨çš„å›¾ç‰‡ID
    const allUsedImageIds = new Set();
    docs.forEach(doc => {
      if (doc.md) {
        const imageRegex = /!\[[^\]]*\]\(([^)]+)\)/g;
        let match;
        while ((match = imageRegex.exec(doc.md)) !== null) {
          const imageId = match[1];
          if (imageId && !imageId.match(/^(https?:\/\/|data:)/)) {
            allUsedImageIds.add(imageId);
          }
        }
      }
    });

    // è·å–IndexedDBä¸­çš„æ‰€æœ‰å›¾ç‰‡ID
    const allImagesMap = await window.imageStorage.getImagesMap();
    const allImageIds = new Set(allImagesMap.keys());

    // æ‰¾å‡ºå®Œå…¨æœªä½¿ç”¨çš„å›¾ç‰‡IDï¼ˆåœ¨æ‰€æœ‰æ–‡æ¡£ä¸­éƒ½ä¸ä½¿ç”¨ï¼‰
    const unusedImageIds = [];
    for (const imageId of allImageIds) {
      if (!allUsedImageIds.has(imageId)) {
        unusedImageIds.push(imageId);
      }
    }

    if (unusedImageIds.length === 0) {
      return { removed: 0, message: 'æ²¡æœ‰éœ€è¦æ¸…ç†çš„å›¾ç‰‡' };
    }

    // åˆ é™¤æœªä½¿ç”¨çš„å›¾ç‰‡
    let removedCount = 0;
    for (const imageId of unusedImageIds) {
      try {
        await window.imageStorage.deleteImage(imageId);
        removedCount++;
      } catch (error) {
        console.warn(`åˆ é™¤å›¾ç‰‡ ${imageId} å¤±è´¥:`, error);
      }
    }

    const message = `å·²æ¸…ç† ${removedCount} å¼ è·¨æ–‡æ¡£æœªä½¿ç”¨å›¾ç‰‡`;
    try { showSuccess && showSuccess(message); } catch (_) { }

    return { removed: removedCount, message };
  } catch (error) {
    const errorMessage = `è·¨æ–‡æ¡£å›¾ç‰‡æ¸…ç†å¤±è´¥ï¼š${error.message}`;
    try { showError && showError(errorMessage); } catch (_) { }
    throw new Error(errorMessage);
  }
}

// å®šæœŸæ£€æŸ¥localStorageå˜åŒ–ï¼ˆç”¨äºåŒä¸€é¡µé¢å†…çš„å˜åŒ–ï¼‰
setInterval(checkMarkdownDataChange, 1000);
